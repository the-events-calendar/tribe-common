/**
 * MCP Server for The Events Calendar - Angie Integration
 * 
 * This file is auto-generated by the MCP server build process.
 * DO NOT EDIT MANUALLY - changes will be lost on next build.
 * 
 * Generated on: 2025-08-25 14:12:12.038
 * 
 * Usage:
 * 1. Ensure WordPress API settings are available:
 *    window.wpApiSettings = { root: '...', nonce: '...' }
 * 
 * 2. Include this file:
 *    <script src="tec-mcp-server.js"></script>
 * 
 * 3. The server will auto-initialize when DOM is ready
 * 
 * 4. Access via global variable:
 *    console.log(window.TEC_MCP);
 *    console.log(window.TEC_MCP.server);
 *    console.log(window.TEC_MCP.tools);
 * 
 * @package TheEventsCalendar
 * @subpackage MCP_Angie
 */
"use strict";
var TEC_MCP = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/dayjs/plugin/quarterOfYear.js
  var require_quarterOfYear = __commonJS({
    "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module) {
      !function(t2, n2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = n2() : "function" == typeof define && define.amd ? define(n2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs_plugin_quarterOfYear = n2();
      }(exports, function() {
        "use strict";
        var t2 = "month", n2 = "quarter";
        return function(e2, i2) {
          var r2 = i2.prototype;
          r2.quarter = function(t3) {
            return this.$utils().u(t3) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t3 - 1));
          };
          var s2 = r2.add;
          r2.add = function(e3, i3) {
            return e3 = Number(e3), this.$utils().p(i3) === n2 ? this.add(3 * e3, t2) : s2.bind(this)(e3, i3);
          };
          var u2 = r2.startOf;
          r2.startOf = function(e3, i3) {
            var r3 = this.$utils(), s3 = !!r3.u(i3) || i3;
            if (r3.p(e3) === n2) {
              var o2 = this.quarter() - 1;
              return s3 ? this.month(3 * o2).startOf(t2).startOf("day") : this.month(3 * o2 + 2).endOf(t2).endOf("day");
            }
            return u2.bind(this)(e3, i3);
          };
        };
      });
    }
  });

  // node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "node_modules/dayjs/dayjs.min.js"(exports, module) {
      !function(t2, e2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e2();
      }(exports, function() {
        "use strict";
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date()) return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = "$isDayjsObject", S2 = function(t3) {
          return t3 instanceof _2 || !(!t3 || !t3[p2]);
        }, w2 = function t3(e3, n3, r3) {
          var i3;
          if (!e3) return g2;
          if ("string" == typeof e3) {
            var s3 = e3.toLowerCase();
            D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
            var u3 = e3.split("-");
            if (!i3 && u3.length > 1) return t3(u3[0]);
          } else {
            var a3 = e3.name;
            D2[a3] = e3, i3 = a3;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, O2 = function(t3, e3) {
          if (S2(t3)) return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _2(n3);
        }, b2 = v2;
        b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
          return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _2 = function() {
          function M3(t3) {
            this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3) return /* @__PURE__ */ new Date(NaN);
              if (b2.u(e3)) return /* @__PURE__ */ new Date();
              if (e3 instanceof Date) return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($2);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return b2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e3) {
            var n3 = O2(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return O2(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < O2(t3);
          }, m3.$g = function(t3, e3, n3) {
            return b2.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
              var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i3 : i3.endOf(a2);
            }, $3 = function(t4, e4) {
              return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c2:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a2:
              case d2:
                return $3(v3 + "Hours", 0);
              case u2:
                return $3(v3 + "Minutes", 1);
              case s2:
                return $3(v3 + "Seconds", 2);
              case i2:
                return $3(v3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
            if (o3 === c2 || o3 === h2) {
              var y3 = this.clone().set(d2, 1);
              y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
            } else l3 && this.$d[l3]($3);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[b2.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $3 = b2.p(f3), y3 = function(t3) {
              var e3 = O2(l3);
              return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
            };
            if ($3 === c2) return this.set(c2, this.$M + r3);
            if ($3 === h2) return this.set(h2, this.$y + r3);
            if ($3 === a2) return y3(1);
            if ($3 === o2) return y3(7);
            var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
            return b2.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
              return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
            }, d3 = function(t4) {
              return b2.s(s3 % 12 || 12, t4, "0");
            }, $3 = f3 || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y2, function(t4, r4) {
              return r4 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b2.s(e3.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return b2.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a3, c3, 3);
                  case "MMMM":
                    return h3(c3, a3);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b2.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e3.$W, o3, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e3.$W, o3, 3);
                  case "dddd":
                    return o3[e3.$W];
                  case "H":
                    return String(s3);
                  case "HH":
                    return b2.s(s3, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $3(s3, u3, true);
                  case "A":
                    return $3(s3, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b2.s(u3, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b2.s(e3.$s, 2, "0");
                  case "SSS":
                    return b2.s(e3.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              }(t4) || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $3, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
              return b2.m(y3, m4);
            };
            switch (M4) {
              case h2:
                $3 = D3() / 12;
                break;
              case c2:
                $3 = D3();
                break;
              case f2:
                $3 = D3() / 3;
                break;
              case o2:
                $3 = (g3 - v3) / 6048e5;
                break;
              case a2:
                $3 = (g3 - v3) / 864e5;
                break;
              case u2:
                $3 = g3 / n2;
                break;
              case s2:
                $3 = g3 / e2;
                break;
              case i2:
                $3 = g3 / t2;
                break;
              default:
                $3 = g3;
            }
            return l3 ? $3 : b2.a($3);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3) return this.$L;
            var n3 = this.clone(), r3 = w2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _2.prototype;
        return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
          k2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), O2.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
        }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
          return O2(1e3 * t3);
        }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
      });
    }
  });

  // node_modules/uri-js/dist/es5/uri.all.js
  var require_uri_all = __commonJS({
    "node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.URI = global.URI || {});
      })(exports, function(exports2) {
        "use strict";
        function merge() {
          for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
            sets[_key] = arguments[_key];
          }
          if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for (var x2 = 1; x2 < xl; ++x2) {
              sets[x2] = sets[x2].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join("");
          } else {
            return sets[0];
          }
        }
        function subexp(str) {
          return "(?:" + str + ")";
        }
        function typeOf(o2) {
          return o2 === void 0 ? "undefined" : o2 === null ? "null" : Object.prototype.toString.call(o2).split(" ").pop().split("]").shift().toLowerCase();
        }
        function toUpperCase(str) {
          return str.toUpperCase();
        }
        function toArray(obj) {
          return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
        }
        function assign(target, source) {
          var obj = target;
          if (source) {
            for (var key in source) {
              obj[key] = source[key];
            }
          }
          return obj;
        }
        function buildExps(isIRI2) {
          var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
          return {
            NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
            OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
            //RFC 6874, with relaxed parsing rules
          };
        }
        var URI_PROTOCOL = buildExps(false);
        var IRI_PROTOCOL = buildExps(true);
        var slicedToArray = /* @__PURE__ */ function() {
          function sliceIterator(arr, i2) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e2 = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s2; !(_n = (_s2 = _i.next()).done); _n = true) {
                _arr.push(_s2.value);
                if (i2 && _arr.length === i2) break;
              }
            } catch (err) {
              _d = true;
              _e2 = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e2;
              }
            }
            return _arr;
          }
          return function(arr, i2) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i2);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var toConsumableArray = function(arr) {
          if (Array.isArray(arr)) {
            for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) arr2[i2] = arr[i2];
            return arr2;
          } else {
            return Array.from(arr);
          }
        };
        var maxInt = 2147483647;
        var base = 36;
        var tMin = 1;
        var tMax = 26;
        var skew = 38;
        var damp = 700;
        var initialBias = 72;
        var initialN = 128;
        var delimiter = "-";
        var regexPunycode = /^xn--/;
        var regexNonASCII = /[^\0-\x7E]/;
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
        var errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        };
        var baseMinusTMin = base - tMin;
        var floor = Math.floor;
        var stringFromCharCode = String.fromCharCode;
        function error$1(type) {
          throw new RangeError(errors[type]);
        }
        function map(array, fn) {
          var result = [];
          var length = array.length;
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          while (counter < length) {
            var value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              var extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        var ucs2encode = function ucs2encode2(array) {
          return String.fromCodePoint.apply(String, toConsumableArray(array));
        };
        var basicToDigit = function basicToDigit2(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        };
        var digitToBasic = function digitToBasic2(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        };
        var adapt = function adapt2(delta, numPoints, firstTime) {
          var k2 = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (
            ;
            /* no initialization */
            delta > baseMinusTMin * tMax >> 1;
            k2 += base
          ) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
        };
        var decode = function decode2(input) {
          var output = [];
          var inputLength = input.length;
          var i2 = 0;
          var n2 = initialN;
          var bias = initialBias;
          var basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (var j2 = 0; j2 < basic; ++j2) {
            if (input.charCodeAt(j2) >= 128) {
              error$1("not-basic");
            }
            output.push(input.charCodeAt(j2));
          }
          for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            var oldi = i2;
            for (
              var w2 = 1, k2 = base;
              ;
              /* no condition */
              k2 += base
            ) {
              if (index >= inputLength) {
                error$1("invalid-input");
              }
              var digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i2) / w2)) {
                error$1("overflow");
              }
              i2 += digit * w2;
              var t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (digit < t2) {
                break;
              }
              var baseMinusT = base - t2;
              if (w2 > floor(maxInt / baseMinusT)) {
                error$1("overflow");
              }
              w2 *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i2 - oldi, out, oldi == 0);
            if (floor(i2 / out) > maxInt - n2) {
              error$1("overflow");
            }
            n2 += floor(i2 / out);
            i2 %= out;
            output.splice(i2++, 0, n2);
          }
          return String.fromCodePoint.apply(String, output);
        };
        var encode = function encode2(input) {
          var output = [];
          input = ucs2decode(input);
          var inputLength = input.length;
          var n2 = initialN;
          var delta = 0;
          var bias = initialBias;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _currentValue2 = _step.value;
              if (_currentValue2 < 128) {
                output.push(stringFromCharCode(_currentValue2));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          var basicLength = output.length;
          var handledCPCount = basicLength;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            var m2 = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var currentValue = _step2.value;
                if (currentValue >= n2 && currentValue < m2) {
                  m2 = currentValue;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error$1("overflow");
            }
            delta += (m2 - n2) * handledCPCountPlusOne;
            n2 = m2;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _currentValue = _step3.value;
                if (_currentValue < n2 && ++delta > maxInt) {
                  error$1("overflow");
                }
                if (_currentValue == n2) {
                  var q2 = delta;
                  for (
                    var k2 = base;
                    ;
                    /* no condition */
                    k2 += base
                  ) {
                    var t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                    if (q2 < t2) {
                      break;
                    }
                    var qMinusT = q2 - t2;
                    var baseMinusT = base - t2;
                    output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                    q2 = floor(qMinusT / baseMinusT);
                  }
                  output.push(stringFromCharCode(digitToBasic(q2, 0)));
                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta = 0;
                  ++handledCPCount;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
            ++delta;
            ++n2;
          }
          return output.join("");
        };
        var toUnicode = function toUnicode2(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        };
        var toASCII = function toASCII2(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        };
        var punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          "version": "2.1.0",
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        var SCHEMES = {};
        function pctEncChar(chr) {
          var c2 = chr.charCodeAt(0);
          var e2 = void 0;
          if (c2 < 16) e2 = "%0" + c2.toString(16).toUpperCase();
          else if (c2 < 128) e2 = "%" + c2.toString(16).toUpperCase();
          else if (c2 < 2048) e2 = "%" + (c2 >> 6 | 192).toString(16).toUpperCase() + "%" + (c2 & 63 | 128).toString(16).toUpperCase();
          else e2 = "%" + (c2 >> 12 | 224).toString(16).toUpperCase() + "%" + (c2 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c2 & 63 | 128).toString(16).toUpperCase();
          return e2;
        }
        function pctDecChars(str) {
          var newStr = "";
          var i2 = 0;
          var il = str.length;
          while (i2 < il) {
            var c2 = parseInt(str.substr(i2 + 1, 2), 16);
            if (c2 < 128) {
              newStr += String.fromCharCode(c2);
              i2 += 3;
            } else if (c2 >= 194 && c2 < 224) {
              if (il - i2 >= 6) {
                var c22 = parseInt(str.substr(i2 + 4, 2), 16);
                newStr += String.fromCharCode((c2 & 31) << 6 | c22 & 63);
              } else {
                newStr += str.substr(i2, 6);
              }
              i2 += 6;
            } else if (c2 >= 224) {
              if (il - i2 >= 9) {
                var _c = parseInt(str.substr(i2 + 4, 2), 16);
                var c3 = parseInt(str.substr(i2 + 7, 2), 16);
                newStr += String.fromCharCode((c2 & 15) << 12 | (_c & 63) << 6 | c3 & 63);
              } else {
                newStr += str.substr(i2, 9);
              }
              i2 += 9;
            } else {
              newStr += str.substr(i2, 3);
              i2 += 3;
            }
          }
          return newStr;
        }
        function _normalizeComponentEncoding(components, protocol) {
          function decodeUnreserved2(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
          }
          if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
          if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          return components;
        }
        function _stripLeadingZeros(str) {
          return str.replace(/^0*(.*)/, "$1") || "0";
        }
        function _normalizeIPv4(host, protocol) {
          var matches = host.match(protocol.IPV4ADDRESS) || [];
          var _matches = slicedToArray(matches, 2), address = _matches[1];
          if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
          } else {
            return host;
          }
        }
        function _normalizeIPv6(host, protocol) {
          var matches = host.match(protocol.IPV6ADDRESS) || [];
          var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
          if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for (var x2 = 0; x2 < fieldCount; ++x2) {
              fields[x2] = firstFields[x2] || lastFields[lastFieldsStart + x2] || "";
            }
            if (isLastFieldIPv4Address) {
              fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function(acc, field, index) {
              if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                  lastLongest.length++;
                } else {
                  acc.push({ index, length: 1 });
                }
              }
              return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a2, b2) {
              return b2.length - a2.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
              var newFirst = fields.slice(0, longestZeroFields.index);
              var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
              newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
              newHost = fields.join(":");
            }
            if (zone) {
              newHost += "%" + zone;
            }
            return newHost;
          } else {
            return host;
          }
        }
        var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
        var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
        function parse2(uriString) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var components = {};
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
          var matches = uriString.match(URI_PARSE);
          if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
              components.scheme = matches[1];
              components.userinfo = matches[3];
              components.host = matches[4];
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = matches[7];
              components.fragment = matches[8];
              if (isNaN(components.port)) {
                components.port = matches[5];
              }
            } else {
              components.scheme = matches[1] || void 0;
              components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
              components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
              components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
              if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
              }
            }
            if (components.host) {
              components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
              components.reference = "same-document";
            } else if (components.scheme === void 0) {
              components.reference = "relative";
            } else if (components.fragment === void 0) {
              components.reference = "absolute";
            } else {
              components.reference = "uri";
            }
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
              components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
              if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                try {
                  components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e2) {
                  components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e2;
                }
              }
              _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
              _normalizeComponentEncoding(components, protocol);
            }
            if (schemeHandler && schemeHandler.parse) {
              schemeHandler.parse(components, options);
            }
          } else {
            components.error = components.error || "URI can not be parsed.";
          }
          return components;
        }
        function _recomposeAuthority(components, options) {
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          if (components.userinfo !== void 0) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
          }
          if (components.host !== void 0) {
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_2, $1, $2) {
              return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
          }
          if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
          }
          return uriTokens.length ? uriTokens.join("") : void 0;
        }
        var RDS1 = /^\.\.?\//;
        var RDS2 = /^\/\.(\/|$)/;
        var RDS3 = /^\/\.\.(\/|$)/;
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
        function removeDotSegments(input) {
          var output = [];
          while (input.length) {
            if (input.match(RDS1)) {
              input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
              input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
              input = input.replace(RDS3, "/");
              output.pop();
            } else if (input === "." || input === "..") {
              input = "";
            } else {
              var im = input.match(RDS5);
              if (im) {
                var s2 = im[0];
                input = input.slice(s2.length);
                output.push(s2);
              } else {
                throw new Error("Unexpected dot segment condition");
              }
            }
          }
          return output.join("");
        }
        function serialize(components) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
          if (components.host) {
            if (protocol.IPV6ADDRESS.test(components.host)) {
            } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
              try {
                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
              } catch (e2) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e2;
              }
            }
          }
          _normalizeComponentEncoding(components, protocol);
          if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
          }
          var authority = _recomposeAuthority(components, options);
          if (authority !== void 0) {
            if (options.reference !== "suffix") {
              uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
              uriTokens.push("/");
            }
          }
          if (components.path !== void 0) {
            var s2 = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
              s2 = removeDotSegments(s2);
            }
            if (authority === void 0) {
              s2 = s2.replace(/^\/\//, "/%2F");
            }
            uriTokens.push(s2);
          }
          if (components.query !== void 0) {
            uriTokens.push("?");
            uriTokens.push(components.query);
          }
          if (components.fragment !== void 0) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
          }
          return uriTokens.join("");
        }
        function resolveComponents(base2, relative) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var skipNormalization = arguments[3];
          var target = {};
          if (!skipNormalization) {
            base2 = parse2(serialize(base2, options), options);
            relative = parse2(serialize(relative, options), options);
          }
          options = options || {};
          if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
              target.userinfo = relative.userinfo;
              target.host = relative.host;
              target.port = relative.port;
              target.path = removeDotSegments(relative.path || "");
              target.query = relative.query;
            } else {
              if (!relative.path) {
                target.path = base2.path;
                if (relative.query !== void 0) {
                  target.query = relative.query;
                } else {
                  target.query = base2.query;
                }
              } else {
                if (relative.path.charAt(0) === "/") {
                  target.path = removeDotSegments(relative.path);
                } else {
                  if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                    target.path = "/" + relative.path;
                  } else if (!base2.path) {
                    target.path = relative.path;
                  } else {
                    target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                  }
                  target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
              }
              target.userinfo = base2.userinfo;
              target.host = base2.host;
              target.port = base2.port;
            }
            target.scheme = base2.scheme;
          }
          target.fragment = relative.fragment;
          return target;
        }
        function resolve(baseURI, relativeURI, options) {
          var schemelessOptions = assign({ scheme: "null" }, options);
          return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
        }
        function normalize(uri, options) {
          if (typeof uri === "string") {
            uri = serialize(parse2(uri, options), options);
          } else if (typeOf(uri) === "object") {
            uri = parse2(serialize(uri, options), options);
          }
          return uri;
        }
        function equal(uriA, uriB, options) {
          if (typeof uriA === "string") {
            uriA = serialize(parse2(uriA, options), options);
          } else if (typeOf(uriA) === "object") {
            uriA = serialize(uriA, options);
          }
          if (typeof uriB === "string") {
            uriB = serialize(parse2(uriB, options), options);
          } else if (typeOf(uriB) === "object") {
            uriB = serialize(uriB, options);
          }
          return uriA === uriB;
        }
        function escapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
        }
        function unescapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
        }
        var handler = {
          scheme: "http",
          domainHost: true,
          parse: function parse3(components, options) {
            if (!components.host) {
              components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
          },
          serialize: function serialize2(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            if (components.port === (secure ? 443 : 80) || components.port === "") {
              components.port = void 0;
            }
            if (!components.path) {
              components.path = "/";
            }
            return components;
          }
        };
        var handler$1 = {
          scheme: "https",
          domainHost: handler.domainHost,
          parse: handler.parse,
          serialize: handler.serialize
        };
        function isSecure(wsComponents) {
          return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
        }
        var handler$2 = {
          scheme: "ws",
          domainHost: true,
          parse: function parse3(components, options) {
            var wsComponents = components;
            wsComponents.secure = isSecure(wsComponents);
            wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
            wsComponents.path = void 0;
            wsComponents.query = void 0;
            return wsComponents;
          },
          serialize: function serialize2(wsComponents, options) {
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
              wsComponents.port = void 0;
            }
            if (typeof wsComponents.secure === "boolean") {
              wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
              wsComponents.secure = void 0;
            }
            if (wsComponents.resourceName) {
              var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
              wsComponents.path = path && path !== "/" ? path : void 0;
              wsComponents.query = query;
              wsComponents.resourceName = void 0;
            }
            wsComponents.fragment = void 0;
            return wsComponents;
          }
        };
        var handler$3 = {
          scheme: "wss",
          domainHost: handler$2.domainHost,
          parse: handler$2.parse,
          serialize: handler$2.serialize
        };
        var O2 = {};
        var isIRI = true;
        var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
        var HEXDIG$$ = "[0-9A-Fa-f]";
        var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
        var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
        var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
        var UNRESERVED = new RegExp(UNRESERVED$$, "g");
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
        var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
        var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
        var NOT_HFVALUE = NOT_HFNAME;
        function decodeUnreserved(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(UNRESERVED) ? str : decStr;
        }
        var handler$4 = {
          scheme: "mailto",
          parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = void 0;
            if (mailtoComponents.query) {
              var unknownHeaders = false;
              var headers = {};
              var hfields = mailtoComponents.query.split("&");
              for (var x2 = 0, xl = hfields.length; x2 < xl; ++x2) {
                var hfield = hfields[x2].split("=");
                switch (hfield[0]) {
                  case "to":
                    var toAddrs = hfield[1].split(",");
                    for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                      to.push(toAddrs[_x]);
                    }
                    break;
                  case "subject":
                    mailtoComponents.subject = unescapeComponent(hfield[1], options);
                    break;
                  case "body":
                    mailtoComponents.body = unescapeComponent(hfield[1], options);
                    break;
                  default:
                    unknownHeaders = true;
                    headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                    break;
                }
              }
              if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = void 0;
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
              var addr = to[_x2].split("@");
              addr[0] = unescapeComponent(addr[0]);
              if (!options.unicodeSupport) {
                try {
                  addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e2) {
                  mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e2;
                }
              } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
              }
              to[_x2] = addr.join("@");
            }
            return mailtoComponents;
          },
          serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
              for (var x2 = 0, xl = to.length; x2 < xl; ++x2) {
                var toAddr = String(to[x2]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                try {
                  domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e2) {
                  components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e2;
                }
                to[x2] = localPart + "@" + domain;
              }
              components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for (var name in headers) {
              if (headers[name] !== O2[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
              }
            }
            if (fields.length) {
              components.query = fields.join("&");
            }
            return components;
          }
        };
        var URN_PARSE = /^([^\:]+)\:(.*)/;
        var handler$5 = {
          scheme: "urn",
          parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
              var scheme = options.scheme || urnComponents.scheme || "urn";
              var nid = matches[1].toLowerCase();
              var nss = matches[2];
              var urnScheme = scheme + ":" + (options.nid || nid);
              var schemeHandler = SCHEMES[urnScheme];
              urnComponents.nid = nid;
              urnComponents.nss = nss;
              urnComponents.path = void 0;
              if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
              }
            } else {
              urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
          },
          serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
              urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
          }
        };
        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
        var handler$6 = {
          scheme: "urn:uuid",
          parse: function parse3(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = void 0;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
              uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
          },
          serialize: function serialize2(uuidComponents, options) {
            var urnComponents = uuidComponents;
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
          }
        };
        SCHEMES[handler.scheme] = handler;
        SCHEMES[handler$1.scheme] = handler$1;
        SCHEMES[handler$2.scheme] = handler$2;
        SCHEMES[handler$3.scheme] = handler$3;
        SCHEMES[handler$4.scheme] = handler$4;
        SCHEMES[handler$5.scheme] = handler$5;
        SCHEMES[handler$6.scheme] = handler$6;
        exports2.SCHEMES = SCHEMES;
        exports2.pctEncChar = pctEncChar;
        exports2.pctDecChars = pctDecChars;
        exports2.parse = parse2;
        exports2.removeDotSegments = removeDotSegments;
        exports2.serialize = serialize;
        exports2.resolveComponents = resolveComponents;
        exports2.resolve = resolve;
        exports2.normalize = normalize;
        exports2.equal = equal;
        exports2.escapeComponent = escapeComponent;
        exports2.unescapeComponent = unescapeComponent;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      module.exports = function equal(a2, b2) {
        if (a2 === b2) return true;
        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
          if (a2.constructor !== b2.constructor) return false;
          var length, i2, keys;
          if (Array.isArray(a2)) {
            length = a2.length;
            if (length != b2.length) return false;
            for (i2 = length; i2-- !== 0; )
              if (!equal(a2[i2], b2[i2])) return false;
            return true;
          }
          if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
          if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
          if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
          keys = Object.keys(a2);
          length = keys.length;
          if (length !== Object.keys(b2).length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
          for (i2 = length; i2-- !== 0; ) {
            var key = keys[i2];
            if (!equal(a2[key], b2[key])) return false;
          }
          return true;
        }
        return a2 !== a2 && b2 !== b2;
      };
    }
  });

  // node_modules/ajv/lib/compile/ucs2length.js
  var require_ucs2length = __commonJS({
    "node_modules/ajv/lib/compile/ucs2length.js"(exports, module) {
      "use strict";
      module.exports = function ucs2length(str) {
        var length = 0, len = str.length, pos = 0, value;
        while (pos < len) {
          length++;
          value = str.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319 && pos < len) {
            value = str.charCodeAt(pos);
            if ((value & 64512) == 56320) pos++;
          }
        }
        return length;
      };
    }
  });

  // node_modules/ajv/lib/compile/util.js
  var require_util = __commonJS({
    "node_modules/ajv/lib/compile/util.js"(exports, module) {
      "use strict";
      module.exports = {
        copy,
        checkDataType,
        checkDataTypes,
        coerceToTypes,
        toHash,
        getProperty,
        escapeQuotes,
        equal: require_fast_deep_equal(),
        ucs2length: require_ucs2length(),
        varOccurences,
        varReplace,
        schemaHasRules,
        schemaHasRulesExcept,
        schemaUnknownRules,
        toQuotedString,
        getPathExpr,
        getPath,
        getData,
        unescapeFragment,
        unescapeJsonPointer,
        escapeFragment,
        escapeJsonPointer
      };
      function copy(o2, to) {
        to = to || {};
        for (var key in o2) to[key] = o2[key];
        return to;
      }
      function checkDataType(dataType, data, strictNumbers, negate) {
        var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK2 = negate ? "!" : "", NOT = negate ? "" : "!";
        switch (dataType) {
          case "null":
            return data + EQUAL + "null";
          case "array":
            return OK2 + "Array.isArray(" + data + ")";
          case "object":
            return "(" + OK2 + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
          case "integer":
            return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK2 + "isFinite(" + data + ")" : "") + ")";
          case "number":
            return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK2 + "isFinite(" + data + ")" : "") + ")";
          default:
            return "typeof " + data + EQUAL + '"' + dataType + '"';
        }
      }
      function checkDataTypes(dataTypes, data, strictNumbers) {
        switch (dataTypes.length) {
          case 1:
            return checkDataType(dataTypes[0], data, strictNumbers, true);
          default:
            var code = "";
            var types = toHash(dataTypes);
            if (types.array && types.object) {
              code = types.null ? "(" : "(!" + data + " || ";
              code += "typeof " + data + ' !== "object")';
              delete types.null;
              delete types.array;
              delete types.object;
            }
            if (types.number) delete types.integer;
            for (var t2 in types)
              code += (code ? " && " : "") + checkDataType(t2, data, strictNumbers, true);
            return code;
        }
      }
      var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(optionCoerceTypes, dataTypes) {
        if (Array.isArray(dataTypes)) {
          var types = [];
          for (var i2 = 0; i2 < dataTypes.length; i2++) {
            var t2 = dataTypes[i2];
            if (COERCE_TO_TYPES[t2]) types[types.length] = t2;
            else if (optionCoerceTypes === "array" && t2 === "array") types[types.length] = t2;
          }
          if (types.length) return types;
        } else if (COERCE_TO_TYPES[dataTypes]) {
          return [dataTypes];
        } else if (optionCoerceTypes === "array" && dataTypes === "array") {
          return ["array"];
        }
      }
      function toHash(arr) {
        var hash = {};
        for (var i2 = 0; i2 < arr.length; i2++) hash[arr[i2]] = true;
        return hash;
      }
      var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      var SINGLE_QUOTE = /'|\\/g;
      function getProperty(key) {
        return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
      }
      function escapeQuotes(str) {
        return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
      }
      function varOccurences(str, dataVar) {
        dataVar += "[^0-9]";
        var matches = str.match(new RegExp(dataVar, "g"));
        return matches ? matches.length : 0;
      }
      function varReplace(str, dataVar, expr) {
        dataVar += "([^0-9])";
        expr = expr.replace(/\$/g, "$$$$");
        return str.replace(new RegExp(dataVar, "g"), expr + "$1");
      }
      function schemaHasRules(schema, rules) {
        if (typeof schema == "boolean") return !schema;
        for (var key in schema) if (rules[key]) return true;
      }
      function schemaHasRulesExcept(schema, rules, exceptKeyword) {
        if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
        for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
      }
      function schemaUnknownRules(schema, rules) {
        if (typeof schema == "boolean") return;
        for (var key in schema) if (!rules[key]) return key;
      }
      function toQuotedString(str) {
        return "'" + escapeQuotes(str) + "'";
      }
      function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
        var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
        return joinPaths(currentPath, path);
      }
      function getPath(currentPath, prop, jsonPointers) {
        var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
        return joinPaths(currentPath, path);
      }
      var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
      var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function getData($data, lvl, paths) {
        var up, jsonPointer, data, matches;
        if ($data === "") return "rootData";
        if ($data[0] == "/") {
          if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
          jsonPointer = $data;
          data = "rootData";
        } else {
          matches = $data.match(RELATIVE_JSON_POINTER);
          if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
          up = +matches[1];
          jsonPointer = matches[2];
          if (jsonPointer == "#") {
            if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
            return paths[lvl - up];
          }
          if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
          data = "data" + (lvl - up || "");
          if (!jsonPointer) return data;
        }
        var expr = data;
        var segments = jsonPointer.split("/");
        for (var i2 = 0; i2 < segments.length; i2++) {
          var segment = segments[i2];
          if (segment) {
            data += getProperty(unescapeJsonPointer(segment));
            expr += " && " + data;
          }
        }
        return expr;
      }
      function joinPaths(a2, b2) {
        if (a2 == '""') return b2;
        return (a2 + " + " + b2).replace(/([^\\])' \+ '/g, "$1");
      }
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
      }
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
      }
      function escapeJsonPointer(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
      }
    }
  });

  // node_modules/ajv/lib/compile/schema_obj.js
  var require_schema_obj = __commonJS({
    "node_modules/ajv/lib/compile/schema_obj.js"(exports, module) {
      "use strict";
      var util2 = require_util();
      module.exports = SchemaObject;
      function SchemaObject(obj) {
        util2.copy(obj, this);
      }
    }
  });

  // node_modules/json-schema-traverse/index.js
  var require_json_schema_traverse = __commonJS({
    "node_modules/json-schema-traverse/index.js"(exports, module) {
      "use strict";
      var traverse = module.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
          cb = opts;
          opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {
        };
        var post = cb.post || function() {
        };
        _traverse(opts, pre, post, schema, "", schema);
      };
      traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true
      };
      traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      };
      traverse.propsKeywords = {
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      };
      traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      };
      function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
          pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          for (var key in schema) {
            var sch = schema[key];
            if (Array.isArray(sch)) {
              if (key in traverse.arrayKeywords) {
                for (var i2 = 0; i2 < sch.length; i2++)
                  _traverse(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
              }
            } else if (key in traverse.propsKeywords) {
              if (sch && typeof sch == "object") {
                for (var prop in sch)
                  _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
              }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
              _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
          }
          post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
      }
      function escapeJsonPtr(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
    }
  });

  // node_modules/ajv/lib/compile/resolve.js
  var require_resolve = __commonJS({
    "node_modules/ajv/lib/compile/resolve.js"(exports, module) {
      "use strict";
      var URI = require_uri_all();
      var equal = require_fast_deep_equal();
      var util2 = require_util();
      var SchemaObject = require_schema_obj();
      var traverse = require_json_schema_traverse();
      module.exports = resolve;
      resolve.normalizeId = normalizeId;
      resolve.fullPath = getFullPath;
      resolve.url = resolveUrl;
      resolve.ids = resolveIds;
      resolve.inlineRef = inlineRef;
      resolve.schema = resolveSchema;
      function resolve(compile, root, ref) {
        var refVal = this._refs[ref];
        if (typeof refVal == "string") {
          if (this._refs[refVal]) refVal = this._refs[refVal];
          else return resolve.call(this, compile, root, refVal);
        }
        refVal = refVal || this._schemas[ref];
        if (refVal instanceof SchemaObject) {
          return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
        }
        var res = resolveSchema.call(this, root, ref);
        var schema, v2, baseId;
        if (res) {
          schema = res.schema;
          root = res.root;
          baseId = res.baseId;
        }
        if (schema instanceof SchemaObject) {
          v2 = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
        } else if (schema !== void 0) {
          v2 = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
        }
        return v2;
      }
      function resolveSchema(root, ref) {
        var p2 = URI.parse(ref), refPath = _getFullPath(p2), baseId = getFullPath(this._getId(root.schema));
        if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
          var id = normalizeId(refPath);
          var refVal = this._refs[id];
          if (typeof refVal == "string") {
            return resolveRecursive.call(this, root, refVal, p2);
          } else if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            root = refVal;
          } else {
            refVal = this._schemas[id];
            if (refVal instanceof SchemaObject) {
              if (!refVal.validate) this._compile(refVal);
              if (id == normalizeId(ref))
                return { schema: refVal, root, baseId };
              root = refVal;
            } else {
              return;
            }
          }
          if (!root.schema) return;
          baseId = getFullPath(this._getId(root.schema));
        }
        return getJsonPointer.call(this, p2, baseId, root.schema, root);
      }
      function resolveRecursive(root, ref, parsedRef) {
        var res = resolveSchema.call(this, root, ref);
        if (res) {
          var schema = res.schema;
          var baseId = res.baseId;
          root = res.root;
          var id = this._getId(schema);
          if (id) baseId = resolveUrl(baseId, id);
          return getJsonPointer.call(this, parsedRef, baseId, schema, root);
        }
      }
      var PREVENT_SCOPE_CHANGE = util2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
      function getJsonPointer(parsedRef, baseId, schema, root) {
        parsedRef.fragment = parsedRef.fragment || "";
        if (parsedRef.fragment.slice(0, 1) != "/") return;
        var parts = parsedRef.fragment.split("/");
        for (var i2 = 1; i2 < parts.length; i2++) {
          var part = parts[i2];
          if (part) {
            part = util2.unescapeFragment(part);
            schema = schema[part];
            if (schema === void 0) break;
            var id;
            if (!PREVENT_SCOPE_CHANGE[part]) {
              id = this._getId(schema);
              if (id) baseId = resolveUrl(baseId, id);
              if (schema.$ref) {
                var $ref = resolveUrl(baseId, schema.$ref);
                var res = resolveSchema.call(this, root, $ref);
                if (res) {
                  schema = res.schema;
                  root = res.root;
                  baseId = res.baseId;
                }
              }
            }
          }
        }
        if (schema !== void 0 && schema !== root.schema)
          return { schema, root, baseId };
      }
      var SIMPLE_INLINED = util2.toHash([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum"
      ]);
      function inlineRef(schema, limit) {
        if (limit === false) return false;
        if (limit === void 0 || limit === true) return checkNoRef(schema);
        else if (limit) return countKeys(schema) <= limit;
      }
      function checkNoRef(schema) {
        var item;
        if (Array.isArray(schema)) {
          for (var i2 = 0; i2 < schema.length; i2++) {
            item = schema[i2];
            if (typeof item == "object" && !checkNoRef(item)) return false;
          }
        } else {
          for (var key in schema) {
            if (key == "$ref") return false;
            item = schema[key];
            if (typeof item == "object" && !checkNoRef(item)) return false;
          }
        }
        return true;
      }
      function countKeys(schema) {
        var count = 0, item;
        if (Array.isArray(schema)) {
          for (var i2 = 0; i2 < schema.length; i2++) {
            item = schema[i2];
            if (typeof item == "object") count += countKeys(item);
            if (count == Infinity) return Infinity;
          }
        } else {
          for (var key in schema) {
            if (key == "$ref") return Infinity;
            if (SIMPLE_INLINED[key]) {
              count++;
            } else {
              item = schema[key];
              if (typeof item == "object") count += countKeys(item) + 1;
              if (count == Infinity) return Infinity;
            }
          }
        }
        return count;
      }
      function getFullPath(id, normalize) {
        if (normalize !== false) id = normalizeId(id);
        var p2 = URI.parse(id);
        return _getFullPath(p2);
      }
      function _getFullPath(p2) {
        return URI.serialize(p2).split("#")[0] + "#";
      }
      var TRAILING_SLASH_HASH = /#\/?$/;
      function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
      }
      function resolveUrl(baseId, id) {
        id = normalizeId(id);
        return URI.resolve(baseId, id);
      }
      function resolveIds(schema) {
        var schemaId = normalizeId(this._getId(schema));
        var baseIds = { "": schemaId };
        var fullPaths = { "": getFullPath(schemaId, false) };
        var localRefs = {};
        var self2 = this;
        traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
          if (jsonPtr === "") return;
          var id = self2._getId(sch);
          var baseId = baseIds[parentJsonPtr];
          var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
          if (keyIndex !== void 0)
            fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util2.escapeFragment(keyIndex));
          if (typeof id == "string") {
            id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
            var refVal = self2._refs[id];
            if (typeof refVal == "string") refVal = self2._refs[refVal];
            if (refVal && refVal.schema) {
              if (!equal(sch, refVal.schema))
                throw new Error('id "' + id + '" resolves to more than one schema');
            } else if (id != normalizeId(fullPath)) {
              if (id[0] == "#") {
                if (localRefs[id] && !equal(sch, localRefs[id]))
                  throw new Error('id "' + id + '" resolves to more than one schema');
                localRefs[id] = sch;
              } else {
                self2._refs[id] = fullPath;
              }
            }
          }
          baseIds[jsonPtr] = baseId;
          fullPaths[jsonPtr] = fullPath;
        });
        return localRefs;
      }
    }
  });

  // node_modules/ajv/lib/compile/error_classes.js
  var require_error_classes = __commonJS({
    "node_modules/ajv/lib/compile/error_classes.js"(exports, module) {
      "use strict";
      var resolve = require_resolve();
      module.exports = {
        Validation: errorSubclass(ValidationError),
        MissingRef: errorSubclass(MissingRefError)
      };
      function ValidationError(errors) {
        this.message = "validation failed";
        this.errors = errors;
        this.ajv = this.validation = true;
      }
      MissingRefError.message = function(baseId, ref) {
        return "can't resolve reference " + ref + " from id " + baseId;
      };
      function MissingRefError(baseId, ref, message) {
        this.message = message || MissingRefError.message(baseId, ref);
        this.missingRef = resolve.url(baseId, ref);
        this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
      }
      function errorSubclass(Subclass) {
        Subclass.prototype = Object.create(Error.prototype);
        Subclass.prototype.constructor = Subclass;
        return Subclass;
      }
    }
  });

  // node_modules/fast-json-stable-stringify/index.js
  var require_fast_json_stable_stringify = __commonJS({
    "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
      "use strict";
      module.exports = function(data, opts) {
        if (!opts) opts = {};
        if (typeof opts === "function") opts = { cmp: opts };
        var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
        var cmp = opts.cmp && /* @__PURE__ */ function(f2) {
          return function(node) {
            return function(a2, b2) {
              var aobj = { key: a2, value: node[a2] };
              var bobj = { key: b2, value: node[b2] };
              return f2(aobj, bobj);
            };
          };
        }(opts.cmp);
        var seen = [];
        return function stringify(node) {
          if (node && node.toJSON && typeof node.toJSON === "function") {
            node = node.toJSON();
          }
          if (node === void 0) return;
          if (typeof node == "number") return isFinite(node) ? "" + node : "null";
          if (typeof node !== "object") return JSON.stringify(node);
          var i2, out;
          if (Array.isArray(node)) {
            out = "[";
            for (i2 = 0; i2 < node.length; i2++) {
              if (i2) out += ",";
              out += stringify(node[i2]) || "null";
            }
            return out + "]";
          }
          if (node === null) return "null";
          if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          }
          var seenIndex = seen.push(node) - 1;
          var keys = Object.keys(node).sort(cmp && cmp(node));
          out = "";
          for (i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ",";
            out += JSON.stringify(key) + ":" + value;
          }
          seen.splice(seenIndex, 1);
          return "{" + out + "}";
        }(data);
      };
    }
  });

  // node_modules/ajv/lib/dotjs/validate.js
  var require_validate = __commonJS({
    "node_modules/ajv/lib/dotjs/validate.js"(exports, module) {
      "use strict";
      module.exports = function generate_validate(it2, $keyword, $ruleType) {
        var out = "";
        var $async = it2.schema.$async === true, $refKeywords = it2.util.schemaHasRulesExcept(it2.schema, it2.RULES.all, "$ref"), $id = it2.self._getId(it2.schema);
        if (it2.opts.strictKeywords) {
          var $unknownKwd = it2.util.schemaUnknownRules(it2.schema, it2.RULES.keywords);
          if ($unknownKwd) {
            var $keywordsMsg = "unknown keyword: " + $unknownKwd;
            if (it2.opts.strictKeywords === "log") it2.logger.warn($keywordsMsg);
            else throw new Error($keywordsMsg);
          }
        }
        if (it2.isTop) {
          out += " var validate = ";
          if ($async) {
            it2.async = true;
            out += "async ";
          }
          out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
          if ($id && (it2.opts.sourceCode || it2.opts.processCode)) {
            out += " " + ("/*# sourceURL=" + $id + " */") + " ";
          }
        }
        if (typeof it2.schema == "boolean" || !($refKeywords || it2.schema.$ref)) {
          var $keyword = "false schema";
          var $lvl = it2.level;
          var $dataLvl = it2.dataLevel;
          var $schema = it2.schema[$keyword];
          var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
          var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
          var $breakOnError = !it2.opts.allErrors;
          var $errorKeyword;
          var $data = "data" + ($dataLvl || "");
          var $valid = "valid" + $lvl;
          if (it2.schema === false) {
            if (it2.isTop) {
              $breakOnError = true;
            } else {
              out += " var " + $valid + " = false; ";
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
              if (it2.opts.messages !== false) {
                out += " , message: 'boolean schema is false' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            if (it2.isTop) {
              if ($async) {
                out += " return data; ";
              } else {
                out += " validate.errors = null; return true; ";
              }
            } else {
              out += " var " + $valid + " = true; ";
            }
          }
          if (it2.isTop) {
            out += " }; return validate; ";
          }
          return out;
        }
        if (it2.isTop) {
          var $top = it2.isTop, $lvl = it2.level = 0, $dataLvl = it2.dataLevel = 0, $data = "data";
          it2.rootId = it2.resolve.fullPath(it2.self._getId(it2.root.schema));
          it2.baseId = it2.baseId || it2.rootId;
          delete it2.isTop;
          it2.dataPathArr = [""];
          if (it2.schema.default !== void 0 && it2.opts.useDefaults && it2.opts.strictDefaults) {
            var $defaultMsg = "default is ignored in the schema root";
            if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
            else throw new Error($defaultMsg);
          }
          out += " var vErrors = null; ";
          out += " var errors = 0;     ";
          out += " if (rootData === undefined) rootData = data; ";
        } else {
          var $lvl = it2.level, $dataLvl = it2.dataLevel, $data = "data" + ($dataLvl || "");
          if ($id) it2.baseId = it2.resolve.url(it2.baseId, $id);
          if ($async && !it2.async) throw new Error("async schema in sync schema");
          out += " var errs_" + $lvl + " = errors;";
        }
        var $valid = "valid" + $lvl, $breakOnError = !it2.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
        var $errorKeyword;
        var $typeSchema = it2.schema.type, $typeIsArray = Array.isArray($typeSchema);
        if ($typeSchema && it2.opts.nullable && it2.schema.nullable === true) {
          if ($typeIsArray) {
            if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
          } else if ($typeSchema != "null") {
            $typeSchema = [$typeSchema, "null"];
            $typeIsArray = true;
          }
        }
        if ($typeIsArray && $typeSchema.length == 1) {
          $typeSchema = $typeSchema[0];
          $typeIsArray = false;
        }
        if (it2.schema.$ref && $refKeywords) {
          if (it2.opts.extendRefs == "fail") {
            throw new Error('$ref: validation keywords used in schema at path "' + it2.errSchemaPath + '" (see option extendRefs)');
          } else if (it2.opts.extendRefs !== true) {
            $refKeywords = false;
            it2.logger.warn('$ref: keywords ignored in schema at path "' + it2.errSchemaPath + '"');
          }
        }
        if (it2.schema.$comment && it2.opts.$comment) {
          out += " " + it2.RULES.all.$comment.code(it2, "$comment");
        }
        if ($typeSchema) {
          if (it2.opts.coerceTypes) {
            var $coerceToTypes = it2.util.coerceToTypes(it2.opts.coerceTypes, $typeSchema);
          }
          var $rulesGroup = it2.RULES.types[$typeSchema];
          if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
            var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
            var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
            out += " if (" + it2.util[$method]($typeSchema, $data, it2.opts.strictNumbers, true) + ") { ";
            if ($coerceToTypes) {
              var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
              out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
              if (it2.opts.coerceTypes == "array") {
                out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it2.util.checkDataType(it2.schema.type, $data, it2.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
              }
              out += " if (" + $coerced + " !== undefined) ; ";
              var arr1 = $coerceToTypes;
              if (arr1) {
                var $type, $i = -1, l1 = arr1.length - 1;
                while ($i < l1) {
                  $type = arr1[$i += 1];
                  if ($type == "string") {
                    out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                  } else if ($type == "number" || $type == "integer") {
                    out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                    if ($type == "integer") {
                      out += " && !(" + $data + " % 1)";
                    }
                    out += ")) " + $coerced + " = +" + $data + "; ";
                  } else if ($type == "boolean") {
                    out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                  } else if ($type == "null") {
                    out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                  } else if (it2.opts.coerceTypes == "array" && $type == "array") {
                    out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                  }
                }
              }
              out += " else {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it2.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it2.compositeRule && $breakOnError) {
                if (it2.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } if (" + $coerced + " !== undefined) {  ";
              var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
              out += " " + $data + " = " + $coerced + "; ";
              if (!$dataLvl) {
                out += "if (" + $parentData + " !== undefined)";
              }
              out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
            } else {
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it2.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it2.compositeRule && $breakOnError) {
                if (it2.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
            }
            out += " } ";
          }
        }
        if (it2.schema.$ref && !$refKeywords) {
          out += " " + it2.RULES.all.$ref.code(it2, "$ref") + " ";
          if ($breakOnError) {
            out += " } if (errors === ";
            if ($top) {
              out += "0";
            } else {
              out += "errs_" + $lvl;
            }
            out += ") { ";
            $closingBraces2 += "}";
          }
        } else {
          var arr2 = it2.RULES;
          if (arr2) {
            var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $rulesGroup = arr2[i2 += 1];
              if ($shouldUseGroup($rulesGroup)) {
                if ($rulesGroup.type) {
                  out += " if (" + it2.util.checkDataType($rulesGroup.type, $data, it2.opts.strictNumbers) + ") { ";
                }
                if (it2.opts.useDefaults) {
                  if ($rulesGroup.type == "object" && it2.schema.properties) {
                    var $schema = it2.schema.properties, $schemaKeys = Object.keys($schema);
                    var arr3 = $schemaKeys;
                    if (arr3) {
                      var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                      while (i3 < l3) {
                        $propertyKey = arr3[i3 += 1];
                        var $sch = $schema[$propertyKey];
                        if ($sch.default !== void 0) {
                          var $passData = $data + it2.util.getProperty($propertyKey);
                          if (it2.compositeRule) {
                            if (it2.opts.strictDefaults) {
                              var $defaultMsg = "default is ignored for: " + $passData;
                              if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
                              else throw new Error($defaultMsg);
                            }
                          } else {
                            out += " if (" + $passData + " === undefined ";
                            if (it2.opts.useDefaults == "empty") {
                              out += " || " + $passData + " === null || " + $passData + " === '' ";
                            }
                            out += " ) " + $passData + " = ";
                            if (it2.opts.useDefaults == "shared") {
                              out += " " + it2.useDefault($sch.default) + " ";
                            } else {
                              out += " " + JSON.stringify($sch.default) + " ";
                            }
                            out += "; ";
                          }
                        }
                      }
                    }
                  } else if ($rulesGroup.type == "array" && Array.isArray(it2.schema.items)) {
                    var arr4 = it2.schema.items;
                    if (arr4) {
                      var $sch, $i = -1, l4 = arr4.length - 1;
                      while ($i < l4) {
                        $sch = arr4[$i += 1];
                        if ($sch.default !== void 0) {
                          var $passData = $data + "[" + $i + "]";
                          if (it2.compositeRule) {
                            if (it2.opts.strictDefaults) {
                              var $defaultMsg = "default is ignored for: " + $passData;
                              if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
                              else throw new Error($defaultMsg);
                            }
                          } else {
                            out += " if (" + $passData + " === undefined ";
                            if (it2.opts.useDefaults == "empty") {
                              out += " || " + $passData + " === null || " + $passData + " === '' ";
                            }
                            out += " ) " + $passData + " = ";
                            if (it2.opts.useDefaults == "shared") {
                              out += " " + it2.useDefault($sch.default) + " ";
                            } else {
                              out += " " + JSON.stringify($sch.default) + " ";
                            }
                            out += "; ";
                          }
                        }
                      }
                    }
                  }
                }
                var arr5 = $rulesGroup.rules;
                if (arr5) {
                  var $rule, i5 = -1, l5 = arr5.length - 1;
                  while (i5 < l5) {
                    $rule = arr5[i5 += 1];
                    if ($shouldUseRule($rule)) {
                      var $code = $rule.code(it2, $rule.keyword, $rulesGroup.type);
                      if ($code) {
                        out += " " + $code + " ";
                        if ($breakOnError) {
                          $closingBraces1 += "}";
                        }
                      }
                    }
                  }
                }
                if ($breakOnError) {
                  out += " " + $closingBraces1 + " ";
                  $closingBraces1 = "";
                }
                if ($rulesGroup.type) {
                  out += " } ";
                  if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                    out += " else { ";
                    var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = "";
                    if (it2.createErrors !== false) {
                      out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' } ";
                      if (it2.opts.messages !== false) {
                        out += " , message: 'should be ";
                        if ($typeIsArray) {
                          out += "" + $typeSchema.join(",");
                        } else {
                          out += "" + $typeSchema;
                        }
                        out += "' ";
                      }
                      if (it2.opts.verbose) {
                        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it2.compositeRule && $breakOnError) {
                      if (it2.async) {
                        out += " throw new ValidationError([" + __err + "]); ";
                      } else {
                        out += " validate.errors = [" + __err + "]; return false; ";
                      }
                    } else {
                      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    }
                    out += " } ";
                  }
                }
                if ($breakOnError) {
                  out += " if (errors === ";
                  if ($top) {
                    out += "0";
                  } else {
                    out += "errs_" + $lvl;
                  }
                  out += ") { ";
                  $closingBraces2 += "}";
                }
              }
            }
          }
        }
        if ($breakOnError) {
          out += " " + $closingBraces2 + " ";
        }
        if ($top) {
          if ($async) {
            out += " if (errors === 0) return data;           ";
            out += " else throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; ";
            out += " return errors === 0;       ";
          }
          out += " }; return validate;";
        } else {
          out += " var " + $valid + " = errors === errs_" + $lvl + ";";
        }
        function $shouldUseGroup($rulesGroup2) {
          var rules = $rulesGroup2.rules;
          for (var i4 = 0; i4 < rules.length; i4++)
            if ($shouldUseRule(rules[i4])) return true;
        }
        function $shouldUseRule($rule2) {
          return it2.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
        }
        function $ruleImplementsSomeKeyword($rule2) {
          var impl = $rule2.implements;
          for (var i4 = 0; i4 < impl.length; i4++)
            if (it2.schema[impl[i4]] !== void 0) return true;
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/compile/index.js
  var require_compile = __commonJS({
    "node_modules/ajv/lib/compile/index.js"(exports, module) {
      "use strict";
      var resolve = require_resolve();
      var util2 = require_util();
      var errorClasses = require_error_classes();
      var stableStringify = require_fast_json_stable_stringify();
      var validateGenerator = require_validate();
      var ucs2length = util2.ucs2length;
      var equal = require_fast_deep_equal();
      var ValidationError = errorClasses.Validation;
      module.exports = compile;
      function compile(schema, root, localRefs, baseId) {
        var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
        root = root || { schema, refVal, refs };
        var c2 = checkCompiling.call(this, schema, root, baseId);
        var compilation = this._compilations[c2.index];
        if (c2.compiling) return compilation.callValidate = callValidate;
        var formats = this._formats;
        var RULES = this.RULES;
        try {
          var v2 = localCompile(schema, root, localRefs, baseId);
          compilation.validate = v2;
          var cv = compilation.callValidate;
          if (cv) {
            cv.schema = v2.schema;
            cv.errors = null;
            cv.refs = v2.refs;
            cv.refVal = v2.refVal;
            cv.root = v2.root;
            cv.$async = v2.$async;
            if (opts.sourceCode) cv.source = v2.source;
          }
          return v2;
        } finally {
          endCompiling.call(this, schema, root, baseId);
        }
        function callValidate() {
          var validate = compilation.validate;
          var result = validate.apply(this, arguments);
          callValidate.errors = validate.errors;
          return result;
        }
        function localCompile(_schema, _root, localRefs2, baseId2) {
          var isRoot = !_root || _root && _root.schema == _schema;
          if (_root.schema != root.schema)
            return compile.call(self2, _schema, _root, localRefs2, baseId2);
          var $async = _schema.$async === true;
          var sourceCode = validateGenerator({
            isTop: true,
            schema: _schema,
            isRoot,
            baseId: baseId2,
            root: _root,
            schemaPath: "",
            errSchemaPath: "#",
            errorPath: '""',
            MissingRefError: errorClasses.MissingRef,
            RULES,
            validate: validateGenerator,
            util: util2,
            resolve,
            resolveRef,
            usePattern,
            useDefault,
            useCustomRule,
            opts,
            formats,
            logger: self2.logger,
            self: self2
          });
          sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
          if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
          var validate;
          try {
            var makeValidate = new Function(
              "self",
              "RULES",
              "formats",
              "root",
              "refVal",
              "defaults",
              "customRules",
              "equal",
              "ucs2length",
              "ValidationError",
              sourceCode
            );
            validate = makeValidate(
              self2,
              RULES,
              formats,
              root,
              refVal,
              defaults,
              customRules,
              equal,
              ucs2length,
              ValidationError
            );
            refVal[0] = validate;
          } catch (e2) {
            self2.logger.error("Error compiling schema, function code:", sourceCode);
            throw e2;
          }
          validate.schema = _schema;
          validate.errors = null;
          validate.refs = refs;
          validate.refVal = refVal;
          validate.root = isRoot ? validate : _root;
          if ($async) validate.$async = true;
          if (opts.sourceCode === true) {
            validate.source = {
              code: sourceCode,
              patterns,
              defaults
            };
          }
          return validate;
        }
        function resolveRef(baseId2, ref, isRoot) {
          ref = resolve.url(baseId2, ref);
          var refIndex = refs[ref];
          var _refVal, refCode;
          if (refIndex !== void 0) {
            _refVal = refVal[refIndex];
            refCode = "refVal[" + refIndex + "]";
            return resolvedRef(_refVal, refCode);
          }
          if (!isRoot && root.refs) {
            var rootRefId = root.refs[ref];
            if (rootRefId !== void 0) {
              _refVal = root.refVal[rootRefId];
              refCode = addLocalRef(ref, _refVal);
              return resolvedRef(_refVal, refCode);
            }
          }
          refCode = addLocalRef(ref);
          var v3 = resolve.call(self2, localCompile, root, ref);
          if (v3 === void 0) {
            var localSchema = localRefs && localRefs[ref];
            if (localSchema) {
              v3 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
            }
          }
          if (v3 === void 0) {
            removeLocalRef(ref);
          } else {
            replaceLocalRef(ref, v3);
            return resolvedRef(v3, refCode);
          }
        }
        function addLocalRef(ref, v3) {
          var refId = refVal.length;
          refVal[refId] = v3;
          refs[ref] = refId;
          return "refVal" + refId;
        }
        function removeLocalRef(ref) {
          delete refs[ref];
        }
        function replaceLocalRef(ref, v3) {
          var refId = refs[ref];
          refVal[refId] = v3;
        }
        function resolvedRef(refVal2, code) {
          return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
        }
        function usePattern(regexStr) {
          var index = patternsHash[regexStr];
          if (index === void 0) {
            index = patternsHash[regexStr] = patterns.length;
            patterns[index] = regexStr;
          }
          return "pattern" + index;
        }
        function useDefault(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
              return "" + value;
            case "string":
              return util2.toQuotedString(value);
            case "object":
              if (value === null) return "null";
              var valueStr = stableStringify(value);
              var index = defaultsHash[valueStr];
              if (index === void 0) {
                index = defaultsHash[valueStr] = defaults.length;
                defaults[index] = value;
              }
              return "default" + index;
          }
        }
        function useCustomRule(rule, schema2, parentSchema, it2) {
          if (self2._opts.validateSchema !== false) {
            var deps = rule.definition.dependencies;
            if (deps && !deps.every(function(keyword) {
              return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
            }))
              throw new Error("parent schema must have all required keywords: " + deps.join(","));
            var validateSchema = rule.definition.validateSchema;
            if (validateSchema) {
              var valid = validateSchema(schema2);
              if (!valid) {
                var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
                if (self2._opts.validateSchema == "log") self2.logger.error(message);
                else throw new Error(message);
              }
            }
          }
          var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
          var validate;
          if (compile2) {
            validate = compile2.call(self2, schema2, parentSchema, it2);
          } else if (macro) {
            validate = macro.call(self2, schema2, parentSchema, it2);
            if (opts.validateSchema !== false) self2.validateSchema(validate, true);
          } else if (inline) {
            validate = inline.call(self2, it2, rule.keyword, schema2, parentSchema);
          } else {
            validate = rule.definition.validate;
            if (!validate) return;
          }
          if (validate === void 0)
            throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
          var index = customRules.length;
          customRules[index] = validate;
          return {
            code: "customRule" + index,
            validate
          };
        }
      }
      function checkCompiling(schema, root, baseId) {
        var index = compIndex.call(this, schema, root, baseId);
        if (index >= 0) return { index, compiling: true };
        index = this._compilations.length;
        this._compilations[index] = {
          schema,
          root,
          baseId
        };
        return { index, compiling: false };
      }
      function endCompiling(schema, root, baseId) {
        var i2 = compIndex.call(this, schema, root, baseId);
        if (i2 >= 0) this._compilations.splice(i2, 1);
      }
      function compIndex(schema, root, baseId) {
        for (var i2 = 0; i2 < this._compilations.length; i2++) {
          var c2 = this._compilations[i2];
          if (c2.schema == schema && c2.root == root && c2.baseId == baseId) return i2;
        }
        return -1;
      }
      function patternCode(i2, patterns) {
        return "var pattern" + i2 + " = new RegExp(" + util2.toQuotedString(patterns[i2]) + ");";
      }
      function defaultCode(i2) {
        return "var default" + i2 + " = defaults[" + i2 + "];";
      }
      function refValCode(i2, refVal) {
        return refVal[i2] === void 0 ? "" : "var refVal" + i2 + " = refVal[" + i2 + "];";
      }
      function customRuleCode(i2) {
        return "var customRule" + i2 + " = customRules[" + i2 + "];";
      }
      function vars(arr, statement) {
        if (!arr.length) return "";
        var code = "";
        for (var i2 = 0; i2 < arr.length; i2++)
          code += statement(i2, arr);
        return code;
      }
    }
  });

  // node_modules/ajv/lib/cache.js
  var require_cache = __commonJS({
    "node_modules/ajv/lib/cache.js"(exports, module) {
      "use strict";
      var Cache = module.exports = function Cache2() {
        this._cache = {};
      };
      Cache.prototype.put = function Cache_put(key, value) {
        this._cache[key] = value;
      };
      Cache.prototype.get = function Cache_get(key) {
        return this._cache[key];
      };
      Cache.prototype.del = function Cache_del(key) {
        delete this._cache[key];
      };
      Cache.prototype.clear = function Cache_clear() {
        this._cache = {};
      };
    }
  });

  // node_modules/ajv/lib/compile/formats.js
  var require_formats = __commonJS({
    "node_modules/ajv/lib/compile/formats.js"(exports, module) {
      "use strict";
      var util2 = require_util();
      var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
      var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
      var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
      var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
      var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
      var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
      var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
      module.exports = formats;
      function formats(mode) {
        mode = mode == "full" ? "full" : "fast";
        return util2.copy(formats[mode]);
      }
      formats.fast = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        "uri-template": URITEMPLATE,
        url: URL2,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        hostname: HOSTNAME,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: UUID,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": RELATIVE_JSON_POINTER
      };
      formats.full = {
        date,
        time,
        "date-time": date_time,
        uri,
        "uri-reference": URIREF,
        "uri-template": URITEMPLATE,
        url: URL2,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: HOSTNAME,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex,
        uuid: UUID,
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        "relative-json-pointer": RELATIVE_JSON_POINTER
      };
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      function date(str) {
        var matches = str.match(DATE);
        if (!matches) return false;
        var year = +matches[1];
        var month = +matches[2];
        var day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function time(str, full) {
        var matches = str.match(TIME);
        if (!matches) return false;
        var hour = matches[1];
        var minute = matches[2];
        var second = matches[3];
        var timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
      }
      var DATE_TIME_SEPARATOR = /t|\s/i;
      function date_time(str) {
        var dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
      }
      var NOT_URI_FRAGMENT = /\/|:/;
      function uri(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      var Z_ANCHOR = /[^\\]\\Z/;
      function regex(str) {
        if (Z_ANCHOR.test(str)) return false;
        try {
          new RegExp(str);
          return true;
        } catch (e2) {
          return false;
        }
      }
    }
  });

  // node_modules/ajv/lib/dotjs/ref.js
  var require_ref = __commonJS({
    "node_modules/ajv/lib/dotjs/ref.js"(exports, module) {
      "use strict";
      module.exports = function generate_ref(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $async, $refCode;
        if ($schema == "#" || $schema == "#/") {
          if (it2.isRoot) {
            $async = it2.async;
            $refCode = "validate";
          } else {
            $async = it2.root.schema.$async === true;
            $refCode = "root.refVal[0]";
          }
        } else {
          var $refVal = it2.resolveRef(it2.baseId, $schema, it2.isRoot);
          if ($refVal === void 0) {
            var $message = it2.MissingRefError.message(it2.baseId, $schema);
            if (it2.opts.missingRefs == "fail") {
              it2.logger.error($message);
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it2.createErrors !== false) {
                out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it2.util.escapeQuotes($schema) + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: 'can\\'t resolve reference " + it2.util.escapeQuotes($schema) + "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: " + it2.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it2.compositeRule && $breakOnError) {
                if (it2.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              if ($breakOnError) {
                out += " if (false) { ";
              }
            } else if (it2.opts.missingRefs == "ignore") {
              it2.logger.warn($message);
              if ($breakOnError) {
                out += " if (true) { ";
              }
            } else {
              throw new it2.MissingRefError(it2.baseId, $schema, $message);
            }
          } else if ($refVal.inline) {
            var $it = it2.util.copy(it2);
            $it.level++;
            var $nextValid = "valid" + $it.level;
            $it.schema = $refVal.schema;
            $it.schemaPath = "";
            $it.errSchemaPath = $schema;
            var $code = it2.validate($it).replace(/validate\.schema/g, $refVal.code);
            out += " " + $code + " ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
            }
          } else {
            $async = $refVal.$async === true || it2.async && $refVal.$async !== false;
            $refCode = $refVal.code;
          }
        }
        if ($refCode) {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.opts.passContext) {
            out += " " + $refCode + ".call(this, ";
          } else {
            out += " " + $refCode + "( ";
          }
          out += " " + $data + ", (dataPath || '')";
          if (it2.errorPath != '""') {
            out += " + " + it2.errorPath;
          }
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
          var __callValidate = out;
          out = $$outStack.pop();
          if ($async) {
            if (!it2.async) throw new Error("async schema referenced by sync schema");
            if ($breakOnError) {
              out += " var " + $valid + "; ";
            }
            out += " try { await " + __callValidate + "; ";
            if ($breakOnError) {
              out += " " + $valid + " = true; ";
            }
            out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
            if ($breakOnError) {
              out += " " + $valid + " = false; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " if (" + $valid + ") { ";
            }
          } else {
            out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
            if ($breakOnError) {
              out += " else { ";
            }
          }
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/allOf.js
  var require_allOf = __commonJS({
    "node_modules/ajv/lib/dotjs/allOf.js"(exports, module) {
      "use strict";
      module.exports = function generate_allOf(it2, $keyword, $ruleType) {
        var out = " ";
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
              $allSchemasEmpty = false;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it2.validate($it) + " ";
              $it.baseId = $currentBaseId;
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if ($breakOnError) {
          if ($allSchemasEmpty) {
            out += " if (true) { ";
          } else {
            out += " " + $closingBraces.slice(0, -1) + " ";
          }
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/anyOf.js
  var require_anyOf = __commonJS({
    "node_modules/ajv/lib/dotjs/anyOf.js"(exports, module) {
      "use strict";
      module.exports = function generate_anyOf(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $noEmptySchema = $schema.every(function($sch2) {
          return it2.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it2.util.schemaHasRules($sch2, it2.RULES.all);
        });
        if ($noEmptySchema) {
          var $currentBaseId = $it.baseId;
          out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
          var $wasComposite = it2.compositeRule;
          it2.compositeRule = $it.compositeRule = true;
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it2.validate($it) + " ";
              $it.baseId = $currentBaseId;
              out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
              $closingBraces += "}";
            }
          }
          it2.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
          if (it2.createErrors !== false) {
            out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should match some schema in anyOf' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
          if (it2.opts.allErrors) {
            out += " } ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/comment.js
  var require_comment = __commonJS({
    "node_modules/ajv/lib/dotjs/comment.js"(exports, module) {
      "use strict";
      module.exports = function generate_comment(it2, $keyword, $ruleType) {
        var out = " ";
        var $schema = it2.schema[$keyword];
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $comment = it2.util.toQuotedString($schema);
        if (it2.opts.$comment === true) {
          out += " console.log(" + $comment + ");";
        } else if (typeof it2.opts.$comment == "function") {
          out += " self._opts.$comment(" + $comment + ", " + it2.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/const.js
  var require_const = __commonJS({
    "node_modules/ajv/lib/dotjs/const.js"(exports, module) {
      "use strict";
      module.exports = function generate_const(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!$isData) {
          out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
        }
        out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should be equal to constant' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " }";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/contains.js
  var require_contains = __commonJS({
    "node_modules/ajv/lib/dotjs/contains.js"(exports, module) {
      "use strict";
      module.exports = function generate_contains(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId, $nonEmptySchema = it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all);
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if ($nonEmptySchema) {
          var $wasComposite = it2.compositeRule;
          it2.compositeRule = $it.compositeRule = true;
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it2.validate($it);
          $it.baseId = $currentBaseId;
          if (it2.util.varOccurences($code, $nextData) < 2) {
            out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " if (" + $nextValid + ") break; }  ";
          it2.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $closingBraces + " if (!" + $nextValid + ") {";
        } else {
          out += " if (" + $data + ".length == 0) {";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should contain a valid item' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
        if ($nonEmptySchema) {
          out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        }
        if (it2.opts.allErrors) {
          out += " } ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/dependencies.js
  var require_dependencies = __commonJS({
    "node_modules/ajv/lib/dotjs/dependencies.js"(exports, module) {
      "use strict";
      module.exports = function generate_dependencies(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it2.opts.ownProperties;
        for ($property in $schema) {
          if ($property == "__proto__") continue;
          var $sch = $schema[$property];
          var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
          $deps[$property] = $sch;
        }
        out += "var " + $errs + " = errors;";
        var $currentErrorPath = it2.errorPath;
        out += "var missing" + $lvl + ";";
        for (var $property in $propertyDeps) {
          $deps = $propertyDeps[$property];
          if ($deps.length) {
            out += " if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) {
              out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
            }
            if ($breakOnError) {
              out += " && ( ";
              var arr1 = $deps;
              if (arr1) {
                var $propertyKey, $i = -1, l1 = arr1.length - 1;
                while ($i < l1) {
                  $propertyKey = arr1[$i += 1];
                  if ($i) {
                    out += " || ";
                  }
                  var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
                  out += " ( ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                }
              }
              out += ")) {  ";
              var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
              }
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it2.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it2.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it2.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it2.compositeRule && $breakOnError) {
                if (it2.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
            } else {
              out += " ) { ";
              var arr2 = $deps;
              if (arr2) {
                var $propertyKey, i2 = -1, l2 = arr2.length - 1;
                while (i2 < l2) {
                  $propertyKey = arr2[i2 += 1];
                  var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                  if (it2.opts._errorDataPathProperty) {
                    it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                  }
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") {  var err =   ";
                  if (it2.createErrors !== false) {
                    out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                    if (it2.opts.messages !== false) {
                      out += " , message: 'should have ";
                      if ($deps.length == 1) {
                        out += "property " + it2.util.escapeQuotes($deps[0]);
                      } else {
                        out += "properties " + it2.util.escapeQuotes($deps.join(", "));
                      }
                      out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
                    }
                    if (it2.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
              }
            }
            out += " }   ";
            if ($breakOnError) {
              $closingBraces += "}";
              out += " else { ";
            }
          }
        }
        it2.errorPath = $currentErrorPath;
        var $currentBaseId = $it.baseId;
        for (var $property in $schemaDeps) {
          var $sch = $schemaDeps[$property];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            out += " " + $nextValid + " = true; if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) {
              out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
            }
            out += ") { ";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + it2.util.getProperty($property);
            $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($property);
            out += "  " + it2.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
        if ($breakOnError) {
          out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/enum.js
  var require_enum = __commonJS({
    "node_modules/ajv/lib/dotjs/enum.js"(exports, module) {
      "use strict";
      module.exports = function generate_enum(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
        }
        out += "var " + $valid + ";";
        if ($isData) {
          out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
        }
        out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should be equal to one of the allowed values' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " }";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/format.js
  var require_format = __commonJS({
    "node_modules/ajv/lib/dotjs/format.js"(exports, module) {
      "use strict";
      module.exports = function generate_format(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        if (it2.opts.format === false) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $unknownFormats = it2.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
        if ($isData) {
          var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
          out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
          if (it2.async) {
            out += " var async" + $lvl + " = " + $format + ".async; ";
          }
          out += " " + $format + " = " + $format + ".validate; } if (  ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
          }
          out += " (";
          if ($unknownFormats != "ignore") {
            out += " (" + $schemaValue + " && !" + $format + " ";
            if ($allowUnknown) {
              out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
            }
            out += ") || ";
          }
          out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
          if (it2.async) {
            out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
          } else {
            out += " " + $format + "(" + $data + ") ";
          }
          out += " : " + $format + ".test(" + $data + "))))) {";
        } else {
          var $format = it2.formats[$schema];
          if (!$format) {
            if ($unknownFormats == "ignore") {
              it2.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it2.errSchemaPath + '"');
              if ($breakOnError) {
                out += " if (true) { ";
              }
              return out;
            } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
              if ($breakOnError) {
                out += " if (true) { ";
              }
              return out;
            } else {
              throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it2.errSchemaPath + '"');
            }
          }
          var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
          var $formatType = $isObject && $format.type || "string";
          if ($isObject) {
            var $async = $format.async === true;
            $format = $format.validate;
          }
          if ($formatType != $ruleType) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          }
          if ($async) {
            if (!it2.async) throw new Error("async format in sync schema");
            var $formatRef = "formats" + it2.util.getProperty($schema) + ".validate";
            out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
          } else {
            out += " if (! ";
            var $formatRef = "formats" + it2.util.getProperty($schema);
            if ($isObject) $formatRef += ".validate";
            if (typeof $format == "function") {
              out += " " + $formatRef + "(" + $data + ") ";
            } else {
              out += " " + $formatRef + ".test(" + $data + ") ";
            }
            out += ") { ";
          }
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
          if ($isData) {
            out += "" + $schemaValue;
          } else {
            out += "" + it2.util.toQuotedString($schema);
          }
          out += "  } ";
          if (it2.opts.messages !== false) {
            out += ` , message: 'should match format "`;
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + it2.util.escapeQuotes($schema);
            }
            out += `"' `;
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + it2.util.toQuotedString($schema);
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/if.js
  var require_if = __commonJS({
    "node_modules/ajv/lib/dotjs/if.js"(exports, module) {
      "use strict";
      module.exports = function generate_if(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $thenSch = it2.schema["then"], $elseSch = it2.schema["else"], $thenPresent = $thenSch !== void 0 && (it2.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it2.util.schemaHasRules($thenSch, it2.RULES.all)), $elsePresent = $elseSch !== void 0 && (it2.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it2.util.schemaHasRules($elseSch, it2.RULES.all)), $currentBaseId = $it.baseId;
        if ($thenPresent || $elsePresent) {
          var $ifClause;
          $it.createErrors = false;
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
          var $wasComposite = it2.compositeRule;
          it2.compositeRule = $it.compositeRule = true;
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          $it.createErrors = true;
          out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
          it2.compositeRule = $it.compositeRule = $wasComposite;
          if ($thenPresent) {
            out += " if (" + $nextValid + ") {  ";
            $it.schema = it2.schema["then"];
            $it.schemaPath = it2.schemaPath + ".then";
            $it.errSchemaPath = it2.errSchemaPath + "/then";
            out += "  " + it2.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
              $ifClause = "ifClause" + $lvl;
              out += " var " + $ifClause + " = 'then'; ";
            } else {
              $ifClause = "'then'";
            }
            out += " } ";
            if ($elsePresent) {
              out += " else { ";
            }
          } else {
            out += " if (!" + $nextValid + ") { ";
          }
          if ($elsePresent) {
            $it.schema = it2.schema["else"];
            $it.schemaPath = it2.schemaPath + ".else";
            $it.errSchemaPath = it2.errSchemaPath + "/else";
            out += "  " + it2.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
              $ifClause = "ifClause" + $lvl;
              out += " var " + $ifClause + " = 'else'; ";
            } else {
              $ifClause = "'else'";
            }
            out += " } ";
          }
          out += " if (!" + $valid + ") {   var err =   ";
          if (it2.createErrors !== false) {
            out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
            if (it2.opts.messages !== false) {
              out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          out += " }   ";
          if ($breakOnError) {
            out += " else { ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/items.js
  var require_items = __commonJS({
    "node_modules/ajv/lib/dotjs/items.js"(exports, module) {
      "use strict";
      module.exports = function generate_items(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId;
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if (Array.isArray($schema)) {
          var $additionalItems = it2.schema.additionalItems;
          if ($additionalItems === false) {
            out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it2.errSchemaPath + "/additionalItems";
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
              if (it2.opts.messages !== false) {
                out += " , message: 'should NOT have more than " + $schema.length + " items' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } ";
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              $closingBraces += "}";
              out += " else { ";
            }
          }
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
                out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
                var $passData = $data + "[" + $i + "]";
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                $it.errorPath = it2.util.getPathExpr(it2.errorPath, $i, it2.opts.jsonPointers, true);
                $it.dataPathArr[$dataNxt] = $i;
                var $code = it2.validate($it);
                $it.baseId = $currentBaseId;
                if (it2.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                out += " }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
          }
          if (typeof $additionalItems == "object" && (it2.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it2.util.schemaHasRules($additionalItems, it2.RULES.all))) {
            $it.schema = $additionalItems;
            $it.schemaPath = it2.schemaPath + ".additionalItems";
            $it.errSchemaPath = it2.errSchemaPath + "/additionalItems";
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
            $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
            var $passData = $data + "[" + $idx + "]";
            $it.dataPathArr[$dataNxt] = $idx;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        } else if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it2.validate($it);
          $it.baseId = $currentBaseId;
          if (it2.util.varOccurences($code, $nextData) < 2) {
            out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " }";
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/_limit.js
  var require_limit = __commonJS({
    "node_modules/ajv/lib/dotjs/_limit.js"(exports, module) {
      "use strict";
      module.exports = function generate__limit(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it2.schema[$exclusiveKeyword], $isDataExcl = it2.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
        if (!($isData || typeof $schema == "number" || $schema === void 0)) {
          throw new Error($keyword + " must be number");
        }
        if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
          throw new Error($exclusiveKeyword + " must be number or boolean");
        }
        if ($isDataExcl) {
          var $schemaValueExcl = it2.util.getData($schemaExcl.$data, $dataLvl, it2.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
          out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
          $schemaValueExcl = "schemaExcl" + $lvl;
          out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
          var $errorKeyword = $exclusiveKeyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it2.opts.messages !== false) {
              out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
          if ($schema === void 0) {
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaValueExcl;
            $isData = $isDataExcl;
          }
        } else {
          var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
          if ($exclIsNumber && $isData) {
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) {
              out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            }
            out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
          } else {
            if ($exclIsNumber && $schema === void 0) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
              $schemaValue = $schemaExcl;
              $notOp += "=";
            } else {
              if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
              if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
                $exclusive = true;
                $errorKeyword = $exclusiveKeyword;
                $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
                $notOp += "=";
              } else {
                $exclusive = false;
                $opStr += "=";
              }
            }
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) {
              out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            }
            out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
          }
        }
        $errorKeyword = $errorKeyword || $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should be " + $opStr + " ";
            if ($isData) {
              out += "' + " + $schemaValue;
            } else {
              out += "" + $schemaValue + "'";
            }
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/_limitItems.js
  var require_limitItems = __commonJS({
    "node_modules/ajv/lib/dotjs/_limitItems.js"(exports, module) {
      "use strict";
      module.exports = function generate__limitItems(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxItems" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxItems") {
              out += "more";
            } else {
              out += "fewer";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " items' ";
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/_limitLength.js
  var require_limitLength = __commonJS({
    "node_modules/ajv/lib/dotjs/_limitLength.js"(exports, module) {
      "use strict";
      module.exports = function generate__limitLength(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxLength" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        if (it2.opts.unicode === false) {
          out += " " + $data + ".length ";
        } else {
          out += " ucs2length(" + $data + ") ";
        }
        out += " " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT be ";
            if ($keyword == "maxLength") {
              out += "longer";
            } else {
              out += "shorter";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " characters' ";
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/_limitProperties.js
  var require_limitProperties = __commonJS({
    "node_modules/ajv/lib/dotjs/_limitProperties.js"(exports, module) {
      "use strict";
      module.exports = function generate__limitProperties(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxProperties" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxProperties") {
              out += "more";
            } else {
              out += "fewer";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " properties' ";
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/multipleOf.js
  var require_multipleOf = __commonJS({
    "node_modules/ajv/lib/dotjs/multipleOf.js"(exports, module) {
      "use strict";
      module.exports = function generate_multipleOf(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        out += "var division" + $lvl + ";if (";
        if ($isData) {
          out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
        }
        out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
        if (it2.opts.multipleOfPrecision) {
          out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it2.opts.multipleOfPrecision + " ";
        } else {
          out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
        }
        out += " ) ";
        if ($isData) {
          out += "  )  ";
        }
        out += " ) {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should be multiple of ";
            if ($isData) {
              out += "' + " + $schemaValue;
            } else {
              out += "" + $schemaValue + "'";
            }
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/not.js
  var require_not = __commonJS({
    "node_modules/ajv/lib/dotjs/not.js"(exports, module) {
      "use strict";
      module.exports = function generate_not(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $errs + " = errors;  ";
          var $wasComposite = it2.compositeRule;
          it2.compositeRule = $it.compositeRule = true;
          $it.createErrors = false;
          var $allErrorsOption;
          if ($it.opts.allErrors) {
            $allErrorsOption = $it.opts.allErrors;
            $it.opts.allErrors = false;
          }
          out += " " + it2.validate($it) + " ";
          $it.createErrors = true;
          if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
          it2.compositeRule = $it.compositeRule = $wasComposite;
          out += " if (" + $nextValid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should NOT be valid' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
          if (it2.opts.allErrors) {
            out += " } ";
          }
        } else {
          out += "  var err =   ";
          if (it2.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should NOT be valid' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if ($breakOnError) {
            out += " if (false) { ";
          }
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/oneOf.js
  var require_oneOf = __commonJS({
    "node_modules/ajv/lib/dotjs/oneOf.js"(exports, module) {
      "use strict";
      module.exports = function generate_oneOf(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
        out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
        var $wasComposite = it2.compositeRule;
        it2.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it2.validate($it) + " ";
              $it.baseId = $currentBaseId;
            } else {
              out += " var " + $nextValid + " = true; ";
            }
            if ($i) {
              out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
              $closingBraces += "}";
            }
            out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
          }
        }
        it2.compositeRule = $it.compositeRule = $wasComposite;
        out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
        if (it2.createErrors !== false) {
          out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should match exactly one schema in oneOf' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
        if (it2.opts.allErrors) {
          out += " } ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/pattern.js
  var require_pattern = __commonJS({
    "node_modules/ajv/lib/dotjs/pattern.js"(exports, module) {
      "use strict";
      module.exports = function generate_pattern(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it2.usePattern($schema);
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " !" + $regexp + ".test(" + $data + ") ) {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
          if ($isData) {
            out += "" + $schemaValue;
          } else {
            out += "" + it2.util.toQuotedString($schema);
          }
          out += "  } ";
          if (it2.opts.messages !== false) {
            out += ` , message: 'should match pattern "`;
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + it2.util.escapeQuotes($schema);
            }
            out += `"' `;
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + it2.util.toQuotedString($schema);
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/properties.js
  var require_properties = __commonJS({
    "node_modules/ajv/lib/dotjs/properties.js"(exports, module) {
      "use strict";
      module.exports = function generate_properties(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
        var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it2.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it2.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it2.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
        var $required = it2.schema.required;
        if ($required && !(it2.opts.$data && $required.$data) && $required.length < it2.opts.loopRequired) {
          var $requiredHash = it2.util.toHash($required);
        }
        function notProto(p2) {
          return p2 !== "__proto__";
        }
        out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined;";
        }
        if ($checkAdditional) {
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          if ($someProperties) {
            out += " var isAdditional" + $lvl + " = !(false ";
            if ($schemaKeys.length) {
              if ($schemaKeys.length > 8) {
                out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
              } else {
                var arr1 = $schemaKeys;
                if (arr1) {
                  var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                  while (i1 < l1) {
                    $propertyKey = arr1[i1 += 1];
                    out += " || " + $key + " == " + it2.util.toQuotedString($propertyKey) + " ";
                  }
                }
              }
            }
            if ($pPropertyKeys.length) {
              var arr2 = $pPropertyKeys;
              if (arr2) {
                var $pProperty, $i = -1, l2 = arr2.length - 1;
                while ($i < l2) {
                  $pProperty = arr2[$i += 1];
                  out += " || " + it2.usePattern($pProperty) + ".test(" + $key + ") ";
                }
              }
            }
            out += " ); if (isAdditional" + $lvl + ") { ";
          }
          if ($removeAdditional == "all") {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            var $currentErrorPath = it2.errorPath;
            var $additionalProperty = "' + " + $key + " + '";
            if (it2.opts._errorDataPathProperty) {
              it2.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
            }
            if ($noAdditional) {
              if ($removeAdditional) {
                out += " delete " + $data + "[" + $key + "]; ";
              } else {
                out += " " + $nextValid + " = false; ";
                var $currErrSchemaPath = $errSchemaPath;
                $errSchemaPath = it2.errSchemaPath + "/additionalProperties";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it2.createErrors !== false) {
                  out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: '";
                    if (it2.opts._errorDataPathProperty) {
                      out += "is an invalid additional property";
                    } else {
                      out += "should NOT have additional properties";
                    }
                    out += "' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it2.compositeRule && $breakOnError) {
                  if (it2.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                if ($breakOnError) {
                  out += " break; ";
                }
              }
            } else if ($additionalIsSchema) {
              if ($removeAdditional == "failing") {
                out += " var " + $errs + " = errors;  ";
                var $wasComposite = it2.compositeRule;
                it2.compositeRule = $it.compositeRule = true;
                $it.schema = $aProperties;
                $it.schemaPath = it2.schemaPath + ".additionalProperties";
                $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
                $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it2.validate($it);
                $it.baseId = $currentBaseId;
                if (it2.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
                it2.compositeRule = $it.compositeRule = $wasComposite;
              } else {
                $it.schema = $aProperties;
                $it.schemaPath = it2.schemaPath + ".additionalProperties";
                $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
                $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it2.validate($it);
                $it.baseId = $currentBaseId;
                if (it2.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                if ($breakOnError) {
                  out += " if (!" + $nextValid + ") break; ";
                }
              }
            }
            it2.errorPath = $currentErrorPath;
          }
          if ($someProperties) {
            out += " } ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
        var $useDefaults = it2.opts.useDefaults && !it2.compositeRule;
        if ($schemaKeys.length) {
          var arr3 = $schemaKeys;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $sch = $schema[$propertyKey];
              if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
                var $prop = it2.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + $prop;
                $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($propertyKey);
                $it.errorPath = it2.util.getPath(it2.errorPath, $propertyKey, it2.opts.jsonPointers);
                $it.dataPathArr[$dataNxt] = it2.util.toQuotedString($propertyKey);
                var $code = it2.validate($it);
                $it.baseId = $currentBaseId;
                if (it2.util.varOccurences($code, $nextData) < 2) {
                  $code = it2.util.varReplace($code, $nextData, $passData);
                  var $useData = $passData;
                } else {
                  var $useData = $nextData;
                  out += " var " + $nextData + " = " + $passData + "; ";
                }
                if ($hasDefault) {
                  out += " " + $code + " ";
                } else {
                  if ($requiredHash && $requiredHash[$propertyKey]) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = false; ";
                    var $currentErrorPath = it2.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it2.util.escapeQuotes($propertyKey);
                    if (it2.opts._errorDataPathProperty) {
                      it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                    }
                    $errSchemaPath = it2.errSchemaPath + "/required";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = "";
                    if (it2.createErrors !== false) {
                      out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                      if (it2.opts.messages !== false) {
                        out += " , message: '";
                        if (it2.opts._errorDataPathProperty) {
                          out += "is a required property";
                        } else {
                          out += "should have required property \\'" + $missingProperty + "\\'";
                        }
                        out += "' ";
                      }
                      if (it2.opts.verbose) {
                        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it2.compositeRule && $breakOnError) {
                      if (it2.async) {
                        out += " throw new ValidationError([" + __err + "]); ";
                      } else {
                        out += " validate.errors = [" + __err + "]; return false; ";
                      }
                    } else {
                      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    }
                    $errSchemaPath = $currErrSchemaPath;
                    it2.errorPath = $currentErrorPath;
                    out += " } else { ";
                  } else {
                    if ($breakOnError) {
                      out += " if ( " + $useData + " === undefined ";
                      if ($ownProperties) {
                        out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                      }
                      out += ") { " + $nextValid + " = true; } else { ";
                    } else {
                      out += " if (" + $useData + " !== undefined ";
                      if ($ownProperties) {
                        out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                      }
                      out += " ) { ";
                    }
                  }
                  out += " " + $code + " } ";
                }
              }
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr4 = $pPropertyKeys;
          if (arr4) {
            var $pProperty, i4 = -1, l4 = arr4.length - 1;
            while (i4 < l4) {
              $pProperty = arr4[i4 += 1];
              var $sch = $pProperties[$pProperty];
              if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = it2.schemaPath + ".patternProperties" + it2.util.getProperty($pProperty);
                $it.errSchemaPath = it2.errSchemaPath + "/patternProperties/" + it2.util.escapeFragment($pProperty);
                if ($ownProperties) {
                  out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
                } else {
                  out += " for (var " + $key + " in " + $data + ") { ";
                }
                out += " if (" + it2.usePattern($pProperty) + ".test(" + $key + ")) { ";
                $it.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it2.validate($it);
                $it.baseId = $currentBaseId;
                if (it2.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                if ($breakOnError) {
                  out += " if (!" + $nextValid + ") break; ";
                }
                out += " } ";
                if ($breakOnError) {
                  out += " else " + $nextValid + " = true; ";
                }
                out += " }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
          }
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/propertyNames.js
  var require_propertyNames = __commonJS({
    "node_modules/ajv/lib/dotjs/propertyNames.js"(exports, module) {
      "use strict";
      module.exports = function generate_propertyNames(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        out += "var " + $errs + " = errors;";
        if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
          if ($ownProperties) {
            out += " var " + $dataProperties + " = undefined; ";
          }
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          out += " var startErrs" + $lvl + " = errors; ";
          var $passData = $key;
          var $wasComposite = it2.compositeRule;
          it2.compositeRule = $it.compositeRule = true;
          var $code = it2.validate($it);
          $it.baseId = $currentBaseId;
          if (it2.util.varOccurences($code, $nextData) < 2) {
            out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          it2.compositeRule = $it.compositeRule = $wasComposite;
          out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
          if (it2.createErrors !== false) {
            out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          if ($breakOnError) {
            out += " break; ";
          }
          out += " } }";
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/required.js
  var require_required = __commonJS({
    "node_modules/ajv/lib/dotjs/required.js"(exports, module) {
      "use strict";
      module.exports = function generate_required(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $vSchema = "schema" + $lvl;
        if (!$isData) {
          if ($schema.length < it2.opts.loopRequired && it2.schema.properties && Object.keys(it2.schema.properties).length) {
            var $required = [];
            var arr1 = $schema;
            if (arr1) {
              var $property, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $property = arr1[i1 += 1];
                var $propertySch = it2.schema.properties[$property];
                if (!($propertySch && (it2.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it2.util.schemaHasRules($propertySch, it2.RULES.all)))) {
                  $required[$required.length] = $property;
                }
              }
            }
          } else {
            var $required = $schema;
          }
        }
        if ($isData || $required.length) {
          var $currentErrorPath = it2.errorPath, $loopRequired = $isData || $required.length >= it2.opts.loopRequired, $ownProperties = it2.opts.ownProperties;
          if ($breakOnError) {
            out += " var missing" + $lvl + "; ";
            if ($loopRequired) {
              if (!$isData) {
                out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
              }
              var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
              }
              out += " var " + $valid + " = true; ";
              if ($isData) {
                out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
              }
              out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
              if ($ownProperties) {
                out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
              }
              out += "; if (!" + $valid + ") break; } ";
              if ($isData) {
                out += "  }  ";
              }
              out += "  if (!" + $valid + ") {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it2.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: '";
                  if (it2.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it2.compositeRule && $breakOnError) {
                if (it2.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } else { ";
            } else {
              out += " if ( ";
              var arr2 = $required;
              if (arr2) {
                var $propertyKey, $i = -1, l2 = arr2.length - 1;
                while ($i < l2) {
                  $propertyKey = arr2[$i += 1];
                  if ($i) {
                    out += " || ";
                  }
                  var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
                  out += " ( ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                }
              }
              out += ") {  ";
              var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
              }
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it2.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: '";
                  if (it2.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it2.compositeRule && $breakOnError) {
                if (it2.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } else { ";
            }
          } else {
            if ($loopRequired) {
              if (!$isData) {
                out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
              }
              var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
              }
              if ($isData) {
                out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
                if (it2.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: '";
                    if (it2.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
              }
              out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
              }
              out += ") {  var err =   ";
              if (it2.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: '";
                  if (it2.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
              if ($isData) {
                out += "  }  ";
              }
            } else {
              var arr3 = $required;
              if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                  if (it2.opts._errorDataPathProperty) {
                    it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                  }
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") {  var err =   ";
                  if (it2.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it2.opts.messages !== false) {
                      out += " , message: '";
                      if (it2.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it2.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
              }
            }
          }
          it2.errorPath = $currentErrorPath;
        } else if ($breakOnError) {
          out += " if (true) {";
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/uniqueItems.js
  var require_uniqueItems = __commonJS({
    "node_modules/ajv/lib/dotjs/uniqueItems.js"(exports, module) {
      "use strict";
      module.exports = function generate_uniqueItems(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (($schema || $isData) && it2.opts.uniqueItems !== false) {
          if ($isData) {
            out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
          }
          out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
          var $itemType = it2.schema.items && it2.schema.items.type, $typeIsArray = Array.isArray($itemType);
          if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
            out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
          } else {
            out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
            var $method = "checkDataType" + ($typeIsArray ? "s" : "");
            out += " if (" + it2.util[$method]($itemType, "item", it2.opts.strictNumbers, true) + ") continue; ";
            if ($typeIsArray) {
              out += ` if (typeof item == 'string') item = '"' + item; `;
            }
            out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
          }
          out += " } ";
          if ($isData) {
            out += "  }  ";
          }
          out += " if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
            }
            if (it2.opts.verbose) {
              out += " , schema:  ";
              if ($isData) {
                out += "validate.schema" + $schemaPath;
              } else {
                out += "" + $schema;
              }
              out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " else { ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/dotjs/index.js
  var require_dotjs = __commonJS({
    "node_modules/ajv/lib/dotjs/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "$ref": require_ref(),
        allOf: require_allOf(),
        anyOf: require_anyOf(),
        "$comment": require_comment(),
        const: require_const(),
        contains: require_contains(),
        dependencies: require_dependencies(),
        "enum": require_enum(),
        format: require_format(),
        "if": require_if(),
        items: require_items(),
        maximum: require_limit(),
        minimum: require_limit(),
        maxItems: require_limitItems(),
        minItems: require_limitItems(),
        maxLength: require_limitLength(),
        minLength: require_limitLength(),
        maxProperties: require_limitProperties(),
        minProperties: require_limitProperties(),
        multipleOf: require_multipleOf(),
        not: require_not(),
        oneOf: require_oneOf(),
        pattern: require_pattern(),
        properties: require_properties(),
        propertyNames: require_propertyNames(),
        required: require_required(),
        uniqueItems: require_uniqueItems(),
        validate: require_validate()
      };
    }
  });

  // node_modules/ajv/lib/compile/rules.js
  var require_rules = __commonJS({
    "node_modules/ajv/lib/compile/rules.js"(exports, module) {
      "use strict";
      var ruleModules = require_dotjs();
      var toHash = require_util().toHash;
      module.exports = function rules() {
        var RULES = [
          {
            type: "number",
            rules: [
              { "maximum": ["exclusiveMaximum"] },
              { "minimum": ["exclusiveMinimum"] },
              "multipleOf",
              "format"
            ]
          },
          {
            type: "string",
            rules: ["maxLength", "minLength", "pattern", "format"]
          },
          {
            type: "array",
            rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
          },
          {
            type: "object",
            rules: [
              "maxProperties",
              "minProperties",
              "required",
              "dependencies",
              "propertyNames",
              { "properties": ["additionalProperties", "patternProperties"] }
            ]
          },
          { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
        ];
        var ALL = ["type", "$comment"];
        var KEYWORDS = [
          "$schema",
          "$id",
          "id",
          "$data",
          "$async",
          "title",
          "description",
          "default",
          "definitions",
          "examples",
          "readOnly",
          "writeOnly",
          "contentMediaType",
          "contentEncoding",
          "additionalItems",
          "then",
          "else"
        ];
        var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
        RULES.all = toHash(ALL);
        RULES.types = toHash(TYPES);
        RULES.forEach(function(group) {
          group.rules = group.rules.map(function(keyword) {
            var implKeywords;
            if (typeof keyword == "object") {
              var key = Object.keys(keyword)[0];
              implKeywords = keyword[key];
              keyword = key;
              implKeywords.forEach(function(k2) {
                ALL.push(k2);
                RULES.all[k2] = true;
              });
            }
            ALL.push(keyword);
            var rule = RULES.all[keyword] = {
              keyword,
              code: ruleModules[keyword],
              implements: implKeywords
            };
            return rule;
          });
          RULES.all.$comment = {
            keyword: "$comment",
            code: ruleModules.$comment
          };
          if (group.type) RULES.types[group.type] = group;
        });
        RULES.keywords = toHash(ALL.concat(KEYWORDS));
        RULES.custom = {};
        return RULES;
      };
    }
  });

  // node_modules/ajv/lib/data.js
  var require_data = __commonJS({
    "node_modules/ajv/lib/data.js"(exports, module) {
      "use strict";
      var KEYWORDS = [
        "multipleOf",
        "maximum",
        "exclusiveMaximum",
        "minimum",
        "exclusiveMinimum",
        "maxLength",
        "minLength",
        "pattern",
        "additionalItems",
        "maxItems",
        "minItems",
        "uniqueItems",
        "maxProperties",
        "minProperties",
        "required",
        "additionalProperties",
        "enum",
        "format",
        "const"
      ];
      module.exports = function(metaSchema, keywordsJsonPointers) {
        for (var i2 = 0; i2 < keywordsJsonPointers.length; i2++) {
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          var segments = keywordsJsonPointers[i2].split("/");
          var keywords = metaSchema;
          var j2;
          for (j2 = 1; j2 < segments.length; j2++)
            keywords = keywords[segments[j2]];
          for (j2 = 0; j2 < KEYWORDS.length; j2++) {
            var key = KEYWORDS[j2];
            var schema = keywords[key];
            if (schema) {
              keywords[key] = {
                anyOf: [
                  schema,
                  { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
                ]
              };
            }
          }
        }
        return metaSchema;
      };
    }
  });

  // node_modules/ajv/lib/compile/async.js
  var require_async = __commonJS({
    "node_modules/ajv/lib/compile/async.js"(exports, module) {
      "use strict";
      var MissingRefError = require_error_classes().MissingRef;
      module.exports = compileAsync;
      function compileAsync(schema, meta, callback) {
        var self2 = this;
        if (typeof this._opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        if (typeof meta == "function") {
          callback = meta;
          meta = void 0;
        }
        var p2 = loadMetaSchemaOf(schema).then(function() {
          var schemaObj = self2._addSchema(schema, void 0, meta);
          return schemaObj.validate || _compileAsync(schemaObj);
        });
        if (callback) {
          p2.then(
            function(v2) {
              callback(null, v2);
            },
            callback
          );
        }
        return p2;
        function loadMetaSchemaOf(sch) {
          var $schema = sch.$schema;
          return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
        }
        function _compileAsync(schemaObj) {
          try {
            return self2._compile(schemaObj);
          } catch (e2) {
            if (e2 instanceof MissingRefError) return loadMissingSchema(e2);
            throw e2;
          }
          function loadMissingSchema(e2) {
            var ref = e2.missingSchema;
            if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e2.missingRef + " cannot be resolved");
            var schemaPromise = self2._loadingSchemas[ref];
            if (!schemaPromise) {
              schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
              schemaPromise.then(removePromise, removePromise);
            }
            return schemaPromise.then(function(sch) {
              if (!added(ref)) {
                return loadMetaSchemaOf(sch).then(function() {
                  if (!added(ref)) self2.addSchema(sch, ref, void 0, meta);
                });
              }
            }).then(function() {
              return _compileAsync(schemaObj);
            });
            function removePromise() {
              delete self2._loadingSchemas[ref];
            }
            function added(ref2) {
              return self2._refs[ref2] || self2._schemas[ref2];
            }
          }
        }
      }
    }
  });

  // node_modules/ajv/lib/dotjs/custom.js
  var require_custom = __commonJS({
    "node_modules/ajv/lib/dotjs/custom.js"(exports, module) {
      "use strict";
      module.exports = function generate_custom(it2, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
        var $compile, $inline, $macro, $ruleValidate, $validateCode;
        if ($isData && $rDef.$data) {
          $validateCode = "keywordValidate" + $lvl;
          var $validateSchema = $rDef.validateSchema;
          out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
        } else {
          $ruleValidate = it2.useCustomRule($rule, $schema, it2.schema, it2);
          if (!$ruleValidate) return;
          $schemaValue = "validate.schema" + $schemaPath;
          $validateCode = $ruleValidate.code;
          $compile = $rDef.compile;
          $inline = $rDef.inline;
          $macro = $rDef.macro;
        }
        var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
        if ($asyncKeyword && !it2.async) throw new Error("async keyword in sync schema");
        if (!($inline || $macro)) {
          out += "" + $ruleErrs + " = null;";
        }
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if ($isData && $rDef.$data) {
          $closingBraces += "}";
          out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
          if ($validateSchema) {
            $closingBraces += "}";
            out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
          }
        }
        if ($inline) {
          if ($rDef.statements) {
            out += " " + $ruleValidate.validate + " ";
          } else {
            out += " " + $valid + " = " + $ruleValidate.validate + "; ";
          }
        } else if ($macro) {
          var $it = it2.util.copy(it2);
          var $closingBraces = "";
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $ruleValidate.validate;
          $it.schemaPath = "";
          var $wasComposite = it2.compositeRule;
          it2.compositeRule = $it.compositeRule = true;
          var $code = it2.validate($it).replace(/validate\.schema/g, $validateCode);
          it2.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $code;
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          out += "  " + $validateCode + ".call( ";
          if (it2.opts.passContext) {
            out += "this";
          } else {
            out += "self";
          }
          if ($compile || $rDef.schema === false) {
            out += " , " + $data + " ";
          } else {
            out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it2.schemaPath + " ";
          }
          out += " , (dataPath || '')";
          if (it2.errorPath != '""') {
            out += " + " + it2.errorPath;
          }
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
          var def_callRuleValidate = out;
          out = $$outStack.pop();
          if ($rDef.errors === false) {
            out += " " + $valid + " = ";
            if ($asyncKeyword) {
              out += "await ";
            }
            out += "" + def_callRuleValidate + "; ";
          } else {
            if ($asyncKeyword) {
              $ruleErrs = "customErrors" + $lvl;
              out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
            } else {
              out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
            }
          }
        }
        if ($rDef.modifying) {
          out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
        }
        out += "" + $closingBraces;
        if ($rDef.valid) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          out += " if ( ";
          if ($rDef.valid === void 0) {
            out += " !";
            if ($macro) {
              out += "" + $nextValid;
            } else {
              out += "" + $valid;
            }
          } else {
            out += " " + !$rDef.valid + " ";
          }
          out += ") { ";
          $errorKeyword = $rule.keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it2.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          var def_customError = out;
          out = $$outStack.pop();
          if ($inline) {
            if ($rDef.errors) {
              if ($rDef.errors != "full") {
                out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it2.opts.verbose) {
                  out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                }
                out += " } ";
              }
            } else {
              if ($rDef.errors === false) {
                out += " " + def_customError + " ";
              } else {
                out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it2.opts.verbose) {
                  out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                }
                out += " } } ";
              }
            }
          } else if ($macro) {
            out += "   var err =   ";
            if (it2.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
              if (it2.opts.messages !== false) {
                out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError(vErrors); ";
              } else {
                out += " validate.errors = vErrors; return false; ";
              }
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
              if (it2.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } else { " + def_customError + " } ";
            }
          }
          out += " } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
        return out;
      };
    }
  });

  // node_modules/ajv/lib/refs/json-schema-draft-07.json
  var require_json_schema_draft_07 = __commonJS({
    "node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
          schemaArray: {
            type: "array",
            minItems: 1,
            items: { $ref: "#" }
          },
          nonNegativeInteger: {
            type: "integer",
            minimum: 0
          },
          nonNegativeIntegerDefault0: {
            allOf: [
              { $ref: "#/definitions/nonNegativeInteger" },
              { default: 0 }
            ]
          },
          simpleTypes: {
            enum: [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ]
          },
          stringArray: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true,
            default: []
          }
        },
        type: ["object", "boolean"],
        properties: {
          $id: {
            type: "string",
            format: "uri-reference"
          },
          $schema: {
            type: "string",
            format: "uri"
          },
          $ref: {
            type: "string",
            format: "uri-reference"
          },
          $comment: {
            type: "string"
          },
          title: {
            type: "string"
          },
          description: {
            type: "string"
          },
          default: true,
          readOnly: {
            type: "boolean",
            default: false
          },
          examples: {
            type: "array",
            items: true
          },
          multipleOf: {
            type: "number",
            exclusiveMinimum: 0
          },
          maximum: {
            type: "number"
          },
          exclusiveMaximum: {
            type: "number"
          },
          minimum: {
            type: "number"
          },
          exclusiveMinimum: {
            type: "number"
          },
          maxLength: { $ref: "#/definitions/nonNegativeInteger" },
          minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          pattern: {
            type: "string",
            format: "regex"
          },
          additionalItems: { $ref: "#" },
          items: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/schemaArray" }
            ],
            default: true
          },
          maxItems: { $ref: "#/definitions/nonNegativeInteger" },
          minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          uniqueItems: {
            type: "boolean",
            default: false
          },
          contains: { $ref: "#" },
          maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
          minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          required: { $ref: "#/definitions/stringArray" },
          additionalProperties: { $ref: "#" },
          definitions: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          properties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          patternProperties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            propertyNames: { format: "regex" },
            default: {}
          },
          dependencies: {
            type: "object",
            additionalProperties: {
              anyOf: [
                { $ref: "#" },
                { $ref: "#/definitions/stringArray" }
              ]
            }
          },
          propertyNames: { $ref: "#" },
          const: true,
          enum: {
            type: "array",
            items: true,
            minItems: 1,
            uniqueItems: true
          },
          type: {
            anyOf: [
              { $ref: "#/definitions/simpleTypes" },
              {
                type: "array",
                items: { $ref: "#/definitions/simpleTypes" },
                minItems: 1,
                uniqueItems: true
              }
            ]
          },
          format: { type: "string" },
          contentMediaType: { type: "string" },
          contentEncoding: { type: "string" },
          if: { $ref: "#" },
          then: { $ref: "#" },
          else: { $ref: "#" },
          allOf: { $ref: "#/definitions/schemaArray" },
          anyOf: { $ref: "#/definitions/schemaArray" },
          oneOf: { $ref: "#/definitions/schemaArray" },
          not: { $ref: "#" }
        },
        default: true
      };
    }
  });

  // node_modules/ajv/lib/definition_schema.js
  var require_definition_schema = __commonJS({
    "node_modules/ajv/lib/definition_schema.js"(exports, module) {
      "use strict";
      var metaSchema = require_json_schema_draft_07();
      module.exports = {
        $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
        definitions: {
          simpleTypes: metaSchema.definitions.simpleTypes
        },
        type: "object",
        dependencies: {
          schema: ["validate"],
          $data: ["validate"],
          statements: ["inline"],
          valid: { not: { required: ["macro"] } }
        },
        properties: {
          type: metaSchema.properties.type,
          schema: { type: "boolean" },
          statements: { type: "boolean" },
          dependencies: {
            type: "array",
            items: { type: "string" }
          },
          metaSchema: { type: "object" },
          modifying: { type: "boolean" },
          valid: { type: "boolean" },
          $data: { type: "boolean" },
          async: { type: "boolean" },
          errors: {
            anyOf: [
              { type: "boolean" },
              { const: "full" }
            ]
          }
        }
      };
    }
  });

  // node_modules/ajv/lib/keyword.js
  var require_keyword = __commonJS({
    "node_modules/ajv/lib/keyword.js"(exports, module) {
      "use strict";
      var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
      var customRuleCode = require_custom();
      var definitionSchema = require_definition_schema();
      module.exports = {
        add: addKeyword,
        get: getKeyword,
        remove: removeKeyword,
        validate: validateKeyword
      };
      function addKeyword(keyword, definition) {
        var RULES = this.RULES;
        if (RULES.keywords[keyword])
          throw new Error("Keyword " + keyword + " is already defined");
        if (!IDENTIFIER.test(keyword))
          throw new Error("Keyword " + keyword + " is not a valid identifier");
        if (definition) {
          this.validateKeyword(definition, true);
          var dataType = definition.type;
          if (Array.isArray(dataType)) {
            for (var i2 = 0; i2 < dataType.length; i2++)
              _addRule(keyword, dataType[i2], definition);
          } else {
            _addRule(keyword, dataType, definition);
          }
          var metaSchema = definition.metaSchema;
          if (metaSchema) {
            if (definition.$data && this._opts.$data) {
              metaSchema = {
                anyOf: [
                  metaSchema,
                  { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
                ]
              };
            }
            definition.validateSchema = this.compile(metaSchema, true);
          }
        }
        RULES.keywords[keyword] = RULES.all[keyword] = true;
        function _addRule(keyword2, dataType2, definition2) {
          var ruleGroup;
          for (var i3 = 0; i3 < RULES.length; i3++) {
            var rg = RULES[i3];
            if (rg.type == dataType2) {
              ruleGroup = rg;
              break;
            }
          }
          if (!ruleGroup) {
            ruleGroup = { type: dataType2, rules: [] };
            RULES.push(ruleGroup);
          }
          var rule = {
            keyword: keyword2,
            definition: definition2,
            custom: true,
            code: customRuleCode,
            implements: definition2.implements
          };
          ruleGroup.rules.push(rule);
          RULES.custom[keyword2] = rule;
        }
        return this;
      }
      function getKeyword(keyword) {
        var rule = this.RULES.custom[keyword];
        return rule ? rule.definition : this.RULES.keywords[keyword] || false;
      }
      function removeKeyword(keyword) {
        var RULES = this.RULES;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        delete RULES.custom[keyword];
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rules = RULES[i2].rules;
          for (var j2 = 0; j2 < rules.length; j2++) {
            if (rules[j2].keyword == keyword) {
              rules.splice(j2, 1);
              break;
            }
          }
        }
        return this;
      }
      function validateKeyword(definition, throwError) {
        validateKeyword.errors = null;
        var v2 = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
        if (v2(definition)) return true;
        validateKeyword.errors = v2.errors;
        if (throwError)
          throw new Error("custom keyword definition is invalid: " + this.errorsText(v2.errors));
        else
          return false;
      }
    }
  });

  // node_modules/ajv/lib/refs/data.json
  var require_data2 = __commonJS({
    "node_modules/ajv/lib/refs/data.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        description: "Meta-schema for $data reference (JSON Schema extension proposal)",
        type: "object",
        required: ["$data"],
        properties: {
          $data: {
            type: "string",
            anyOf: [
              { format: "relative-json-pointer" },
              { format: "json-pointer" }
            ]
          }
        },
        additionalProperties: false
      };
    }
  });

  // node_modules/ajv/lib/ajv.js
  var require_ajv = __commonJS({
    "node_modules/ajv/lib/ajv.js"(exports, module) {
      "use strict";
      var compileSchema = require_compile();
      var resolve = require_resolve();
      var Cache = require_cache();
      var SchemaObject = require_schema_obj();
      var stableStringify = require_fast_json_stable_stringify();
      var formats = require_formats();
      var rules = require_rules();
      var $dataMetaSchema = require_data();
      var util2 = require_util();
      module.exports = Ajv2;
      Ajv2.prototype.validate = validate;
      Ajv2.prototype.compile = compile;
      Ajv2.prototype.addSchema = addSchema;
      Ajv2.prototype.addMetaSchema = addMetaSchema;
      Ajv2.prototype.validateSchema = validateSchema;
      Ajv2.prototype.getSchema = getSchema;
      Ajv2.prototype.removeSchema = removeSchema;
      Ajv2.prototype.addFormat = addFormat;
      Ajv2.prototype.errorsText = errorsText;
      Ajv2.prototype._addSchema = _addSchema;
      Ajv2.prototype._compile = _compile;
      Ajv2.prototype.compileAsync = require_async();
      var customKeyword = require_keyword();
      Ajv2.prototype.addKeyword = customKeyword.add;
      Ajv2.prototype.getKeyword = customKeyword.get;
      Ajv2.prototype.removeKeyword = customKeyword.remove;
      Ajv2.prototype.validateKeyword = customKeyword.validate;
      var errorClasses = require_error_classes();
      Ajv2.ValidationError = errorClasses.Validation;
      Ajv2.MissingRefError = errorClasses.MissingRef;
      Ajv2.$dataMetaSchema = $dataMetaSchema;
      var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
      var META_SUPPORT_DATA = ["/properties"];
      function Ajv2(opts) {
        if (!(this instanceof Ajv2)) return new Ajv2(opts);
        opts = this._opts = util2.copy(opts) || {};
        setLogger(this);
        this._schemas = {};
        this._refs = {};
        this._fragments = {};
        this._formats = formats(opts.format);
        this._cache = opts.cache || new Cache();
        this._loadingSchemas = {};
        this._compilations = [];
        this.RULES = rules();
        this._getId = chooseGetId(opts);
        opts.loopRequired = opts.loopRequired || Infinity;
        if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
        if (opts.serialize === void 0) opts.serialize = stableStringify;
        this._metaOpts = getMetaSchemaOptions(this);
        if (opts.formats) addInitialFormats(this);
        if (opts.keywords) addInitialKeywords(this);
        addDefaultMetaSchema(this);
        if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
        if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
        addInitialSchemas(this);
      }
      function validate(schemaKeyRef, data) {
        var v2;
        if (typeof schemaKeyRef == "string") {
          v2 = this.getSchema(schemaKeyRef);
          if (!v2) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
        } else {
          var schemaObj = this._addSchema(schemaKeyRef);
          v2 = schemaObj.validate || this._compile(schemaObj);
        }
        var valid = v2(data);
        if (v2.$async !== true) this.errors = v2.errors;
        return valid;
      }
      function compile(schema, _meta) {
        var schemaObj = this._addSchema(schema, void 0, _meta);
        return schemaObj.validate || this._compile(schemaObj);
      }
      function addSchema(schema, key, _skipValidation, _meta) {
        if (Array.isArray(schema)) {
          for (var i2 = 0; i2 < schema.length; i2++) this.addSchema(schema[i2], void 0, _skipValidation, _meta);
          return this;
        }
        var id = this._getId(schema);
        if (id !== void 0 && typeof id != "string")
          throw new Error("schema id must be string");
        key = resolve.normalizeId(key || id);
        checkUnique(this, key);
        this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
        return this;
      }
      function addMetaSchema(schema, key, skipValidation) {
        this.addSchema(schema, key, skipValidation, true);
        return this;
      }
      function validateSchema(schema, throwOrLogError) {
        var $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        var valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          var message = "schema is invalid: " + this.errorsText();
          if (this._opts.validateSchema == "log") this.logger.error(message);
          else throw new Error(message);
        }
        return valid;
      }
      function defaultMeta(self2) {
        var meta = self2._opts.meta;
        self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
        return self2._opts.defaultMeta;
      }
      function getSchema(keyRef) {
        var schemaObj = _getSchemaObj(this, keyRef);
        switch (typeof schemaObj) {
          case "object":
            return schemaObj.validate || this._compile(schemaObj);
          case "string":
            return this.getSchema(schemaObj);
          case "undefined":
            return _getSchemaFragment(this, keyRef);
        }
      }
      function _getSchemaFragment(self2, ref) {
        var res = resolve.schema.call(self2, { schema: {} }, ref);
        if (res) {
          var schema = res.schema, root = res.root, baseId = res.baseId;
          var v2 = compileSchema.call(self2, schema, root, void 0, baseId);
          self2._fragments[ref] = new SchemaObject({
            ref,
            fragment: true,
            schema,
            root,
            baseId,
            validate: v2
          });
          return v2;
        }
      }
      function _getSchemaObj(self2, keyRef) {
        keyRef = resolve.normalizeId(keyRef);
        return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
      }
      function removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          _removeAllSchemas(this, this._schemas, schemaKeyRef);
          _removeAllSchemas(this, this._refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            _removeAllSchemas(this, this._schemas);
            _removeAllSchemas(this, this._refs);
            this._cache.clear();
            return this;
          case "string":
            var schemaObj = _getSchemaObj(this, schemaKeyRef);
            if (schemaObj) this._cache.del(schemaObj.cacheKey);
            delete this._schemas[schemaKeyRef];
            delete this._refs[schemaKeyRef];
            return this;
          case "object":
            var serialize = this._opts.serialize;
            var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
            this._cache.del(cacheKey);
            var id = this._getId(schemaKeyRef);
            if (id) {
              id = resolve.normalizeId(id);
              delete this._schemas[id];
              delete this._refs[id];
            }
        }
        return this;
      }
      function _removeAllSchemas(self2, schemas, regex) {
        for (var keyRef in schemas) {
          var schemaObj = schemas[keyRef];
          if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
            self2._cache.del(schemaObj.cacheKey);
            delete schemas[keyRef];
          }
        }
      }
      function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
        if (typeof schema != "object" && typeof schema != "boolean")
          throw new Error("schema should be object or boolean");
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schema) : schema;
        var cached = this._cache.get(cacheKey);
        if (cached) return cached;
        shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
        var id = resolve.normalizeId(this._getId(schema));
        if (id && shouldAddSchema) checkUnique(this, id);
        var willValidate = this._opts.validateSchema !== false && !skipValidation;
        var recursiveMeta;
        if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
          this.validateSchema(schema, true);
        var localRefs = resolve.ids.call(this, schema);
        var schemaObj = new SchemaObject({
          id,
          schema,
          localRefs,
          cacheKey,
          meta
        });
        if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
        this._cache.put(cacheKey, schemaObj);
        if (willValidate && recursiveMeta) this.validateSchema(schema, true);
        return schemaObj;
      }
      function _compile(schemaObj, root) {
        if (schemaObj.compiling) {
          schemaObj.validate = callValidate;
          callValidate.schema = schemaObj.schema;
          callValidate.errors = null;
          callValidate.root = root ? root : callValidate;
          if (schemaObj.schema.$async === true)
            callValidate.$async = true;
          return callValidate;
        }
        schemaObj.compiling = true;
        var currentOpts;
        if (schemaObj.meta) {
          currentOpts = this._opts;
          this._opts = this._metaOpts;
        }
        var v2;
        try {
          v2 = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
        } catch (e2) {
          delete schemaObj.validate;
          throw e2;
        } finally {
          schemaObj.compiling = false;
          if (schemaObj.meta) this._opts = currentOpts;
        }
        schemaObj.validate = v2;
        schemaObj.refs = v2.refs;
        schemaObj.refVal = v2.refVal;
        schemaObj.root = v2.root;
        return v2;
        function callValidate() {
          var _validate = schemaObj.validate;
          var result = _validate.apply(this, arguments);
          callValidate.errors = _validate.errors;
          return result;
        }
      }
      function chooseGetId(opts) {
        switch (opts.schemaId) {
          case "auto":
            return _get$IdOrId;
          case "id":
            return _getId;
          default:
            return _get$Id;
        }
      }
      function _getId(schema) {
        if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
        return schema.id;
      }
      function _get$Id(schema) {
        if (schema.id) this.logger.warn("schema id ignored", schema.id);
        return schema.$id;
      }
      function _get$IdOrId(schema) {
        if (schema.$id && schema.id && schema.$id != schema.id)
          throw new Error("schema $id is different from id");
        return schema.$id || schema.id;
      }
      function errorsText(errors, options) {
        errors = errors || this.errors;
        if (!errors) return "No errors";
        options = options || {};
        var separator = options.separator === void 0 ? ", " : options.separator;
        var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
        var text = "";
        for (var i2 = 0; i2 < errors.length; i2++) {
          var e2 = errors[i2];
          if (e2) text += dataVar + e2.dataPath + " " + e2.message + separator;
        }
        return text.slice(0, -separator.length);
      }
      function addFormat(name, format) {
        if (typeof format == "string") format = new RegExp(format);
        this._formats[name] = format;
        return this;
      }
      function addDefaultMetaSchema(self2) {
        var $dataSchema;
        if (self2._opts.$data) {
          $dataSchema = require_data2();
          self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
        }
        if (self2._opts.meta === false) return;
        var metaSchema = require_json_schema_draft_07();
        if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
        self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
        self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      function addInitialSchemas(self2) {
        var optsSchemas = self2._opts.schemas;
        if (!optsSchemas) return;
        if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
        else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats(self2) {
        for (var name in self2._opts.formats) {
          var format = self2._opts.formats[name];
          self2.addFormat(name, format);
        }
      }
      function addInitialKeywords(self2) {
        for (var name in self2._opts.keywords) {
          var keyword = self2._opts.keywords[name];
          self2.addKeyword(name, keyword);
        }
      }
      function checkUnique(self2, id) {
        if (self2._schemas[id] || self2._refs[id])
          throw new Error('schema with key or id "' + id + '" already exists');
      }
      function getMetaSchemaOptions(self2) {
        var metaOpts = util2.copy(self2._opts);
        for (var i2 = 0; i2 < META_IGNORE_OPTIONS.length; i2++)
          delete metaOpts[META_IGNORE_OPTIONS[i2]];
        return metaOpts;
      }
      function setLogger(self2) {
        var logger = self2._opts.logger;
        if (logger === false) {
          self2.logger = { log: noop, warn: noop, error: noop };
        } else {
          if (logger === void 0) logger = console;
          if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
            throw new Error("logger must implement log, warn and error methods");
          self2.logger = logger;
        }
      }
      function noop() {
      }
    }
  });

  // src/wordpress-integrations/angie/tec-mcp-server.ts
  var tec_mcp_server_exports = {};
  __export(tec_mcp_server_exports, {
    createTecMcpServer: () => createTecMcpServer,
    default: () => tec_mcp_server_default,
    initializeTecMcpServer: () => initializeTecMcpServer,
    tecTools: () => tecTools
  });

  // node_modules/@elementor/angie-sdk/dist/index.js
  var e;
  var t;
  var s;
  var a;
  !function(e2) {
    e2.POST_MESSAGE = "postMessage";
  }(e || (e = {})), function(e2) {
    e2.SDK_ANGIE_READY_PING = "sdk-angie-ready-ping", e2.SDK_REQUEST_CLIENT_CREATION = "sdk-request-client-creation", e2.SDK_REQUEST_INIT_SERVER = "sdk-request-init-server";
  }(t || (t = {}));
  var r = class {
    constructor() {
      __publicField(this, "isAngieReady", false);
      __publicField(this, "readyPromise");
      __publicField(this, "readyResolve");
      if (this.readyPromise = new Promise((e3) => {
        this.readyResolve = e3;
      }), "undefined" == typeof globalThis) return;
      let e2 = 0;
      const s2 = () => {
        if (this.isAngieReady || e2 >= 500) return void (!this.isAngieReady && e2 >= 500 && this.handleDetectionTimeout());
        const a2 = new MessageChannel();
        a2.port1.onmessage = (e3) => {
          this.handleAngieReady(e3.data), a2.port1.close(), a2.port2.close();
        };
        const r2 = { type: t.SDK_ANGIE_READY_PING, timestamp: Date.now() };
        globalThis.postMessage(r2, globalThis.location.origin, [a2.port2]), e2++, setTimeout(s2, 500);
      };
      s2();
    }
    handleAngieReady(e2) {
      this.isAngieReady = true;
      const t2 = { isReady: true, version: e2.version, capabilities: e2.capabilities };
      this.readyResolve && this.readyResolve(t2);
    }
    handleDetectionTimeout() {
      this.readyResolve && this.readyResolve({ isReady: false }), console.warn("AngieMcpSdk: AngieDetector: Detection timeout - Angie may not be available");
    }
    isReady() {
      return this.isAngieReady;
    }
    waitForReady() {
      return __async(this, null, function* () {
        return this.readyPromise;
      });
    }
  };
  var n = class {
    constructor() {
      __publicField(this, "queue", []);
      __publicField(this, "isProcessing", false);
    }
    add(e2) {
      const t2 = { id: this.generateId(e2), config: e2, timestamp: Date.now(), status: "pending" };
      return this.queue.push(t2), console.log(`RegistrationQueue: Added server "${e2.name}" to queue`), t2;
    }
    getAll() {
      return [...this.queue];
    }
    getPending() {
      return this.queue.filter((e2) => "pending" === e2.status);
    }
    updateStatus(e2, t2, s2) {
      const a2 = this.queue.find((t3) => t3.id === e2);
      a2 && (a2.status = t2, s2 && (a2.error = s2), console.log(`RegistrationQueue: Updated server ${e2} status to ${t2}`));
    }
    processQueue(e2) {
      return __async(this, null, function* () {
        if (this.isProcessing) return void console.log("RegistrationQueue: Already processing queue");
        this.isProcessing = true;
        const t2 = this.getPending();
        console.log(`RegistrationQueue: Processing ${t2.length} pending registrations`);
        try {
          for (const s2 of t2) try {
            yield e2(s2), this.updateStatus(s2.id, "registered");
          } catch (e3) {
            const t3 = e3 instanceof Error ? e3.message : String(e3);
            this.updateStatus(s2.id, "failed", t3), console.error(`RegistrationQueue: Failed to process registration ${s2.id}:`, t3);
          }
        } finally {
          this.isProcessing = false;
        }
      });
    }
    clear() {
      this.queue = [], console.log("RegistrationQueue: Cleared all registrations");
    }
    remove(e2) {
      const t2 = this.queue.findIndex((t3) => t3.id === e2);
      return -1 !== t2 && (this.queue.splice(t2, 1), console.log(`RegistrationQueue: Removed registration ${e2}`), true);
    }
    generateId(e2) {
      return `reg_${e2.name}_${e2.version}_${Date.now()}`;
    }
  };
  var i = class {
    requestClientCreation(s2) {
      return __async(this, null, function* () {
        const { config: a2 } = s2, r2 = { serverId: s2.id, serverName: a2.name, serverVersion: a2.version, description: a2.description, transport: e.POST_MESSAGE, capabilities: a2.capabilities };
        return new Promise((e2, s3) => {
          const a3 = new MessageChannel(), n2 = setTimeout(() => {
            s3(new Error("Client creation request timed out after 10000ms"));
          }, 1e4);
          a3.port1.onmessage = (t2) => {
            clearTimeout(n2), e2(t2.data);
          };
          const i2 = { type: t.SDK_REQUEST_CLIENT_CREATION, payload: r2, timestamp: Date.now() };
          globalThis.postMessage(i2, globalThis.location.origin, [a3.port2]);
        });
      });
    }
  };
  !function(e2) {
    e2.assertEqual = (e3) => {
    }, e2.assertIs = function(e3) {
    }, e2.assertNever = function(e3) {
      throw new Error();
    }, e2.arrayToEnum = (e3) => {
      const t2 = {};
      for (const s2 of e3) t2[s2] = s2;
      return t2;
    }, e2.getValidEnumValues = (t2) => {
      const s2 = e2.objectKeys(t2).filter((e3) => "number" != typeof t2[t2[e3]]), a2 = {};
      for (const e3 of s2) a2[e3] = t2[e3];
      return e2.objectValues(a2);
    }, e2.objectValues = (t2) => e2.objectKeys(t2).map(function(e3) {
      return t2[e3];
    }), e2.objectKeys = "function" == typeof Object.keys ? (e3) => Object.keys(e3) : (e3) => {
      const t2 = [];
      for (const s2 in e3) Object.prototype.hasOwnProperty.call(e3, s2) && t2.push(s2);
      return t2;
    }, e2.find = (e3, t2) => {
      for (const s2 of e3) if (t2(s2)) return s2;
    }, e2.isInteger = "function" == typeof Number.isInteger ? (e3) => Number.isInteger(e3) : (e3) => "number" == typeof e3 && Number.isFinite(e3) && Math.floor(e3) === e3, e2.joinValues = function(e3, t2 = " | ") {
      return e3.map((e4) => "string" == typeof e4 ? `'${e4}'` : e4).join(t2);
    }, e2.jsonStringifyReplacer = (e3, t2) => "bigint" == typeof t2 ? t2.toString() : t2;
  }(s || (s = {})), function(e2) {
    e2.mergeShapes = (e3, t2) => __spreadValues(__spreadValues({}, e3), t2);
  }(a || (a = {}));
  var o = s.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
  var d = (e2) => {
    switch (typeof e2) {
      case "undefined":
        return o.undefined;
      case "string":
        return o.string;
      case "number":
        return Number.isNaN(e2) ? o.nan : o.number;
      case "boolean":
        return o.boolean;
      case "function":
        return o.function;
      case "bigint":
        return o.bigint;
      case "symbol":
        return o.symbol;
      case "object":
        return Array.isArray(e2) ? o.array : null === e2 ? o.null : e2.then && "function" == typeof e2.then && e2.catch && "function" == typeof e2.catch ? o.promise : "undefined" != typeof Map && e2 instanceof Map ? o.map : "undefined" != typeof Set && e2 instanceof Set ? o.set : "undefined" != typeof Date && e2 instanceof Date ? o.date : o.object;
      default:
        return o.unknown;
    }
  };
  var c = s.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
  var u = class _u extends Error {
    get errors() {
      return this.issues;
    }
    constructor(e2) {
      super(), this.issues = [], this.addIssue = (e3) => {
        this.issues = [...this.issues, e3];
      }, this.addIssues = (e3 = []) => {
        this.issues = [...this.issues, ...e3];
      };
      const t2 = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, t2) : this.__proto__ = t2, this.name = "ZodError", this.issues = e2;
    }
    format(e2) {
      const t2 = e2 || function(e3) {
        return e3.message;
      }, s2 = { _errors: [] }, a2 = (e3) => {
        for (const r2 of e3.issues) if ("invalid_union" === r2.code) r2.unionErrors.map(a2);
        else if ("invalid_return_type" === r2.code) a2(r2.returnTypeError);
        else if ("invalid_arguments" === r2.code) a2(r2.argumentsError);
        else if (0 === r2.path.length) s2._errors.push(t2(r2));
        else {
          let e4 = s2, a3 = 0;
          for (; a3 < r2.path.length; ) {
            const s3 = r2.path[a3];
            a3 === r2.path.length - 1 ? (e4[s3] = e4[s3] || { _errors: [] }, e4[s3]._errors.push(t2(r2))) : e4[s3] = e4[s3] || { _errors: [] }, e4 = e4[s3], a3++;
          }
        }
      };
      return a2(this), s2;
    }
    static assert(e2) {
      if (!(e2 instanceof _u)) throw new Error(`Not a ZodError: ${e2}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, s.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return 0 === this.issues.length;
    }
    flatten(e2 = (e3) => e3.message) {
      const t2 = {}, s2 = [];
      for (const a2 of this.issues) a2.path.length > 0 ? (t2[a2.path[0]] = t2[a2.path[0]] || [], t2[a2.path[0]].push(e2(a2))) : s2.push(e2(a2));
      return { formErrors: s2, fieldErrors: t2 };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  u.create = (e2) => new u(e2);
  var l = (e2, t2) => {
    let a2;
    switch (e2.code) {
      case c.invalid_type:
        a2 = e2.received === o.undefined ? "Required" : `Expected ${e2.expected}, received ${e2.received}`;
        break;
      case c.invalid_literal:
        a2 = `Invalid literal value, expected ${JSON.stringify(e2.expected, s.jsonStringifyReplacer)}`;
        break;
      case c.unrecognized_keys:
        a2 = `Unrecognized key(s) in object: ${s.joinValues(e2.keys, ", ")}`;
        break;
      case c.invalid_union:
        a2 = "Invalid input";
        break;
      case c.invalid_union_discriminator:
        a2 = `Invalid discriminator value. Expected ${s.joinValues(e2.options)}`;
        break;
      case c.invalid_enum_value:
        a2 = `Invalid enum value. Expected ${s.joinValues(e2.options)}, received '${e2.received}'`;
        break;
      case c.invalid_arguments:
        a2 = "Invalid function arguments";
        break;
      case c.invalid_return_type:
        a2 = "Invalid function return type";
        break;
      case c.invalid_date:
        a2 = "Invalid date";
        break;
      case c.invalid_string:
        "object" == typeof e2.validation ? "includes" in e2.validation ? (a2 = `Invalid input: must include "${e2.validation.includes}"`, "number" == typeof e2.validation.position && (a2 = `${a2} at one or more positions greater than or equal to ${e2.validation.position}`)) : "startsWith" in e2.validation ? a2 = `Invalid input: must start with "${e2.validation.startsWith}"` : "endsWith" in e2.validation ? a2 = `Invalid input: must end with "${e2.validation.endsWith}"` : s.assertNever(e2.validation) : a2 = "regex" !== e2.validation ? `Invalid ${e2.validation}` : "Invalid";
        break;
      case c.too_small:
        a2 = "array" === e2.type ? `Array must contain ${e2.exact ? "exactly" : e2.inclusive ? "at least" : "more than"} ${e2.minimum} element(s)` : "string" === e2.type ? `String must contain ${e2.exact ? "exactly" : e2.inclusive ? "at least" : "over"} ${e2.minimum} character(s)` : "number" === e2.type ? `Number must be ${e2.exact ? "exactly equal to " : e2.inclusive ? "greater than or equal to " : "greater than "}${e2.minimum}` : "date" === e2.type ? `Date must be ${e2.exact ? "exactly equal to " : e2.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e2.minimum))}` : "Invalid input";
        break;
      case c.too_big:
        a2 = "array" === e2.type ? `Array must contain ${e2.exact ? "exactly" : e2.inclusive ? "at most" : "less than"} ${e2.maximum} element(s)` : "string" === e2.type ? `String must contain ${e2.exact ? "exactly" : e2.inclusive ? "at most" : "under"} ${e2.maximum} character(s)` : "number" === e2.type ? `Number must be ${e2.exact ? "exactly" : e2.inclusive ? "less than or equal to" : "less than"} ${e2.maximum}` : "bigint" === e2.type ? `BigInt must be ${e2.exact ? "exactly" : e2.inclusive ? "less than or equal to" : "less than"} ${e2.maximum}` : "date" === e2.type ? `Date must be ${e2.exact ? "exactly" : e2.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e2.maximum))}` : "Invalid input";
        break;
      case c.custom:
        a2 = "Invalid input";
        break;
      case c.invalid_intersection_types:
        a2 = "Intersection results could not be merged";
        break;
      case c.not_multiple_of:
        a2 = `Number must be a multiple of ${e2.multipleOf}`;
        break;
      case c.not_finite:
        a2 = "Number must be finite";
        break;
      default:
        a2 = t2.defaultError, s.assertNever(e2);
    }
    return { message: a2 };
  };
  var h = l;
  function p(e2, t2) {
    const s2 = h, a2 = ((e3) => {
      const { data: t3, path: s3, errorMaps: a3, issueData: r2 } = e3, n2 = [...s3, ...r2.path || []], i2 = __spreadProps(__spreadValues({}, r2), { path: n2 });
      if (void 0 !== r2.message) return __spreadProps(__spreadValues({}, r2), { path: n2, message: r2.message });
      let o2 = "";
      const d2 = a3.filter((e4) => !!e4).slice().reverse();
      for (const e4 of d2) o2 = e4(i2, { data: t3, defaultError: o2 }).message;
      return __spreadProps(__spreadValues({}, r2), { path: n2, message: o2 });
    })({ issueData: t2, data: e2.data, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, s2, s2 === l ? void 0 : l].filter((e3) => !!e3) });
    e2.common.issues.push(a2);
  }
  var m = class _m {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      "valid" === this.value && (this.value = "dirty");
    }
    abort() {
      "aborted" !== this.value && (this.value = "aborted");
    }
    static mergeArray(e2, t2) {
      const s2 = [];
      for (const a2 of t2) {
        if ("aborted" === a2.status) return g;
        "dirty" === a2.status && e2.dirty(), s2.push(a2.value);
      }
      return { status: e2.value, value: s2 };
    }
    static mergeObjectAsync(e2, t2) {
      return __async(this, null, function* () {
        const s2 = [];
        for (const e3 of t2) {
          const t3 = yield e3.key, a2 = yield e3.value;
          s2.push({ key: t3, value: a2 });
        }
        return _m.mergeObjectSync(e2, s2);
      });
    }
    static mergeObjectSync(e2, t2) {
      const s2 = {};
      for (const a2 of t2) {
        const { key: t3, value: r2 } = a2;
        if ("aborted" === t3.status) return g;
        if ("aborted" === r2.status) return g;
        "dirty" === t3.status && e2.dirty(), "dirty" === r2.status && e2.dirty(), "__proto__" === t3.value || void 0 === r2.value && !a2.alwaysSet || (s2[t3.value] = r2.value);
      }
      return { status: e2.value, value: s2 };
    }
  };
  var g = Object.freeze({ status: "aborted" });
  var f = (e2) => ({ status: "dirty", value: e2 });
  var y = (e2) => ({ status: "valid", value: e2 });
  var _ = (e2) => "aborted" === e2.status;
  var v = (e2) => "dirty" === e2.status;
  var x = (e2) => "valid" === e2.status;
  var k = (e2) => "undefined" != typeof Promise && e2 instanceof Promise;
  var b;
  !function(e2) {
    e2.errToObj = (e3) => "string" == typeof e3 ? { message: e3 } : e3 || {}, e2.toString = (e3) => "string" == typeof e3 ? e3 : e3 == null ? void 0 : e3.message;
  }(b || (b = {}));
  var w = class {
    constructor(e2, t2, s2, a2) {
      this._cachedPath = [], this.parent = e2, this.data = t2, this._path = s2, this._key = a2;
    }
    get path() {
      return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  };
  var S = (e2, t2) => {
    if (x(t2)) return { success: true, data: t2.value };
    if (!e2.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return { success: false, get error() {
      if (this._error) return this._error;
      const t3 = new u(e2.common.issues);
      return this._error = t3, this._error;
    } };
  };
  function T(e2) {
    if (!e2) return {};
    const { errorMap: t2, invalid_type_error: s2, required_error: a2, description: r2 } = e2;
    if (t2 && (s2 || a2)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t2 ? { errorMap: t2, description: r2 } : { errorMap: (t3, r3) => {
      var _a, _b;
      const { message: n2 } = e2;
      return "invalid_enum_value" === t3.code ? { message: n2 != null ? n2 : r3.defaultError } : void 0 === r3.data ? { message: (_a = n2 != null ? n2 : a2) != null ? _a : r3.defaultError } : "invalid_type" !== t3.code ? { message: r3.defaultError } : { message: (_b = n2 != null ? n2 : s2) != null ? _b : r3.defaultError };
    }, description: r2 };
  }
  var A = class {
    get description() {
      return this._def.description;
    }
    _getType(e2) {
      return d(e2.data);
    }
    _getOrReturnCtx(e2, t2) {
      return t2 || { common: e2.parent.common, data: e2.data, parsedType: d(e2.data), schemaErrorMap: this._def.errorMap, path: e2.path, parent: e2.parent };
    }
    _processInputParams(e2) {
      return { status: new m(), ctx: { common: e2.parent.common, data: e2.data, parsedType: d(e2.data), schemaErrorMap: this._def.errorMap, path: e2.path, parent: e2.parent } };
    }
    _parseSync(e2) {
      const t2 = this._parse(e2);
      if (k(t2)) throw new Error("Synchronous parse encountered promise.");
      return t2;
    }
    _parseAsync(e2) {
      const t2 = this._parse(e2);
      return Promise.resolve(t2);
    }
    parse(e2, t2) {
      const s2 = this.safeParse(e2, t2);
      if (s2.success) return s2.data;
      throw s2.error;
    }
    safeParse(e2, t2) {
      var _a;
      const s2 = { common: { issues: [], async: (_a = t2 == null ? void 0 : t2.async) != null ? _a : false, contextualErrorMap: t2 == null ? void 0 : t2.errorMap }, path: (t2 == null ? void 0 : t2.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e2, parsedType: d(e2) }, a2 = this._parseSync({ data: e2, path: s2.path, parent: s2 });
      return S(s2, a2);
    }
    "~validate"(e2) {
      var _a, _b;
      const t2 = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: e2, parsedType: d(e2) };
      if (!this["~standard"].async) try {
        const s2 = this._parseSync({ data: e2, path: [], parent: t2 });
        return x(s2) ? { value: s2.value } : { issues: t2.common.issues };
      } catch (e3) {
        ((_b = (_a = e3 == null ? void 0 : e3.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) && (this["~standard"].async = true), t2.common = { issues: [], async: true };
      }
      return this._parseAsync({ data: e2, path: [], parent: t2 }).then((e3) => x(e3) ? { value: e3.value } : { issues: t2.common.issues });
    }
    parseAsync(e2, t2) {
      return __async(this, null, function* () {
        const s2 = yield this.safeParseAsync(e2, t2);
        if (s2.success) return s2.data;
        throw s2.error;
      });
    }
    safeParseAsync(e2, t2) {
      return __async(this, null, function* () {
        const s2 = { common: { issues: [], contextualErrorMap: t2 == null ? void 0 : t2.errorMap, async: true }, path: (t2 == null ? void 0 : t2.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e2, parsedType: d(e2) }, a2 = this._parse({ data: e2, path: s2.path, parent: s2 }), r2 = yield k(a2) ? a2 : Promise.resolve(a2);
        return S(s2, r2);
      });
    }
    refine(e2, t2) {
      const s2 = (e3) => "string" == typeof t2 || void 0 === t2 ? { message: t2 } : "function" == typeof t2 ? t2(e3) : t2;
      return this._refinement((t3, a2) => {
        const r2 = e2(t3), n2 = () => a2.addIssue(__spreadValues({ code: c.custom }, s2(t3)));
        return "undefined" != typeof Promise && r2 instanceof Promise ? r2.then((e3) => !!e3 || (n2(), false)) : !!r2 || (n2(), false);
      });
    }
    refinement(e2, t2) {
      return this._refinement((s2, a2) => !!e2(s2) || (a2.addIssue("function" == typeof t2 ? t2(s2, a2) : t2), false));
    }
    _refinement(e2) {
      return new Te({ schema: this, typeName: je.ZodEffects, effect: { type: "refinement", refinement: e2 } });
    }
    superRefine(e2) {
      return this._refinement(e2);
    }
    constructor(e2) {
      this.spa = this.safeParseAsync, this._def = e2, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (e3) => this["~validate"](e3) };
    }
    optional() {
      return Ae.create(this, this._def);
    }
    nullable() {
      return Ce.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return oe.create(this);
    }
    promise() {
      return Se.create(this, this._def);
    }
    or(e2) {
      return ue.create([this, e2], this._def);
    }
    and(e2) {
      return me.create(this, e2, this._def);
    }
    transform(e2) {
      return new Te(__spreadProps(__spreadValues({}, T(this._def)), { schema: this, typeName: je.ZodEffects, effect: { type: "transform", transform: e2 } }));
    }
    default(e2) {
      const t2 = "function" == typeof e2 ? e2 : () => e2;
      return new Re(__spreadProps(__spreadValues({}, T(this._def)), { innerType: this, defaultValue: t2, typeName: je.ZodDefault }));
    }
    brand() {
      return new Ie(__spreadValues({ typeName: je.ZodBranded, type: this }, T(this._def)));
    }
    catch(e2) {
      const t2 = "function" == typeof e2 ? e2 : () => e2;
      return new Ze(__spreadProps(__spreadValues({}, T(this._def)), { innerType: this, catchValue: t2, typeName: je.ZodCatch }));
    }
    describe(e2) {
      return new (0, this.constructor)(__spreadProps(__spreadValues({}, this._def), { description: e2 }));
    }
    pipe(e2) {
      return Ee.create(this, e2);
    }
    readonly() {
      return Ne.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var C = /^c[^\s-]{8,}$/i;
  var R = /^[0-9a-z]+$/;
  var Z = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  var O = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var I = /^[a-z0-9_-]{21}$/i;
  var E = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  var N = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var j = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var P;
  var $ = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var M = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  var D = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  var F = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var q = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var z = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  var L = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
  var V = new RegExp(`^${L}$`);
  function U(e2) {
    let t2 = "[0-5]\\d";
    return e2.precision ? t2 = `${t2}\\.\\d{${e2.precision}}` : null == e2.precision && (t2 = `${t2}(\\.\\d+)?`), `([01]\\d|2[0-3]):[0-5]\\d(:${t2})${e2.precision ? "+" : "?"}`;
  }
  function K(e2) {
    let t2 = `${L}T${U(e2)}`;
    const s2 = [];
    return s2.push(e2.local ? "Z?" : "Z"), e2.offset && s2.push("([+-]\\d{2}:?\\d{2})"), t2 = `${t2}(${s2.join("|")})`, new RegExp(`^${t2}$`);
  }
  function Q(e2, t2) {
    if (!E.test(e2)) return false;
    try {
      const [s2] = e2.split("."), a2 = s2.replace(/-/g, "+").replace(/_/g, "/").padEnd(s2.length + (4 - s2.length % 4) % 4, "="), r2 = JSON.parse(atob(a2));
      return !("object" != typeof r2 || null === r2 || "typ" in r2 && "JWT" !== (r2 == null ? void 0 : r2.typ) || !r2.alg || t2 && r2.alg !== t2);
    } catch (e3) {
      return false;
    }
  }
  function B(e2, t2) {
    return !("v4" !== t2 && t2 || !M.test(e2)) || !("v6" !== t2 && t2 || !F.test(e2));
  }
  var W = class _W extends A {
    _parse(e2) {
      if (this._def.coerce && (e2.data = String(e2.data)), this._getType(e2) !== o.string) {
        const t3 = this._getOrReturnCtx(e2);
        return p(t3, { code: c.invalid_type, expected: o.string, received: t3.parsedType }), g;
      }
      const t2 = new m();
      let a2;
      for (const i2 of this._def.checks) if ("min" === i2.kind) e2.data.length < i2.value && (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.too_small, minimum: i2.value, type: "string", inclusive: true, exact: false, message: i2.message }), t2.dirty());
      else if ("max" === i2.kind) e2.data.length > i2.value && (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.too_big, maximum: i2.value, type: "string", inclusive: true, exact: false, message: i2.message }), t2.dirty());
      else if ("length" === i2.kind) {
        const s2 = e2.data.length > i2.value, r3 = e2.data.length < i2.value;
        (s2 || r3) && (a2 = this._getOrReturnCtx(e2, a2), s2 ? p(a2, { code: c.too_big, maximum: i2.value, type: "string", inclusive: true, exact: true, message: i2.message }) : r3 && p(a2, { code: c.too_small, minimum: i2.value, type: "string", inclusive: true, exact: true, message: i2.message }), t2.dirty());
      } else if ("email" === i2.kind) j.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "email", code: c.invalid_string, message: i2.message }), t2.dirty());
      else if ("emoji" === i2.kind) P || (P = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), P.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "emoji", code: c.invalid_string, message: i2.message }), t2.dirty());
      else if ("uuid" === i2.kind) O.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "uuid", code: c.invalid_string, message: i2.message }), t2.dirty());
      else if ("nanoid" === i2.kind) I.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "nanoid", code: c.invalid_string, message: i2.message }), t2.dirty());
      else if ("cuid" === i2.kind) C.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "cuid", code: c.invalid_string, message: i2.message }), t2.dirty());
      else if ("cuid2" === i2.kind) R.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "cuid2", code: c.invalid_string, message: i2.message }), t2.dirty());
      else if ("ulid" === i2.kind) Z.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "ulid", code: c.invalid_string, message: i2.message }), t2.dirty());
      else if ("url" === i2.kind) try {
        new URL(e2.data);
      } catch (e3) {
        a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "url", code: c.invalid_string, message: i2.message }), t2.dirty();
      }
      else "regex" === i2.kind ? (i2.regex.lastIndex = 0, i2.regex.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "regex", code: c.invalid_string, message: i2.message }), t2.dirty())) : "trim" === i2.kind ? e2.data = e2.data.trim() : "includes" === i2.kind ? e2.data.includes(i2.value, i2.position) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.invalid_string, validation: { includes: i2.value, position: i2.position }, message: i2.message }), t2.dirty()) : "toLowerCase" === i2.kind ? e2.data = e2.data.toLowerCase() : "toUpperCase" === i2.kind ? e2.data = e2.data.toUpperCase() : "startsWith" === i2.kind ? e2.data.startsWith(i2.value) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.invalid_string, validation: { startsWith: i2.value }, message: i2.message }), t2.dirty()) : "endsWith" === i2.kind ? e2.data.endsWith(i2.value) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.invalid_string, validation: { endsWith: i2.value }, message: i2.message }), t2.dirty()) : "datetime" === i2.kind ? K(i2).test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.invalid_string, validation: "datetime", message: i2.message }), t2.dirty()) : "date" === i2.kind ? V.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.invalid_string, validation: "date", message: i2.message }), t2.dirty()) : "time" === i2.kind ? new RegExp(`^${U(i2)}$`).test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.invalid_string, validation: "time", message: i2.message }), t2.dirty()) : "duration" === i2.kind ? N.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "duration", code: c.invalid_string, message: i2.message }), t2.dirty()) : "ip" === i2.kind ? (r2 = e2.data, ("v4" !== (n2 = i2.version) && n2 || !$.test(r2)) && ("v6" !== n2 && n2 || !D.test(r2)) && (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "ip", code: c.invalid_string, message: i2.message }), t2.dirty())) : "jwt" === i2.kind ? Q(e2.data, i2.alg) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "jwt", code: c.invalid_string, message: i2.message }), t2.dirty()) : "cidr" === i2.kind ? B(e2.data, i2.version) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "cidr", code: c.invalid_string, message: i2.message }), t2.dirty()) : "base64" === i2.kind ? q.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "base64", code: c.invalid_string, message: i2.message }), t2.dirty()) : "base64url" === i2.kind ? z.test(e2.data) || (a2 = this._getOrReturnCtx(e2, a2), p(a2, { validation: "base64url", code: c.invalid_string, message: i2.message }), t2.dirty()) : s.assertNever(i2);
      var r2, n2;
      return { status: t2.value, value: e2.data };
    }
    _regex(e2, t2, s2) {
      return this.refinement((t3) => e2.test(t3), __spreadValues({ validation: t2, code: c.invalid_string }, b.errToObj(s2)));
    }
    _addCheck(e2) {
      return new _W(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, e2] }));
    }
    email(e2) {
      return this._addCheck(__spreadValues({ kind: "email" }, b.errToObj(e2)));
    }
    url(e2) {
      return this._addCheck(__spreadValues({ kind: "url" }, b.errToObj(e2)));
    }
    emoji(e2) {
      return this._addCheck(__spreadValues({ kind: "emoji" }, b.errToObj(e2)));
    }
    uuid(e2) {
      return this._addCheck(__spreadValues({ kind: "uuid" }, b.errToObj(e2)));
    }
    nanoid(e2) {
      return this._addCheck(__spreadValues({ kind: "nanoid" }, b.errToObj(e2)));
    }
    cuid(e2) {
      return this._addCheck(__spreadValues({ kind: "cuid" }, b.errToObj(e2)));
    }
    cuid2(e2) {
      return this._addCheck(__spreadValues({ kind: "cuid2" }, b.errToObj(e2)));
    }
    ulid(e2) {
      return this._addCheck(__spreadValues({ kind: "ulid" }, b.errToObj(e2)));
    }
    base64(e2) {
      return this._addCheck(__spreadValues({ kind: "base64" }, b.errToObj(e2)));
    }
    base64url(e2) {
      return this._addCheck(__spreadValues({ kind: "base64url" }, b.errToObj(e2)));
    }
    jwt(e2) {
      return this._addCheck(__spreadValues({ kind: "jwt" }, b.errToObj(e2)));
    }
    ip(e2) {
      return this._addCheck(__spreadValues({ kind: "ip" }, b.errToObj(e2)));
    }
    cidr(e2) {
      return this._addCheck(__spreadValues({ kind: "cidr" }, b.errToObj(e2)));
    }
    datetime(e2) {
      var _a, _b;
      return "string" == typeof e2 ? this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: e2 }) : this._addCheck(__spreadValues({ kind: "datetime", precision: void 0 === (e2 == null ? void 0 : e2.precision) ? null : e2 == null ? void 0 : e2.precision, offset: (_a = e2 == null ? void 0 : e2.offset) != null ? _a : false, local: (_b = e2 == null ? void 0 : e2.local) != null ? _b : false }, b.errToObj(e2 == null ? void 0 : e2.message)));
    }
    date(e2) {
      return this._addCheck({ kind: "date", message: e2 });
    }
    time(e2) {
      return "string" == typeof e2 ? this._addCheck({ kind: "time", precision: null, message: e2 }) : this._addCheck(__spreadValues({ kind: "time", precision: void 0 === (e2 == null ? void 0 : e2.precision) ? null : e2 == null ? void 0 : e2.precision }, b.errToObj(e2 == null ? void 0 : e2.message)));
    }
    duration(e2) {
      return this._addCheck(__spreadValues({ kind: "duration" }, b.errToObj(e2)));
    }
    regex(e2, t2) {
      return this._addCheck(__spreadValues({ kind: "regex", regex: e2 }, b.errToObj(t2)));
    }
    includes(e2, t2) {
      return this._addCheck(__spreadValues({ kind: "includes", value: e2, position: t2 == null ? void 0 : t2.position }, b.errToObj(t2 == null ? void 0 : t2.message)));
    }
    startsWith(e2, t2) {
      return this._addCheck(__spreadValues({ kind: "startsWith", value: e2 }, b.errToObj(t2)));
    }
    endsWith(e2, t2) {
      return this._addCheck(__spreadValues({ kind: "endsWith", value: e2 }, b.errToObj(t2)));
    }
    min(e2, t2) {
      return this._addCheck(__spreadValues({ kind: "min", value: e2 }, b.errToObj(t2)));
    }
    max(e2, t2) {
      return this._addCheck(__spreadValues({ kind: "max", value: e2 }, b.errToObj(t2)));
    }
    length(e2, t2) {
      return this._addCheck(__spreadValues({ kind: "length", value: e2 }, b.errToObj(t2)));
    }
    nonempty(e2) {
      return this.min(1, b.errToObj(e2));
    }
    trim() {
      return new _W(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, { kind: "trim" }] }));
    }
    toLowerCase() {
      return new _W(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, { kind: "toLowerCase" }] }));
    }
    toUpperCase() {
      return new _W(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, { kind: "toUpperCase" }] }));
    }
    get isDatetime() {
      return !!this._def.checks.find((e2) => "datetime" === e2.kind);
    }
    get isDate() {
      return !!this._def.checks.find((e2) => "date" === e2.kind);
    }
    get isTime() {
      return !!this._def.checks.find((e2) => "time" === e2.kind);
    }
    get isDuration() {
      return !!this._def.checks.find((e2) => "duration" === e2.kind);
    }
    get isEmail() {
      return !!this._def.checks.find((e2) => "email" === e2.kind);
    }
    get isURL() {
      return !!this._def.checks.find((e2) => "url" === e2.kind);
    }
    get isEmoji() {
      return !!this._def.checks.find((e2) => "emoji" === e2.kind);
    }
    get isUUID() {
      return !!this._def.checks.find((e2) => "uuid" === e2.kind);
    }
    get isNANOID() {
      return !!this._def.checks.find((e2) => "nanoid" === e2.kind);
    }
    get isCUID() {
      return !!this._def.checks.find((e2) => "cuid" === e2.kind);
    }
    get isCUID2() {
      return !!this._def.checks.find((e2) => "cuid2" === e2.kind);
    }
    get isULID() {
      return !!this._def.checks.find((e2) => "ulid" === e2.kind);
    }
    get isIP() {
      return !!this._def.checks.find((e2) => "ip" === e2.kind);
    }
    get isCIDR() {
      return !!this._def.checks.find((e2) => "cidr" === e2.kind);
    }
    get isBase64() {
      return !!this._def.checks.find((e2) => "base64" === e2.kind);
    }
    get isBase64url() {
      return !!this._def.checks.find((e2) => "base64url" === e2.kind);
    }
    get minLength() {
      let e2 = null;
      for (const t2 of this._def.checks) "min" === t2.kind && (null === e2 || t2.value > e2) && (e2 = t2.value);
      return e2;
    }
    get maxLength() {
      let e2 = null;
      for (const t2 of this._def.checks) "max" === t2.kind && (null === e2 || t2.value < e2) && (e2 = t2.value);
      return e2;
    }
  };
  function H(e2, t2) {
    const s2 = (e2.toString().split(".")[1] || "").length, a2 = (t2.toString().split(".")[1] || "").length, r2 = s2 > a2 ? s2 : a2;
    return Number.parseInt(e2.toFixed(r2).replace(".", "")) % Number.parseInt(t2.toFixed(r2).replace(".", "")) / __pow(10, r2);
  }
  W.create = (e2) => {
    var _a;
    return new W(__spreadValues({ checks: [], typeName: je.ZodString, coerce: (_a = e2 == null ? void 0 : e2.coerce) != null ? _a : false }, T(e2)));
  };
  var G = class _G extends A {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(e2) {
      if (this._def.coerce && (e2.data = Number(e2.data)), this._getType(e2) !== o.number) {
        const t3 = this._getOrReturnCtx(e2);
        return p(t3, { code: c.invalid_type, expected: o.number, received: t3.parsedType }), g;
      }
      let t2;
      const a2 = new m();
      for (const r2 of this._def.checks) "int" === r2.kind ? s.isInteger(e2.data) || (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.invalid_type, expected: "integer", received: "float", message: r2.message }), a2.dirty()) : "min" === r2.kind ? (r2.inclusive ? e2.data < r2.value : e2.data <= r2.value) && (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.too_small, minimum: r2.value, type: "number", inclusive: r2.inclusive, exact: false, message: r2.message }), a2.dirty()) : "max" === r2.kind ? (r2.inclusive ? e2.data > r2.value : e2.data >= r2.value) && (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.too_big, maximum: r2.value, type: "number", inclusive: r2.inclusive, exact: false, message: r2.message }), a2.dirty()) : "multipleOf" === r2.kind ? 0 !== H(e2.data, r2.value) && (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.not_multiple_of, multipleOf: r2.value, message: r2.message }), a2.dirty()) : "finite" === r2.kind ? Number.isFinite(e2.data) || (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.not_finite, message: r2.message }), a2.dirty()) : s.assertNever(r2);
      return { status: a2.value, value: e2.data };
    }
    gte(e2, t2) {
      return this.setLimit("min", e2, true, b.toString(t2));
    }
    gt(e2, t2) {
      return this.setLimit("min", e2, false, b.toString(t2));
    }
    lte(e2, t2) {
      return this.setLimit("max", e2, true, b.toString(t2));
    }
    lt(e2, t2) {
      return this.setLimit("max", e2, false, b.toString(t2));
    }
    setLimit(e2, t2, s2, a2) {
      return new _G(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, { kind: e2, value: t2, inclusive: s2, message: b.toString(a2) }] }));
    }
    _addCheck(e2) {
      return new _G(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, e2] }));
    }
    int(e2) {
      return this._addCheck({ kind: "int", message: b.toString(e2) });
    }
    positive(e2) {
      return this._addCheck({ kind: "min", value: 0, inclusive: false, message: b.toString(e2) });
    }
    negative(e2) {
      return this._addCheck({ kind: "max", value: 0, inclusive: false, message: b.toString(e2) });
    }
    nonpositive(e2) {
      return this._addCheck({ kind: "max", value: 0, inclusive: true, message: b.toString(e2) });
    }
    nonnegative(e2) {
      return this._addCheck({ kind: "min", value: 0, inclusive: true, message: b.toString(e2) });
    }
    multipleOf(e2, t2) {
      return this._addCheck({ kind: "multipleOf", value: e2, message: b.toString(t2) });
    }
    finite(e2) {
      return this._addCheck({ kind: "finite", message: b.toString(e2) });
    }
    safe(e2) {
      return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: b.toString(e2) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: b.toString(e2) });
    }
    get minValue() {
      let e2 = null;
      for (const t2 of this._def.checks) "min" === t2.kind && (null === e2 || t2.value > e2) && (e2 = t2.value);
      return e2;
    }
    get maxValue() {
      let e2 = null;
      for (const t2 of this._def.checks) "max" === t2.kind && (null === e2 || t2.value < e2) && (e2 = t2.value);
      return e2;
    }
    get isInt() {
      return !!this._def.checks.find((e2) => "int" === e2.kind || "multipleOf" === e2.kind && s.isInteger(e2.value));
    }
    get isFinite() {
      let e2 = null, t2 = null;
      for (const s2 of this._def.checks) {
        if ("finite" === s2.kind || "int" === s2.kind || "multipleOf" === s2.kind) return true;
        "min" === s2.kind ? (null === t2 || s2.value > t2) && (t2 = s2.value) : "max" === s2.kind && (null === e2 || s2.value < e2) && (e2 = s2.value);
      }
      return Number.isFinite(t2) && Number.isFinite(e2);
    }
  };
  G.create = (e2) => new G(__spreadValues({ checks: [], typeName: je.ZodNumber, coerce: (e2 == null ? void 0 : e2.coerce) || false }, T(e2)));
  var J = class _J extends A {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(e2) {
      if (this._def.coerce) try {
        e2.data = BigInt(e2.data);
      } catch (e3) {
        return this._getInvalidInput(e2);
      }
      if (this._getType(e2) !== o.bigint) return this._getInvalidInput(e2);
      let t2;
      const a2 = new m();
      for (const r2 of this._def.checks) "min" === r2.kind ? (r2.inclusive ? e2.data < r2.value : e2.data <= r2.value) && (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.too_small, type: "bigint", minimum: r2.value, inclusive: r2.inclusive, message: r2.message }), a2.dirty()) : "max" === r2.kind ? (r2.inclusive ? e2.data > r2.value : e2.data >= r2.value) && (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.too_big, type: "bigint", maximum: r2.value, inclusive: r2.inclusive, message: r2.message }), a2.dirty()) : "multipleOf" === r2.kind ? e2.data % r2.value !== BigInt(0) && (t2 = this._getOrReturnCtx(e2, t2), p(t2, { code: c.not_multiple_of, multipleOf: r2.value, message: r2.message }), a2.dirty()) : s.assertNever(r2);
      return { status: a2.value, value: e2.data };
    }
    _getInvalidInput(e2) {
      const t2 = this._getOrReturnCtx(e2);
      return p(t2, { code: c.invalid_type, expected: o.bigint, received: t2.parsedType }), g;
    }
    gte(e2, t2) {
      return this.setLimit("min", e2, true, b.toString(t2));
    }
    gt(e2, t2) {
      return this.setLimit("min", e2, false, b.toString(t2));
    }
    lte(e2, t2) {
      return this.setLimit("max", e2, true, b.toString(t2));
    }
    lt(e2, t2) {
      return this.setLimit("max", e2, false, b.toString(t2));
    }
    setLimit(e2, t2, s2, a2) {
      return new _J(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, { kind: e2, value: t2, inclusive: s2, message: b.toString(a2) }] }));
    }
    _addCheck(e2) {
      return new _J(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, e2] }));
    }
    positive(e2) {
      return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: b.toString(e2) });
    }
    negative(e2) {
      return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: b.toString(e2) });
    }
    nonpositive(e2) {
      return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: b.toString(e2) });
    }
    nonnegative(e2) {
      return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: b.toString(e2) });
    }
    multipleOf(e2, t2) {
      return this._addCheck({ kind: "multipleOf", value: e2, message: b.toString(t2) });
    }
    get minValue() {
      let e2 = null;
      for (const t2 of this._def.checks) "min" === t2.kind && (null === e2 || t2.value > e2) && (e2 = t2.value);
      return e2;
    }
    get maxValue() {
      let e2 = null;
      for (const t2 of this._def.checks) "max" === t2.kind && (null === e2 || t2.value < e2) && (e2 = t2.value);
      return e2;
    }
  };
  J.create = (e2) => {
    var _a;
    return new J(__spreadValues({ checks: [], typeName: je.ZodBigInt, coerce: (_a = e2 == null ? void 0 : e2.coerce) != null ? _a : false }, T(e2)));
  };
  var Y = class extends A {
    _parse(e2) {
      if (this._def.coerce && (e2.data = Boolean(e2.data)), this._getType(e2) !== o.boolean) {
        const t2 = this._getOrReturnCtx(e2);
        return p(t2, { code: c.invalid_type, expected: o.boolean, received: t2.parsedType }), g;
      }
      return y(e2.data);
    }
  };
  Y.create = (e2) => new Y(__spreadValues({ typeName: je.ZodBoolean, coerce: (e2 == null ? void 0 : e2.coerce) || false }, T(e2)));
  var X = class _X extends A {
    _parse(e2) {
      if (this._def.coerce && (e2.data = new Date(e2.data)), this._getType(e2) !== o.date) {
        const t3 = this._getOrReturnCtx(e2);
        return p(t3, { code: c.invalid_type, expected: o.date, received: t3.parsedType }), g;
      }
      if (Number.isNaN(e2.data.getTime())) return p(this._getOrReturnCtx(e2), { code: c.invalid_date }), g;
      const t2 = new m();
      let a2;
      for (const r2 of this._def.checks) "min" === r2.kind ? e2.data.getTime() < r2.value && (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.too_small, message: r2.message, inclusive: true, exact: false, minimum: r2.value, type: "date" }), t2.dirty()) : "max" === r2.kind ? e2.data.getTime() > r2.value && (a2 = this._getOrReturnCtx(e2, a2), p(a2, { code: c.too_big, message: r2.message, inclusive: true, exact: false, maximum: r2.value, type: "date" }), t2.dirty()) : s.assertNever(r2);
      return { status: t2.value, value: new Date(e2.data.getTime()) };
    }
    _addCheck(e2) {
      return new _X(__spreadProps(__spreadValues({}, this._def), { checks: [...this._def.checks, e2] }));
    }
    min(e2, t2) {
      return this._addCheck({ kind: "min", value: e2.getTime(), message: b.toString(t2) });
    }
    max(e2, t2) {
      return this._addCheck({ kind: "max", value: e2.getTime(), message: b.toString(t2) });
    }
    get minDate() {
      let e2 = null;
      for (const t2 of this._def.checks) "min" === t2.kind && (null === e2 || t2.value > e2) && (e2 = t2.value);
      return null != e2 ? new Date(e2) : null;
    }
    get maxDate() {
      let e2 = null;
      for (const t2 of this._def.checks) "max" === t2.kind && (null === e2 || t2.value < e2) && (e2 = t2.value);
      return null != e2 ? new Date(e2) : null;
    }
  };
  X.create = (e2) => new X(__spreadValues({ checks: [], coerce: (e2 == null ? void 0 : e2.coerce) || false, typeName: je.ZodDate }, T(e2)));
  var ee = class extends A {
    _parse(e2) {
      if (this._getType(e2) !== o.symbol) {
        const t2 = this._getOrReturnCtx(e2);
        return p(t2, { code: c.invalid_type, expected: o.symbol, received: t2.parsedType }), g;
      }
      return y(e2.data);
    }
  };
  ee.create = (e2) => new ee(__spreadValues({ typeName: je.ZodSymbol }, T(e2)));
  var te = class extends A {
    _parse(e2) {
      if (this._getType(e2) !== o.undefined) {
        const t2 = this._getOrReturnCtx(e2);
        return p(t2, { code: c.invalid_type, expected: o.undefined, received: t2.parsedType }), g;
      }
      return y(e2.data);
    }
  };
  te.create = (e2) => new te(__spreadValues({ typeName: je.ZodUndefined }, T(e2)));
  var se = class extends A {
    _parse(e2) {
      if (this._getType(e2) !== o.null) {
        const t2 = this._getOrReturnCtx(e2);
        return p(t2, { code: c.invalid_type, expected: o.null, received: t2.parsedType }), g;
      }
      return y(e2.data);
    }
  };
  se.create = (e2) => new se(__spreadValues({ typeName: je.ZodNull }, T(e2)));
  var ae = class extends A {
    constructor() {
      super(...arguments), this._any = true;
    }
    _parse(e2) {
      return y(e2.data);
    }
  };
  ae.create = (e2) => new ae(__spreadValues({ typeName: je.ZodAny }, T(e2)));
  var re = class extends A {
    constructor() {
      super(...arguments), this._unknown = true;
    }
    _parse(e2) {
      return y(e2.data);
    }
  };
  re.create = (e2) => new re(__spreadValues({ typeName: je.ZodUnknown }, T(e2)));
  var ne = class extends A {
    _parse(e2) {
      const t2 = this._getOrReturnCtx(e2);
      return p(t2, { code: c.invalid_type, expected: o.never, received: t2.parsedType }), g;
    }
  };
  ne.create = (e2) => new ne(__spreadValues({ typeName: je.ZodNever }, T(e2)));
  var ie = class extends A {
    _parse(e2) {
      if (this._getType(e2) !== o.undefined) {
        const t2 = this._getOrReturnCtx(e2);
        return p(t2, { code: c.invalid_type, expected: o.void, received: t2.parsedType }), g;
      }
      return y(e2.data);
    }
  };
  ie.create = (e2) => new ie(__spreadValues({ typeName: je.ZodVoid }, T(e2)));
  var oe = class _oe extends A {
    _parse(e2) {
      const { ctx: t2, status: s2 } = this._processInputParams(e2), a2 = this._def;
      if (t2.parsedType !== o.array) return p(t2, { code: c.invalid_type, expected: o.array, received: t2.parsedType }), g;
      if (null !== a2.exactLength) {
        const e3 = t2.data.length > a2.exactLength.value, r3 = t2.data.length < a2.exactLength.value;
        (e3 || r3) && (p(t2, { code: e3 ? c.too_big : c.too_small, minimum: r3 ? a2.exactLength.value : void 0, maximum: e3 ? a2.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: a2.exactLength.message }), s2.dirty());
      }
      if (null !== a2.minLength && t2.data.length < a2.minLength.value && (p(t2, { code: c.too_small, minimum: a2.minLength.value, type: "array", inclusive: true, exact: false, message: a2.minLength.message }), s2.dirty()), null !== a2.maxLength && t2.data.length > a2.maxLength.value && (p(t2, { code: c.too_big, maximum: a2.maxLength.value, type: "array", inclusive: true, exact: false, message: a2.maxLength.message }), s2.dirty()), t2.common.async) return Promise.all([...t2.data].map((e3, s3) => a2.type._parseAsync(new w(t2, e3, t2.path, s3)))).then((e3) => m.mergeArray(s2, e3));
      const r2 = [...t2.data].map((e3, s3) => a2.type._parseSync(new w(t2, e3, t2.path, s3)));
      return m.mergeArray(s2, r2);
    }
    get element() {
      return this._def.type;
    }
    min(e2, t2) {
      return new _oe(__spreadProps(__spreadValues({}, this._def), { minLength: { value: e2, message: b.toString(t2) } }));
    }
    max(e2, t2) {
      return new _oe(__spreadProps(__spreadValues({}, this._def), { maxLength: { value: e2, message: b.toString(t2) } }));
    }
    length(e2, t2) {
      return new _oe(__spreadProps(__spreadValues({}, this._def), { exactLength: { value: e2, message: b.toString(t2) } }));
    }
    nonempty(e2) {
      return this.min(1, e2);
    }
  };
  function de(e2) {
    if (e2 instanceof ce) {
      const t2 = {};
      for (const s2 in e2.shape) {
        const a2 = e2.shape[s2];
        t2[s2] = Ae.create(de(a2));
      }
      return new ce(__spreadProps(__spreadValues({}, e2._def), { shape: () => t2 }));
    }
    return e2 instanceof oe ? new oe(__spreadProps(__spreadValues({}, e2._def), { type: de(e2.element) })) : e2 instanceof Ae ? Ae.create(de(e2.unwrap())) : e2 instanceof Ce ? Ce.create(de(e2.unwrap())) : e2 instanceof ge ? ge.create(e2.items.map((e3) => de(e3))) : e2;
  }
  oe.create = (e2, t2) => new oe(__spreadValues({ type: e2, minLength: null, maxLength: null, exactLength: null, typeName: je.ZodArray }, T(t2)));
  var ce = class _ce extends A {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (null !== this._cached) return this._cached;
      const e2 = this._def.shape(), t2 = s.objectKeys(e2);
      return this._cached = { shape: e2, keys: t2 }, this._cached;
    }
    _parse(e2) {
      if (this._getType(e2) !== o.object) {
        const t3 = this._getOrReturnCtx(e2);
        return p(t3, { code: c.invalid_type, expected: o.object, received: t3.parsedType }), g;
      }
      const { status: t2, ctx: s2 } = this._processInputParams(e2), { shape: a2, keys: r2 } = this._getCached(), n2 = [];
      if (!(this._def.catchall instanceof ne && "strip" === this._def.unknownKeys)) for (const e3 in s2.data) r2.includes(e3) || n2.push(e3);
      const i2 = [];
      for (const e3 of r2) {
        const t3 = a2[e3], r3 = s2.data[e3];
        i2.push({ key: { status: "valid", value: e3 }, value: t3._parse(new w(s2, r3, s2.path, e3)), alwaysSet: e3 in s2.data });
      }
      if (this._def.catchall instanceof ne) {
        const e3 = this._def.unknownKeys;
        if ("passthrough" === e3) for (const e4 of n2) i2.push({ key: { status: "valid", value: e4 }, value: { status: "valid", value: s2.data[e4] } });
        else if ("strict" === e3) n2.length > 0 && (p(s2, { code: c.unrecognized_keys, keys: n2 }), t2.dirty());
        else if ("strip" !== e3) throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const e3 = this._def.catchall;
        for (const t3 of n2) {
          const a3 = s2.data[t3];
          i2.push({ key: { status: "valid", value: t3 }, value: e3._parse(new w(s2, a3, s2.path, t3)), alwaysSet: t3 in s2.data });
        }
      }
      return s2.common.async ? Promise.resolve().then(() => __async(this, null, function* () {
        const e3 = [];
        for (const t3 of i2) {
          const s3 = yield t3.key, a3 = yield t3.value;
          e3.push({ key: s3, value: a3, alwaysSet: t3.alwaysSet });
        }
        return e3;
      })).then((e3) => m.mergeObjectSync(t2, e3)) : m.mergeObjectSync(t2, i2);
    }
    get shape() {
      return this._def.shape();
    }
    strict(e2) {
      return b.errToObj, new _ce(__spreadValues(__spreadProps(__spreadValues({}, this._def), { unknownKeys: "strict" }), void 0 !== e2 ? { errorMap: (t2, s2) => {
        var _a, _b, _c, _d;
        const a2 = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, t2, s2).message) != null ? _c : s2.defaultError;
        return "unrecognized_keys" === t2.code ? { message: (_d = b.errToObj(e2).message) != null ? _d : a2 } : { message: a2 };
      } } : {}));
    }
    strip() {
      return new _ce(__spreadProps(__spreadValues({}, this._def), { unknownKeys: "strip" }));
    }
    passthrough() {
      return new _ce(__spreadProps(__spreadValues({}, this._def), { unknownKeys: "passthrough" }));
    }
    extend(e2) {
      return new _ce(__spreadProps(__spreadValues({}, this._def), { shape: () => __spreadValues(__spreadValues({}, this._def.shape()), e2) }));
    }
    merge(e2) {
      return new _ce({ unknownKeys: e2._def.unknownKeys, catchall: e2._def.catchall, shape: () => __spreadValues(__spreadValues({}, this._def.shape()), e2._def.shape()), typeName: je.ZodObject });
    }
    setKey(e2, t2) {
      return this.augment({ [e2]: t2 });
    }
    catchall(e2) {
      return new _ce(__spreadProps(__spreadValues({}, this._def), { catchall: e2 }));
    }
    pick(e2) {
      const t2 = {};
      for (const a2 of s.objectKeys(e2)) e2[a2] && this.shape[a2] && (t2[a2] = this.shape[a2]);
      return new _ce(__spreadProps(__spreadValues({}, this._def), { shape: () => t2 }));
    }
    omit(e2) {
      const t2 = {};
      for (const a2 of s.objectKeys(this.shape)) e2[a2] || (t2[a2] = this.shape[a2]);
      return new _ce(__spreadProps(__spreadValues({}, this._def), { shape: () => t2 }));
    }
    deepPartial() {
      return de(this);
    }
    partial(e2) {
      const t2 = {};
      for (const a2 of s.objectKeys(this.shape)) {
        const s2 = this.shape[a2];
        e2 && !e2[a2] ? t2[a2] = s2 : t2[a2] = s2.optional();
      }
      return new _ce(__spreadProps(__spreadValues({}, this._def), { shape: () => t2 }));
    }
    required(e2) {
      const t2 = {};
      for (const a2 of s.objectKeys(this.shape)) if (e2 && !e2[a2]) t2[a2] = this.shape[a2];
      else {
        let e3 = this.shape[a2];
        for (; e3 instanceof Ae; ) e3 = e3._def.innerType;
        t2[a2] = e3;
      }
      return new _ce(__spreadProps(__spreadValues({}, this._def), { shape: () => t2 }));
    }
    keyof() {
      return ke(s.objectKeys(this.shape));
    }
  };
  ce.create = (e2, t2) => new ce(__spreadValues({ shape: () => e2, unknownKeys: "strip", catchall: ne.create(), typeName: je.ZodObject }, T(t2))), ce.strictCreate = (e2, t2) => new ce(__spreadValues({ shape: () => e2, unknownKeys: "strict", catchall: ne.create(), typeName: je.ZodObject }, T(t2))), ce.lazycreate = (e2, t2) => new ce(__spreadValues({ shape: e2, unknownKeys: "strip", catchall: ne.create(), typeName: je.ZodObject }, T(t2)));
  var ue = class extends A {
    _parse(e2) {
      const { ctx: t2 } = this._processInputParams(e2), s2 = this._def.options;
      if (t2.common.async) return Promise.all(s2.map((e3) => __async(this, null, function* () {
        const s3 = __spreadProps(__spreadValues({}, t2), { common: __spreadProps(__spreadValues({}, t2.common), { issues: [] }), parent: null });
        return { result: yield e3._parseAsync({ data: t2.data, path: t2.path, parent: s3 }), ctx: s3 };
      }))).then(function(e3) {
        for (const t3 of e3) if ("valid" === t3.result.status) return t3.result;
        for (const s4 of e3) if ("dirty" === s4.result.status) return t2.common.issues.push(...s4.ctx.common.issues), s4.result;
        const s3 = e3.map((e4) => new u(e4.ctx.common.issues));
        return p(t2, { code: c.invalid_union, unionErrors: s3 }), g;
      });
      {
        let e3;
        const a2 = [];
        for (const r3 of s2) {
          const s3 = __spreadProps(__spreadValues({}, t2), { common: __spreadProps(__spreadValues({}, t2.common), { issues: [] }), parent: null }), n2 = r3._parseSync({ data: t2.data, path: t2.path, parent: s3 });
          if ("valid" === n2.status) return n2;
          "dirty" !== n2.status || e3 || (e3 = { result: n2, ctx: s3 }), s3.common.issues.length && a2.push(s3.common.issues);
        }
        if (e3) return t2.common.issues.push(...e3.ctx.common.issues), e3.result;
        const r2 = a2.map((e4) => new u(e4));
        return p(t2, { code: c.invalid_union, unionErrors: r2 }), g;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ue.create = (e2, t2) => new ue(__spreadValues({ options: e2, typeName: je.ZodUnion }, T(t2)));
  var le = (e2) => e2 instanceof ve ? le(e2.schema) : e2 instanceof Te ? le(e2.innerType()) : e2 instanceof xe ? [e2.value] : e2 instanceof be ? e2.options : e2 instanceof we ? s.objectValues(e2.enum) : e2 instanceof Re ? le(e2._def.innerType) : e2 instanceof te ? [void 0] : e2 instanceof se ? [null] : e2 instanceof Ae ? [void 0, ...le(e2.unwrap())] : e2 instanceof Ce ? [null, ...le(e2.unwrap())] : e2 instanceof Ie || e2 instanceof Ne ? le(e2.unwrap()) : e2 instanceof Ze ? le(e2._def.innerType) : [];
  var he = class _he extends A {
    _parse(e2) {
      const { ctx: t2 } = this._processInputParams(e2);
      if (t2.parsedType !== o.object) return p(t2, { code: c.invalid_type, expected: o.object, received: t2.parsedType }), g;
      const s2 = this.discriminator, a2 = t2.data[s2], r2 = this.optionsMap.get(a2);
      return r2 ? t2.common.async ? r2._parseAsync({ data: t2.data, path: t2.path, parent: t2 }) : r2._parseSync({ data: t2.data, path: t2.path, parent: t2 }) : (p(t2, { code: c.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [s2] }), g);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(e2, t2, s2) {
      const a2 = /* @__PURE__ */ new Map();
      for (const s3 of t2) {
        const t3 = le(s3.shape[e2]);
        if (!t3.length) throw new Error(`A discriminator value for key \`${e2}\` could not be extracted from all schema options`);
        for (const r2 of t3) {
          if (a2.has(r2)) throw new Error(`Discriminator property ${String(e2)} has duplicate value ${String(r2)}`);
          a2.set(r2, s3);
        }
      }
      return new _he(__spreadValues({ typeName: je.ZodDiscriminatedUnion, discriminator: e2, options: t2, optionsMap: a2 }, T(s2)));
    }
  };
  function pe(e2, t2) {
    const a2 = d(e2), r2 = d(t2);
    if (e2 === t2) return { valid: true, data: e2 };
    if (a2 === o.object && r2 === o.object) {
      const a3 = s.objectKeys(t2), r3 = s.objectKeys(e2).filter((e3) => -1 !== a3.indexOf(e3)), n2 = __spreadValues(__spreadValues({}, e2), t2);
      for (const s2 of r3) {
        const a4 = pe(e2[s2], t2[s2]);
        if (!a4.valid) return { valid: false };
        n2[s2] = a4.data;
      }
      return { valid: true, data: n2 };
    }
    if (a2 === o.array && r2 === o.array) {
      if (e2.length !== t2.length) return { valid: false };
      const s2 = [];
      for (let a3 = 0; a3 < e2.length; a3++) {
        const r3 = pe(e2[a3], t2[a3]);
        if (!r3.valid) return { valid: false };
        s2.push(r3.data);
      }
      return { valid: true, data: s2 };
    }
    return a2 === o.date && r2 === o.date && +e2 === +t2 ? { valid: true, data: e2 } : { valid: false };
  }
  var me = class extends A {
    _parse(e2) {
      const { status: t2, ctx: s2 } = this._processInputParams(e2), a2 = (e3, a3) => {
        if (_(e3) || _(a3)) return g;
        const r2 = pe(e3.value, a3.value);
        return r2.valid ? ((v(e3) || v(a3)) && t2.dirty(), { status: t2.value, value: r2.data }) : (p(s2, { code: c.invalid_intersection_types }), g);
      };
      return s2.common.async ? Promise.all([this._def.left._parseAsync({ data: s2.data, path: s2.path, parent: s2 }), this._def.right._parseAsync({ data: s2.data, path: s2.path, parent: s2 })]).then(([e3, t3]) => a2(e3, t3)) : a2(this._def.left._parseSync({ data: s2.data, path: s2.path, parent: s2 }), this._def.right._parseSync({ data: s2.data, path: s2.path, parent: s2 }));
    }
  };
  me.create = (e2, t2, s2) => new me(__spreadValues({ left: e2, right: t2, typeName: je.ZodIntersection }, T(s2)));
  var ge = class _ge extends A {
    _parse(e2) {
      const { status: t2, ctx: s2 } = this._processInputParams(e2);
      if (s2.parsedType !== o.array) return p(s2, { code: c.invalid_type, expected: o.array, received: s2.parsedType }), g;
      if (s2.data.length < this._def.items.length) return p(s2, { code: c.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), g;
      !this._def.rest && s2.data.length > this._def.items.length && (p(s2, { code: c.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t2.dirty());
      const a2 = [...s2.data].map((e3, t3) => {
        const a3 = this._def.items[t3] || this._def.rest;
        return a3 ? a3._parse(new w(s2, e3, s2.path, t3)) : null;
      }).filter((e3) => !!e3);
      return s2.common.async ? Promise.all(a2).then((e3) => m.mergeArray(t2, e3)) : m.mergeArray(t2, a2);
    }
    get items() {
      return this._def.items;
    }
    rest(e2) {
      return new _ge(__spreadProps(__spreadValues({}, this._def), { rest: e2 }));
    }
  };
  ge.create = (e2, t2) => {
    if (!Array.isArray(e2)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new ge(__spreadValues({ items: e2, typeName: je.ZodTuple, rest: null }, T(t2)));
  };
  var fe = class _fe extends A {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e2) {
      const { status: t2, ctx: s2 } = this._processInputParams(e2);
      if (s2.parsedType !== o.object) return p(s2, { code: c.invalid_type, expected: o.object, received: s2.parsedType }), g;
      const a2 = [], r2 = this._def.keyType, n2 = this._def.valueType;
      for (const e3 in s2.data) a2.push({ key: r2._parse(new w(s2, e3, s2.path, e3)), value: n2._parse(new w(s2, s2.data[e3], s2.path, e3)), alwaysSet: e3 in s2.data });
      return s2.common.async ? m.mergeObjectAsync(t2, a2) : m.mergeObjectSync(t2, a2);
    }
    get element() {
      return this._def.valueType;
    }
    static create(e2, t2, s2) {
      return new _fe(t2 instanceof A ? __spreadValues({ keyType: e2, valueType: t2, typeName: je.ZodRecord }, T(s2)) : __spreadValues({ keyType: W.create(), valueType: e2, typeName: je.ZodRecord }, T(t2)));
    }
  };
  var ye = class extends A {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e2) {
      const { status: t2, ctx: s2 } = this._processInputParams(e2);
      if (s2.parsedType !== o.map) return p(s2, { code: c.invalid_type, expected: o.map, received: s2.parsedType }), g;
      const a2 = this._def.keyType, r2 = this._def.valueType, n2 = [...s2.data.entries()].map(([e3, t3], n3) => ({ key: a2._parse(new w(s2, e3, s2.path, [n3, "key"])), value: r2._parse(new w(s2, t3, s2.path, [n3, "value"])) }));
      if (s2.common.async) {
        const e3 = /* @__PURE__ */ new Map();
        return Promise.resolve().then(() => __async(this, null, function* () {
          for (const s3 of n2) {
            const a3 = yield s3.key, r3 = yield s3.value;
            if ("aborted" === a3.status || "aborted" === r3.status) return g;
            "dirty" !== a3.status && "dirty" !== r3.status || t2.dirty(), e3.set(a3.value, r3.value);
          }
          return { status: t2.value, value: e3 };
        }));
      }
      {
        const e3 = /* @__PURE__ */ new Map();
        for (const s3 of n2) {
          const a3 = s3.key, r3 = s3.value;
          if ("aborted" === a3.status || "aborted" === r3.status) return g;
          "dirty" !== a3.status && "dirty" !== r3.status || t2.dirty(), e3.set(a3.value, r3.value);
        }
        return { status: t2.value, value: e3 };
      }
    }
  };
  ye.create = (e2, t2, s2) => new ye(__spreadValues({ valueType: t2, keyType: e2, typeName: je.ZodMap }, T(s2)));
  var _e = class __e extends A {
    _parse(e2) {
      const { status: t2, ctx: s2 } = this._processInputParams(e2);
      if (s2.parsedType !== o.set) return p(s2, { code: c.invalid_type, expected: o.set, received: s2.parsedType }), g;
      const a2 = this._def;
      null !== a2.minSize && s2.data.size < a2.minSize.value && (p(s2, { code: c.too_small, minimum: a2.minSize.value, type: "set", inclusive: true, exact: false, message: a2.minSize.message }), t2.dirty()), null !== a2.maxSize && s2.data.size > a2.maxSize.value && (p(s2, { code: c.too_big, maximum: a2.maxSize.value, type: "set", inclusive: true, exact: false, message: a2.maxSize.message }), t2.dirty());
      const r2 = this._def.valueType;
      function n2(e3) {
        const s3 = /* @__PURE__ */ new Set();
        for (const a3 of e3) {
          if ("aborted" === a3.status) return g;
          "dirty" === a3.status && t2.dirty(), s3.add(a3.value);
        }
        return { status: t2.value, value: s3 };
      }
      const i2 = [...s2.data.values()].map((e3, t3) => r2._parse(new w(s2, e3, s2.path, t3)));
      return s2.common.async ? Promise.all(i2).then((e3) => n2(e3)) : n2(i2);
    }
    min(e2, t2) {
      return new __e(__spreadProps(__spreadValues({}, this._def), { minSize: { value: e2, message: b.toString(t2) } }));
    }
    max(e2, t2) {
      return new __e(__spreadProps(__spreadValues({}, this._def), { maxSize: { value: e2, message: b.toString(t2) } }));
    }
    size(e2, t2) {
      return this.min(e2, t2).max(e2, t2);
    }
    nonempty(e2) {
      return this.min(1, e2);
    }
  };
  _e.create = (e2, t2) => new _e(__spreadValues({ valueType: e2, minSize: null, maxSize: null, typeName: je.ZodSet }, T(t2)));
  var ve = class extends A {
    get schema() {
      return this._def.getter();
    }
    _parse(e2) {
      const { ctx: t2 } = this._processInputParams(e2);
      return this._def.getter()._parse({ data: t2.data, path: t2.path, parent: t2 });
    }
  };
  ve.create = (e2, t2) => new ve(__spreadValues({ getter: e2, typeName: je.ZodLazy }, T(t2)));
  var xe = class extends A {
    _parse(e2) {
      if (e2.data !== this._def.value) {
        const t2 = this._getOrReturnCtx(e2);
        return p(t2, { received: t2.data, code: c.invalid_literal, expected: this._def.value }), g;
      }
      return { status: "valid", value: e2.data };
    }
    get value() {
      return this._def.value;
    }
  };
  function ke(e2, t2) {
    return new be(__spreadValues({ values: e2, typeName: je.ZodEnum }, T(t2)));
  }
  xe.create = (e2, t2) => new xe(__spreadValues({ value: e2, typeName: je.ZodLiteral }, T(t2)));
  var be = class _be extends A {
    _parse(e2) {
      if ("string" != typeof e2.data) {
        const t2 = this._getOrReturnCtx(e2), a2 = this._def.values;
        return p(t2, { expected: s.joinValues(a2), received: t2.parsedType, code: c.invalid_type }), g;
      }
      if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e2.data)) {
        const t2 = this._getOrReturnCtx(e2), s2 = this._def.values;
        return p(t2, { received: t2.data, code: c.invalid_enum_value, options: s2 }), g;
      }
      return y(e2.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const e2 = {};
      for (const t2 of this._def.values) e2[t2] = t2;
      return e2;
    }
    get Values() {
      const e2 = {};
      for (const t2 of this._def.values) e2[t2] = t2;
      return e2;
    }
    get Enum() {
      const e2 = {};
      for (const t2 of this._def.values) e2[t2] = t2;
      return e2;
    }
    extract(e2, t2 = this._def) {
      return _be.create(e2, __spreadValues(__spreadValues({}, this._def), t2));
    }
    exclude(e2, t2 = this._def) {
      return _be.create(this.options.filter((t3) => !e2.includes(t3)), __spreadValues(__spreadValues({}, this._def), t2));
    }
  };
  be.create = ke;
  var we = class extends A {
    _parse(e2) {
      const t2 = s.getValidEnumValues(this._def.values), a2 = this._getOrReturnCtx(e2);
      if (a2.parsedType !== o.string && a2.parsedType !== o.number) {
        const e3 = s.objectValues(t2);
        return p(a2, { expected: s.joinValues(e3), received: a2.parsedType, code: c.invalid_type }), g;
      }
      if (this._cache || (this._cache = new Set(s.getValidEnumValues(this._def.values))), !this._cache.has(e2.data)) {
        const e3 = s.objectValues(t2);
        return p(a2, { received: a2.data, code: c.invalid_enum_value, options: e3 }), g;
      }
      return y(e2.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  we.create = (e2, t2) => new we(__spreadValues({ values: e2, typeName: je.ZodNativeEnum }, T(t2)));
  var Se = class extends A {
    unwrap() {
      return this._def.type;
    }
    _parse(e2) {
      const { ctx: t2 } = this._processInputParams(e2);
      if (t2.parsedType !== o.promise && false === t2.common.async) return p(t2, { code: c.invalid_type, expected: o.promise, received: t2.parsedType }), g;
      const s2 = t2.parsedType === o.promise ? t2.data : Promise.resolve(t2.data);
      return y(s2.then((e3) => this._def.type.parseAsync(e3, { path: t2.path, errorMap: t2.common.contextualErrorMap })));
    }
  };
  Se.create = (e2, t2) => new Se(__spreadValues({ type: e2, typeName: je.ZodPromise }, T(t2)));
  var Te = class extends A {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === je.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(e2) {
      const { status: t2, ctx: a2 } = this._processInputParams(e2), r2 = this._def.effect || null, n2 = { addIssue: (e3) => {
        p(a2, e3), e3.fatal ? t2.abort() : t2.dirty();
      }, get path() {
        return a2.path;
      } };
      if (n2.addIssue = n2.addIssue.bind(n2), "preprocess" === r2.type) {
        const e3 = r2.transform(a2.data, n2);
        if (a2.common.async) return Promise.resolve(e3).then((e4) => __async(this, null, function* () {
          if ("aborted" === t2.value) return g;
          const s2 = yield this._def.schema._parseAsync({ data: e4, path: a2.path, parent: a2 });
          return "aborted" === s2.status ? g : "dirty" === s2.status || "dirty" === t2.value ? f(s2.value) : s2;
        }));
        {
          if ("aborted" === t2.value) return g;
          const s2 = this._def.schema._parseSync({ data: e3, path: a2.path, parent: a2 });
          return "aborted" === s2.status ? g : "dirty" === s2.status || "dirty" === t2.value ? f(s2.value) : s2;
        }
      }
      if ("refinement" === r2.type) {
        const e3 = (e4) => {
          const t3 = r2.refinement(e4, n2);
          if (a2.common.async) return Promise.resolve(t3);
          if (t3 instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return e4;
        };
        if (false === a2.common.async) {
          const s2 = this._def.schema._parseSync({ data: a2.data, path: a2.path, parent: a2 });
          return "aborted" === s2.status ? g : ("dirty" === s2.status && t2.dirty(), e3(s2.value), { status: t2.value, value: s2.value });
        }
        return this._def.schema._parseAsync({ data: a2.data, path: a2.path, parent: a2 }).then((s2) => "aborted" === s2.status ? g : ("dirty" === s2.status && t2.dirty(), e3(s2.value).then(() => ({ status: t2.value, value: s2.value }))));
      }
      if ("transform" === r2.type) {
        if (false === a2.common.async) {
          const e3 = this._def.schema._parseSync({ data: a2.data, path: a2.path, parent: a2 });
          if (!x(e3)) return g;
          const s2 = r2.transform(e3.value, n2);
          if (s2 instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: t2.value, value: s2 };
        }
        return this._def.schema._parseAsync({ data: a2.data, path: a2.path, parent: a2 }).then((e3) => x(e3) ? Promise.resolve(r2.transform(e3.value, n2)).then((e4) => ({ status: t2.value, value: e4 })) : g);
      }
      s.assertNever(r2);
    }
  };
  Te.create = (e2, t2, s2) => new Te(__spreadValues({ schema: e2, typeName: je.ZodEffects, effect: t2 }, T(s2))), Te.createWithPreprocess = (e2, t2, s2) => new Te(__spreadValues({ schema: t2, effect: { type: "preprocess", transform: e2 }, typeName: je.ZodEffects }, T(s2)));
  var Ae = class extends A {
    _parse(e2) {
      return this._getType(e2) === o.undefined ? y(void 0) : this._def.innerType._parse(e2);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  Ae.create = (e2, t2) => new Ae(__spreadValues({ innerType: e2, typeName: je.ZodOptional }, T(t2)));
  var Ce = class extends A {
    _parse(e2) {
      return this._getType(e2) === o.null ? y(null) : this._def.innerType._parse(e2);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  Ce.create = (e2, t2) => new Ce(__spreadValues({ innerType: e2, typeName: je.ZodNullable }, T(t2)));
  var Re = class extends A {
    _parse(e2) {
      const { ctx: t2 } = this._processInputParams(e2);
      let s2 = t2.data;
      return t2.parsedType === o.undefined && (s2 = this._def.defaultValue()), this._def.innerType._parse({ data: s2, path: t2.path, parent: t2 });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  Re.create = (e2, t2) => new Re(__spreadValues({ innerType: e2, typeName: je.ZodDefault, defaultValue: "function" == typeof t2.default ? t2.default : () => t2.default }, T(t2)));
  var Ze = class extends A {
    _parse(e2) {
      const { ctx: t2 } = this._processInputParams(e2), s2 = __spreadProps(__spreadValues({}, t2), { common: __spreadProps(__spreadValues({}, t2.common), { issues: [] }) }), a2 = this._def.innerType._parse({ data: s2.data, path: s2.path, parent: __spreadValues({}, s2) });
      return k(a2) ? a2.then((e3) => ({ status: "valid", value: "valid" === e3.status ? e3.value : this._def.catchValue({ get error() {
        return new u(s2.common.issues);
      }, input: s2.data }) })) : { status: "valid", value: "valid" === a2.status ? a2.value : this._def.catchValue({ get error() {
        return new u(s2.common.issues);
      }, input: s2.data }) };
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  Ze.create = (e2, t2) => new Ze(__spreadValues({ innerType: e2, typeName: je.ZodCatch, catchValue: "function" == typeof t2.catch ? t2.catch : () => t2.catch }, T(t2)));
  var Oe = class extends A {
    _parse(e2) {
      if (this._getType(e2) !== o.nan) {
        const t2 = this._getOrReturnCtx(e2);
        return p(t2, { code: c.invalid_type, expected: o.nan, received: t2.parsedType }), g;
      }
      return { status: "valid", value: e2.data };
    }
  };
  Oe.create = (e2) => new Oe(__spreadValues({ typeName: je.ZodNaN }, T(e2))), Symbol("zod_brand");
  var Ie = class extends A {
    _parse(e2) {
      const { ctx: t2 } = this._processInputParams(e2), s2 = t2.data;
      return this._def.type._parse({ data: s2, path: t2.path, parent: t2 });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var Ee = class _Ee extends A {
    _parse(e2) {
      const { status: t2, ctx: s2 } = this._processInputParams(e2);
      if (s2.common.async) return (() => __async(this, null, function* () {
        const e3 = yield this._def.in._parseAsync({ data: s2.data, path: s2.path, parent: s2 });
        return "aborted" === e3.status ? g : "dirty" === e3.status ? (t2.dirty(), f(e3.value)) : this._def.out._parseAsync({ data: e3.value, path: s2.path, parent: s2 });
      }))();
      {
        const e3 = this._def.in._parseSync({ data: s2.data, path: s2.path, parent: s2 });
        return "aborted" === e3.status ? g : "dirty" === e3.status ? (t2.dirty(), { status: "dirty", value: e3.value }) : this._def.out._parseSync({ data: e3.value, path: s2.path, parent: s2 });
      }
    }
    static create(e2, t2) {
      return new _Ee({ in: e2, out: t2, typeName: je.ZodPipeline });
    }
  };
  var Ne = class extends A {
    _parse(e2) {
      const t2 = this._def.innerType._parse(e2), s2 = (e3) => (x(e3) && (e3.value = Object.freeze(e3.value)), e3);
      return k(t2) ? t2.then((e3) => s2(e3)) : s2(t2);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  var je;
  Ne.create = (e2, t2) => new Ne(__spreadValues({ innerType: e2, typeName: je.ZodReadonly }, T(t2))), ce.lazycreate, function(e2) {
    e2.ZodString = "ZodString", e2.ZodNumber = "ZodNumber", e2.ZodNaN = "ZodNaN", e2.ZodBigInt = "ZodBigInt", e2.ZodBoolean = "ZodBoolean", e2.ZodDate = "ZodDate", e2.ZodSymbol = "ZodSymbol", e2.ZodUndefined = "ZodUndefined", e2.ZodNull = "ZodNull", e2.ZodAny = "ZodAny", e2.ZodUnknown = "ZodUnknown", e2.ZodNever = "ZodNever", e2.ZodVoid = "ZodVoid", e2.ZodArray = "ZodArray", e2.ZodObject = "ZodObject", e2.ZodUnion = "ZodUnion", e2.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e2.ZodIntersection = "ZodIntersection", e2.ZodTuple = "ZodTuple", e2.ZodRecord = "ZodRecord", e2.ZodMap = "ZodMap", e2.ZodSet = "ZodSet", e2.ZodFunction = "ZodFunction", e2.ZodLazy = "ZodLazy", e2.ZodLiteral = "ZodLiteral", e2.ZodEnum = "ZodEnum", e2.ZodEffects = "ZodEffects", e2.ZodNativeEnum = "ZodNativeEnum", e2.ZodOptional = "ZodOptional", e2.ZodNullable = "ZodNullable", e2.ZodDefault = "ZodDefault", e2.ZodCatch = "ZodCatch", e2.ZodPromise = "ZodPromise", e2.ZodBranded = "ZodBranded", e2.ZodPipeline = "ZodPipeline", e2.ZodReadonly = "ZodReadonly";
  }(je || (je = {}));
  var Pe = W.create;
  var $e = G.create;
  var Me = (Oe.create, J.create, Y.create);
  var De = (X.create, ee.create, te.create, se.create, ae.create, re.create);
  var Fe = (ne.create, ie.create, oe.create);
  var qe = ce.create;
  var ze = (ce.strictCreate, ue.create);
  var Le = he.create;
  var Ve = (me.create, ge.create, fe.create);
  var Ue = (ye.create, _e.create, ve.create, xe.create);
  var Ke = be.create;
  var Qe = (we.create, Se.create, Te.create, Ae.create);
  var Be = (Ce.create, Te.createWithPreprocess, Ee.create, "2.0");
  var We = ze([Pe(), $e().int()]);
  var He = Pe();
  var Ge = qe({ progressToken: Qe(We) }).passthrough();
  var Je = qe({ _meta: Qe(Ge) }).passthrough();
  var Ye = qe({ method: Pe(), params: Qe(Je) });
  var Xe = qe({ _meta: Qe(qe({}).passthrough()) }).passthrough();
  var et = qe({ method: Pe(), params: Qe(Xe) });
  var tt = qe({ _meta: Qe(qe({}).passthrough()) }).passthrough();
  var st = ze([Pe(), $e().int()]);
  var at = qe({ jsonrpc: Ue(Be), id: st }).merge(Ye).strict();
  var rt = qe({ jsonrpc: Ue(Be) }).merge(et).strict();
  var nt = qe({ jsonrpc: Ue(Be), id: st, result: tt }).strict();
  var it;
  !function(e2) {
    e2[e2.ConnectionClosed = -32e3] = "ConnectionClosed", e2[e2.RequestTimeout = -32001] = "RequestTimeout", e2[e2.ParseError = -32700] = "ParseError", e2[e2.InvalidRequest = -32600] = "InvalidRequest", e2[e2.MethodNotFound = -32601] = "MethodNotFound", e2[e2.InvalidParams = -32602] = "InvalidParams", e2[e2.InternalError = -32603] = "InternalError";
  }(it || (it = {}));
  var ot = ze([at, rt, nt, qe({ jsonrpc: Ue(Be), id: st, error: qe({ code: $e().int(), message: Pe(), data: Qe(De()) }) }).strict()]);
  var dt = tt.strict();
  var ct = et.extend({ method: Ue("notifications/cancelled"), params: Xe.extend({ requestId: st, reason: Pe().optional() }) });
  var ut = qe({ name: Pe(), title: Qe(Pe()) }).passthrough();
  var lt = ut.extend({ version: Pe() });
  var ht = qe({ experimental: Qe(qe({}).passthrough()), sampling: Qe(qe({}).passthrough()), elicitation: Qe(qe({}).passthrough()), roots: Qe(qe({ listChanged: Qe(Me()) }).passthrough()) }).passthrough();
  var pt = Ye.extend({ method: Ue("initialize"), params: Je.extend({ protocolVersion: Pe(), capabilities: ht, clientInfo: lt }) });
  var mt = qe({ experimental: Qe(qe({}).passthrough()), logging: Qe(qe({}).passthrough()), completions: Qe(qe({}).passthrough()), prompts: Qe(qe({ listChanged: Qe(Me()) }).passthrough()), resources: Qe(qe({ subscribe: Qe(Me()), listChanged: Qe(Me()) }).passthrough()), tools: Qe(qe({ listChanged: Qe(Me()) }).passthrough()) }).passthrough();
  var gt = tt.extend({ protocolVersion: Pe(), capabilities: mt, serverInfo: lt, instructions: Qe(Pe()) });
  var ft = et.extend({ method: Ue("notifications/initialized") });
  var yt = Ye.extend({ method: Ue("ping") });
  var _t = qe({ progress: $e(), total: Qe($e()), message: Qe(Pe()) }).passthrough();
  var vt = et.extend({ method: Ue("notifications/progress"), params: Xe.merge(_t).extend({ progressToken: We }) });
  var xt = Ye.extend({ params: Je.extend({ cursor: Qe(He) }).optional() });
  var kt = tt.extend({ nextCursor: Qe(He) });
  var bt = qe({ uri: Pe(), mimeType: Qe(Pe()), _meta: Qe(qe({}).passthrough()) }).passthrough();
  var wt = bt.extend({ text: Pe() });
  var St = bt.extend({ blob: Pe().base64() });
  var Tt = ut.extend({ uri: Pe(), description: Qe(Pe()), mimeType: Qe(Pe()), _meta: Qe(qe({}).passthrough()) });
  var At = ut.extend({ uriTemplate: Pe(), description: Qe(Pe()), mimeType: Qe(Pe()), _meta: Qe(qe({}).passthrough()) });
  var Ct = xt.extend({ method: Ue("resources/list") });
  var Rt = kt.extend({ resources: Fe(Tt) });
  var Zt = xt.extend({ method: Ue("resources/templates/list") });
  var Ot = kt.extend({ resourceTemplates: Fe(At) });
  var It = Ye.extend({ method: Ue("resources/read"), params: Je.extend({ uri: Pe() }) });
  var Et = tt.extend({ contents: Fe(ze([wt, St])) });
  var Nt = et.extend({ method: Ue("notifications/resources/list_changed") });
  var jt = Ye.extend({ method: Ue("resources/subscribe"), params: Je.extend({ uri: Pe() }) });
  var Pt = Ye.extend({ method: Ue("resources/unsubscribe"), params: Je.extend({ uri: Pe() }) });
  var $t = et.extend({ method: Ue("notifications/resources/updated"), params: Xe.extend({ uri: Pe() }) });
  var Mt = qe({ name: Pe(), description: Qe(Pe()), required: Qe(Me()) }).passthrough();
  var Dt = ut.extend({ description: Qe(Pe()), arguments: Qe(Fe(Mt)), _meta: Qe(qe({}).passthrough()) });
  var Ft = xt.extend({ method: Ue("prompts/list") });
  var qt = kt.extend({ prompts: Fe(Dt) });
  var zt = Ye.extend({ method: Ue("prompts/get"), params: Je.extend({ name: Pe(), arguments: Qe(Ve(Pe())) }) });
  var Lt = qe({ type: Ue("text"), text: Pe(), _meta: Qe(qe({}).passthrough()) }).passthrough();
  var Vt = qe({ type: Ue("image"), data: Pe().base64(), mimeType: Pe(), _meta: Qe(qe({}).passthrough()) }).passthrough();
  var Ut = qe({ type: Ue("audio"), data: Pe().base64(), mimeType: Pe(), _meta: Qe(qe({}).passthrough()) }).passthrough();
  var Kt = qe({ type: Ue("resource"), resource: ze([wt, St]), _meta: Qe(qe({}).passthrough()) }).passthrough();
  var Qt = ze([Lt, Vt, Ut, Tt.extend({ type: Ue("resource_link") }), Kt]);
  var Bt = qe({ role: Ke(["user", "assistant"]), content: Qt }).passthrough();
  var Wt = tt.extend({ description: Qe(Pe()), messages: Fe(Bt) });
  var Ht = et.extend({ method: Ue("notifications/prompts/list_changed") });
  var Gt = qe({ title: Qe(Pe()), readOnlyHint: Qe(Me()), destructiveHint: Qe(Me()), idempotentHint: Qe(Me()), openWorldHint: Qe(Me()) }).passthrough();
  var Jt = ut.extend({ description: Qe(Pe()), inputSchema: qe({ type: Ue("object"), properties: Qe(qe({}).passthrough()), required: Qe(Fe(Pe())) }).passthrough(), outputSchema: Qe(qe({ type: Ue("object"), properties: Qe(qe({}).passthrough()), required: Qe(Fe(Pe())) }).passthrough()), annotations: Qe(Gt), _meta: Qe(qe({}).passthrough()) });
  var Yt = xt.extend({ method: Ue("tools/list") });
  var Xt = kt.extend({ tools: Fe(Jt) });
  var es = tt.extend({ content: Fe(Qt).default([]), structuredContent: qe({}).passthrough().optional(), isError: Qe(Me()) });
  var ts = (es.or(tt.extend({ toolResult: De() })), Ye.extend({ method: Ue("tools/call"), params: Je.extend({ name: Pe(), arguments: Qe(Ve(De())) }) }));
  var ss = et.extend({ method: Ue("notifications/tools/list_changed") });
  var as = Ke(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
  var rs = Ye.extend({ method: Ue("logging/setLevel"), params: Je.extend({ level: as }) });
  var ns = et.extend({ method: Ue("notifications/message"), params: Xe.extend({ level: as, logger: Qe(Pe()), data: De() }) });
  var is = qe({ name: Pe().optional() }).passthrough();
  var os = qe({ hints: Qe(Fe(is)), costPriority: Qe($e().min(0).max(1)), speedPriority: Qe($e().min(0).max(1)), intelligencePriority: Qe($e().min(0).max(1)) }).passthrough();
  var ds = qe({ role: Ke(["user", "assistant"]), content: ze([Lt, Vt, Ut]) }).passthrough();
  var cs = Ye.extend({ method: Ue("sampling/createMessage"), params: Je.extend({ messages: Fe(ds), systemPrompt: Qe(Pe()), includeContext: Qe(Ke(["none", "thisServer", "allServers"])), temperature: Qe($e()), maxTokens: $e().int(), stopSequences: Qe(Fe(Pe())), metadata: Qe(qe({}).passthrough()), modelPreferences: Qe(os) }) });
  var us = tt.extend({ model: Pe(), stopReason: Qe(Ke(["endTurn", "stopSequence", "maxTokens"]).or(Pe())), role: Ke(["user", "assistant"]), content: Le("type", [Lt, Vt, Ut]) });
  var ls = ze([qe({ type: Ue("boolean"), title: Qe(Pe()), description: Qe(Pe()), default: Qe(Me()) }).passthrough(), qe({ type: Ue("string"), title: Qe(Pe()), description: Qe(Pe()), minLength: Qe($e()), maxLength: Qe($e()), format: Qe(Ke(["email", "uri", "date", "date-time"])) }).passthrough(), qe({ type: Ke(["number", "integer"]), title: Qe(Pe()), description: Qe(Pe()), minimum: Qe($e()), maximum: Qe($e()) }).passthrough(), qe({ type: Ue("string"), title: Qe(Pe()), description: Qe(Pe()), enum: Fe(Pe()), enumNames: Qe(Fe(Pe())) }).passthrough()]);
  var hs = Ye.extend({ method: Ue("elicitation/create"), params: Je.extend({ message: Pe(), requestedSchema: qe({ type: Ue("object"), properties: Ve(Pe(), ls), required: Qe(Fe(Pe())) }).passthrough() }) });
  var ps = tt.extend({ action: Ke(["accept", "reject", "cancel"]), content: Qe(Ve(Pe(), De())) });
  var ms = qe({ type: Ue("ref/resource"), uri: Pe() }).passthrough();
  var gs = qe({ type: Ue("ref/prompt"), name: Pe() }).passthrough();
  var fs = Ye.extend({ method: Ue("completion/complete"), params: Je.extend({ ref: ze([gs, ms]), argument: qe({ name: Pe(), value: Pe() }).passthrough(), context: Qe(qe({ arguments: Qe(Ve(Pe(), Pe())) })) }) });
  var ys = tt.extend({ completion: qe({ values: Fe(Pe()).max(100), total: Qe($e().int()), hasMore: Qe(Me()) }).passthrough() });
  var _s = qe({ uri: Pe().startsWith("file://"), name: Qe(Pe()), _meta: Qe(qe({}).passthrough()) }).passthrough();
  var vs = Ye.extend({ method: Ue("roots/list") });
  var xs = tt.extend({ roots: Fe(_s) });
  var ks = et.extend({ method: Ue("notifications/roots/list_changed") });
  ze([yt, pt, fs, rs, zt, Ft, Ct, Zt, It, jt, Pt, ts, Yt]), ze([ct, vt, ft, ks]), ze([dt, us, ps, xs]), ze([yt, cs, hs, vs]), ze([ct, vt, ns, $t, Nt, ss, Ht]), ze([dt, gt, ys, Wt, qt, Rt, Ot, Et, es, Xt]), Error;
  var bs = class _bs {
    constructor(e2, t2) {
      __publicField(this, "sessionId");
      __publicField(this, "onmessage");
      __publicField(this, "onerror");
      __publicField(this, "onclose");
      __publicField(this, "_port");
      __publicField(this, "_started", false);
      __publicField(this, "_closed", false);
      if (!e2) throw new Error("MessagePort is required");
      this._port = e2, this.sessionId = t2 || this.generateId(), this._port.onmessage = (e3) => {
        var _a, _b;
        try {
          const t3 = ot.parse(e3.data);
          (_a = this.onmessage) == null ? void 0 : _a.call(this, t3);
        } catch (e4) {
          const t3 = new Error(`Failed to parse message: ${e4}`);
          (_b = this.onerror) == null ? void 0 : _b.call(this, t3);
        }
      }, this._port.onmessageerror = (e3) => {
        var _a;
        const t3 = new Error(`MessagePort error: ${JSON.stringify(e3)}`);
        (_a = this.onerror) == null ? void 0 : _a.call(this, t3);
      };
    }
    static generateSessionId() {
      return "undefined" != typeof crypto && "function" == typeof crypto.randomUUID ? crypto.randomUUID() : `${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 10)}`;
    }
    start() {
      return __async(this, null, function* () {
        if (this._started) throw new Error("BrowserContextTransport already started! If using Client or Server class, note that connect() calls start() automatically.");
        if (this._closed) throw new Error("Cannot start a closed BrowserContextTransport");
        this._started = true, this._port.start();
      });
    }
    send(e2) {
      return __async(this, null, function* () {
        if (this._closed) throw new Error("Cannot send on a closed BrowserContextTransport");
        return new Promise((t2, s2) => {
          var _a;
          try {
            this._port.postMessage(e2), t2();
          } catch (e3) {
            const t3 = e3 instanceof Error ? e3 : new Error(String(e3));
            (_a = this.onerror) == null ? void 0 : _a.call(this, t3), s2(t3);
          }
        });
      });
    }
    close() {
      return __async(this, null, function* () {
        var _a;
        this._closed || (this._closed = true, this._port.close(), (_a = this.onclose) == null ? void 0 : _a.call(this));
      });
    }
    generateId() {
      return _bs.generateSessionId();
    }
  };
  var ws = class {
    constructor() {
      __publicField(this, "angieDetector");
      __publicField(this, "registrationQueue");
      __publicField(this, "clientManager");
      __publicField(this, "isInitialized", false);
      this.angieDetector = new r(), this.registrationQueue = new n(), this.clientManager = new i(), this.setupAngieReadyHandler(), this.setupServerInitHandler();
    }
    setupAngieReadyHandler() {
      this.angieDetector.waitForReady().then((e2) => {
        e2.isReady ? this.handleAngieReady() : console.warn("AngieMcpSdk: Angie not detected - servers will remain queued");
      }).catch((e2) => {
        console.error("AngieMcpSdk: Error waiting for Angie:", e2);
      });
    }
    handleAngieReady() {
      return __async(this, null, function* () {
        console.log("AngieMcpSdk: Angie is ready, processing queued registrations");
        try {
          yield this.registrationQueue.processQueue((e2) => __async(this, null, function* () {
            yield this.processRegistration(e2);
          })), this.isInitialized = true, console.log("AngieMcpSdk: Initialization complete");
        } catch (e2) {
          console.error("AngieMcpSdk: Error processing registration queue:", e2);
        }
      });
    }
    processRegistration(e2) {
      return __async(this, null, function* () {
        console.log(`AngieMcpSdk: Processing registration for server "${e2.config.name}"`);
        try {
          yield this.clientManager.requestClientCreation(e2), console.log(`AngieMcpSdk: Successfully registered server "${e2.config.name}"`);
        } catch (t2) {
          throw console.error(`AngieMcpSdk: Failed to register server "${e2.config.name}":`, t2), t2;
        }
      });
    }
    registerServer(e2) {
      return __async(this, null, function* () {
        if (!e2.server) throw new Error("Server instance is required");
        if (!e2.name) throw new Error("Server name is required");
        if (!e2.description) throw new Error("Server description is required");
        console.log(`AngieMcpSdk: Registering server "${e2.name}"`);
        const t2 = this.registrationQueue.add(e2);
        if (this.angieDetector.isReady()) try {
          yield this.processRegistration(t2), this.registrationQueue.updateStatus(t2.id, "registered"), console.log(`AngieMcpSdk: Server "${e2.name}" registered successfully`);
        } catch (e3) {
          const s2 = e3 instanceof Error ? e3.message : String(e3);
          throw this.registrationQueue.updateStatus(t2.id, "failed", s2), e3;
        }
        else console.log(`AngieMcpSdk: Server "${e2.name}" queued until Angie is ready`);
      });
    }
    getRegistrations() {
      return this.registrationQueue.getAll();
    }
    getPendingRegistrations() {
      return this.registrationQueue.getPending();
    }
    isAngieReady() {
      return this.angieDetector.isReady();
    }
    isReady() {
      return this.isInitialized;
    }
    waitForReady() {
      return __async(this, null, function* () {
        if (!(yield this.angieDetector.waitForReady()).isReady) throw new Error("Angie is not available");
        for (; !this.isInitialized; ) yield new Promise((e2) => setTimeout(e2, 100));
      });
    }
    destroy() {
      this.registrationQueue.clear(), console.log("AngieMcpSdk: SDK destroyed");
    }
    setupServerInitHandler() {
      globalThis.addEventListener("message", (e2) => {
        var _a;
        ((_a = e2.data) == null ? void 0 : _a.type) === t.SDK_REQUEST_INIT_SERVER && this.handleServerInitRequest(e2);
      });
    }
    handleServerInitRequest(e2) {
      const { clientId: t2, serverId: s2 } = e2.data.payload || {};
      if (t2 && s2) {
        console.log(`AngieMcpSdk: Handling server init request for clientId: ${t2}, serverId: ${s2}`);
        try {
          const t3 = this.registrationQueue.getAll().find((e3) => e3.id === s2);
          if (!t3) return void console.error(`AngieMcpSdk: No registration found for serverId: ${s2}`);
          const a2 = e2.ports[0];
          if (!a2) return void console.error("AngieMcpSdk: No port provided in server init request");
          const r2 = t3.config.server, n2 = new bs(a2);
          r2.connect(n2), console.log(`AngieMcpSdk: Server "${t3.config.name}" initialized successfully`);
        } catch (e3) {
          console.error(`AngieMcpSdk: Error initializing server for clientId ${t2}:`, e3);
        }
      } else console.error("AngieMcpSdk: Invalid server init request - missing clientId or serverId");
    }
  };

  // node_modules/chrono-node/dist/esm/results.js
  var import_quarterOfYear = __toESM(require_quarterOfYear(), 1);
  var import_dayjs2 = __toESM(require_dayjs_min(), 1);

  // node_modules/chrono-node/dist/esm/types.js
  var Meridiem;
  (function(Meridiem2) {
    Meridiem2[Meridiem2["AM"] = 0] = "AM";
    Meridiem2[Meridiem2["PM"] = 1] = "PM";
  })(Meridiem || (Meridiem = {}));
  var Weekday;
  (function(Weekday2) {
    Weekday2[Weekday2["SUNDAY"] = 0] = "SUNDAY";
    Weekday2[Weekday2["MONDAY"] = 1] = "MONDAY";
    Weekday2[Weekday2["TUESDAY"] = 2] = "TUESDAY";
    Weekday2[Weekday2["WEDNESDAY"] = 3] = "WEDNESDAY";
    Weekday2[Weekday2["THURSDAY"] = 4] = "THURSDAY";
    Weekday2[Weekday2["FRIDAY"] = 5] = "FRIDAY";
    Weekday2[Weekday2["SATURDAY"] = 6] = "SATURDAY";
  })(Weekday || (Weekday = {}));
  var Month;
  (function(Month2) {
    Month2[Month2["JANUARY"] = 1] = "JANUARY";
    Month2[Month2["FEBRUARY"] = 2] = "FEBRUARY";
    Month2[Month2["MARCH"] = 3] = "MARCH";
    Month2[Month2["APRIL"] = 4] = "APRIL";
    Month2[Month2["MAY"] = 5] = "MAY";
    Month2[Month2["JUNE"] = 6] = "JUNE";
    Month2[Month2["JULY"] = 7] = "JULY";
    Month2[Month2["AUGUST"] = 8] = "AUGUST";
    Month2[Month2["SEPTEMBER"] = 9] = "SEPTEMBER";
    Month2[Month2["OCTOBER"] = 10] = "OCTOBER";
    Month2[Month2["NOVEMBER"] = 11] = "NOVEMBER";
    Month2[Month2["DECEMBER"] = 12] = "DECEMBER";
  })(Month || (Month = {}));

  // node_modules/chrono-node/dist/esm/utils/dates.js
  function assignSimilarDate(component, target) {
    component.assign("day", target.getDate());
    component.assign("month", target.getMonth() + 1);
    component.assign("year", target.getFullYear());
  }
  function assignSimilarTime(component, target) {
    component.assign("hour", target.getHours());
    component.assign("minute", target.getMinutes());
    component.assign("second", target.getSeconds());
    component.assign("millisecond", target.getMilliseconds());
    component.assign("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
  }
  function implySimilarDate(component, target) {
    component.imply("day", target.getDate());
    component.imply("month", target.getMonth() + 1);
    component.imply("year", target.getFullYear());
  }
  function implySimilarTime(component, target) {
    component.imply("hour", target.getHours());
    component.imply("minute", target.getMinutes());
    component.imply("second", target.getSeconds());
    component.imply("millisecond", target.getMilliseconds());
    component.imply("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
  }

  // node_modules/chrono-node/dist/esm/timezone.js
  var import_dayjs = __toESM(require_dayjs_min(), 1);
  var TIMEZONE_ABBR_MAP = {
    ACDT: 630,
    ACST: 570,
    ADT: -180,
    AEDT: 660,
    AEST: 600,
    AFT: 270,
    AKDT: -480,
    AKST: -540,
    ALMT: 360,
    AMST: -180,
    AMT: -240,
    ANAST: 720,
    ANAT: 720,
    AQTT: 300,
    ART: -180,
    AST: -240,
    AWDT: 540,
    AWST: 480,
    AZOST: 0,
    AZOT: -60,
    AZST: 300,
    AZT: 240,
    BNT: 480,
    BOT: -240,
    BRST: -120,
    BRT: -180,
    BST: 60,
    BTT: 360,
    CAST: 480,
    CAT: 120,
    CCT: 390,
    CDT: -300,
    CEST: 120,
    CET: {
      timezoneOffsetDuringDst: 2 * 60,
      timezoneOffsetNonDst: 60,
      dstStart: (year) => getLastWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2),
      dstEnd: (year) => getLastWeekdayOfMonth(year, Month.OCTOBER, Weekday.SUNDAY, 3)
    },
    CHADT: 825,
    CHAST: 765,
    CKT: -600,
    CLST: -180,
    CLT: -240,
    COT: -300,
    CST: -360,
    CT: {
      timezoneOffsetDuringDst: -5 * 60,
      timezoneOffsetNonDst: -6 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    CVT: -60,
    CXT: 420,
    ChST: 600,
    DAVT: 420,
    EASST: -300,
    EAST: -360,
    EAT: 180,
    ECT: -300,
    EDT: -240,
    EEST: 180,
    EET: 120,
    EGST: 0,
    EGT: -60,
    EST: -300,
    ET: {
      timezoneOffsetDuringDst: -4 * 60,
      timezoneOffsetNonDst: -5 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    FJST: 780,
    FJT: 720,
    FKST: -180,
    FKT: -240,
    FNT: -120,
    GALT: -360,
    GAMT: -540,
    GET: 240,
    GFT: -180,
    GILT: 720,
    GMT: 0,
    GST: 240,
    GYT: -240,
    HAA: -180,
    HAC: -300,
    HADT: -540,
    HAE: -240,
    HAP: -420,
    HAR: -360,
    HAST: -600,
    HAT: -90,
    HAY: -480,
    HKT: 480,
    HLV: -210,
    HNA: -240,
    HNC: -360,
    HNE: -300,
    HNP: -480,
    HNR: -420,
    HNT: -150,
    HNY: -540,
    HOVT: 420,
    ICT: 420,
    IDT: 180,
    IOT: 360,
    IRDT: 270,
    IRKST: 540,
    IRKT: 540,
    IRST: 210,
    IST: 330,
    JST: 540,
    KGT: 360,
    KRAST: 480,
    KRAT: 480,
    KST: 540,
    KUYT: 240,
    LHDT: 660,
    LHST: 630,
    LINT: 840,
    MAGST: 720,
    MAGT: 720,
    MART: -510,
    MAWT: 300,
    MDT: -360,
    MESZ: 120,
    MEZ: 60,
    MHT: 720,
    MMT: 390,
    MSD: 240,
    MSK: 180,
    MST: -420,
    MT: {
      timezoneOffsetDuringDst: -6 * 60,
      timezoneOffsetNonDst: -7 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    MUT: 240,
    MVT: 300,
    MYT: 480,
    NCT: 660,
    NDT: -90,
    NFT: 690,
    NOVST: 420,
    NOVT: 360,
    NPT: 345,
    NST: -150,
    NUT: -660,
    NZDT: 780,
    NZST: 720,
    OMSST: 420,
    OMST: 420,
    PDT: -420,
    PET: -300,
    PETST: 720,
    PETT: 720,
    PGT: 600,
    PHOT: 780,
    PHT: 480,
    PKT: 300,
    PMDT: -120,
    PMST: -180,
    PONT: 660,
    PST: -480,
    PT: {
      timezoneOffsetDuringDst: -7 * 60,
      timezoneOffsetNonDst: -8 * 60,
      dstStart: (year) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),
      dstEnd: (year) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
    },
    PWT: 540,
    PYST: -180,
    PYT: -240,
    RET: 240,
    SAMT: 240,
    SAST: 120,
    SBT: 660,
    SCT: 240,
    SGT: 480,
    SRT: -180,
    SST: -660,
    TAHT: -600,
    TFT: 300,
    TJT: 300,
    TKT: 780,
    TLT: 540,
    TMT: 300,
    TVT: 720,
    ULAT: 480,
    UTC: 0,
    UYST: -120,
    UYT: -180,
    UZT: 300,
    VET: -210,
    VLAST: 660,
    VLAT: 660,
    VUT: 660,
    WAST: 120,
    WAT: 60,
    WEST: 60,
    WESZ: 60,
    WET: 0,
    WEZ: 0,
    WFT: 720,
    WGST: -120,
    WGT: -180,
    WIB: 420,
    WIT: 540,
    WITA: 480,
    WST: 780,
    WT: 0,
    YAKST: 600,
    YAKT: 600,
    YAPT: 600,
    YEKST: 360,
    YEKT: 360
  };
  function getNthWeekdayOfMonth(year, month, weekday, n2, hour = 0) {
    let dayOfMonth = 0;
    let i2 = 0;
    while (i2 < n2) {
      dayOfMonth++;
      const date = new Date(year, month - 1, dayOfMonth);
      if (date.getDay() === weekday)
        i2++;
    }
    return new Date(year, month - 1, dayOfMonth, hour);
  }
  function getLastWeekdayOfMonth(year, month, weekday, hour = 0) {
    const oneIndexedWeekday = weekday === 0 ? 7 : weekday;
    const date = new Date(year, month - 1 + 1, 1, 12);
    const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();
    let dayDiff;
    if (firstWeekdayNextMonth === oneIndexedWeekday)
      dayDiff = 7;
    else if (firstWeekdayNextMonth < oneIndexedWeekday)
      dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;
    else
      dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;
    date.setDate(date.getDate() - dayDiff);
    return new Date(year, month - 1, date.getDate(), hour);
  }
  function toTimezoneOffset(timezoneInput, date, timezoneOverrides = {}) {
    var _a;
    if (timezoneInput == null) {
      return null;
    }
    if (typeof timezoneInput === "number") {
      return timezoneInput;
    }
    const matchedTimezone = (_a = timezoneOverrides[timezoneInput]) != null ? _a : TIMEZONE_ABBR_MAP[timezoneInput];
    if (matchedTimezone == null) {
      return null;
    }
    if (typeof matchedTimezone == "number") {
      return matchedTimezone;
    }
    if (date == null) {
      return null;
    }
    if ((0, import_dayjs.default)(date).isAfter(matchedTimezone.dstStart(date.getFullYear())) && !(0, import_dayjs.default)(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))) {
      return matchedTimezone.timezoneOffsetDuringDst;
    }
    return matchedTimezone.timezoneOffsetNonDst;
  }

  // node_modules/chrono-node/dist/esm/calculation/duration.js
  function addDuration(ref, duration) {
    var _a, _b, _c, _d, _e2, _f, _g;
    let date = new Date(ref);
    if (duration["y"]) {
      duration["year"] = duration["y"];
      delete duration["y"];
    }
    if (duration["mo"]) {
      duration["month"] = duration["mo"];
      delete duration["mo"];
    }
    if (duration["M"]) {
      duration["month"] = duration["M"];
      delete duration["M"];
    }
    if (duration["w"]) {
      duration["week"] = duration["w"];
      delete duration["w"];
    }
    if (duration["d"]) {
      duration["day"] = duration["d"];
      delete duration["d"];
    }
    if (duration["h"]) {
      duration["hour"] = duration["h"];
      delete duration["h"];
    }
    if (duration["m"]) {
      duration["minute"] = duration["m"];
      delete duration["m"];
    }
    if (duration["s"]) {
      duration["second"] = duration["s"];
      delete duration["s"];
    }
    if (duration["ms"]) {
      duration["millisecond"] = duration["ms"];
      delete duration["ms"];
    }
    if ("year" in duration) {
      const floor = Math.floor(duration["year"]);
      date.setFullYear(date.getFullYear() + floor);
      const remainingFraction = duration["year"] - floor;
      if (remainingFraction > 0) {
        duration.month = (_a = duration == null ? void 0 : duration.month) != null ? _a : 0;
        duration.month += remainingFraction * 12;
      }
    }
    if ("quarter" in duration) {
      const floor = Math.floor(duration["quarter"]);
      date.setMonth(date.getMonth() + floor * 3);
    }
    if ("month" in duration) {
      const floor = Math.floor(duration["month"]);
      date.setMonth(date.getMonth() + floor);
      const remainingFraction = duration["month"] - floor;
      if (remainingFraction > 0) {
        duration.week = (_b = duration == null ? void 0 : duration.week) != null ? _b : 0;
        duration.week += remainingFraction * 4;
      }
    }
    if ("week" in duration) {
      const floor = Math.floor(duration["week"]);
      date.setDate(date.getDate() + floor * 7);
      const remainingFraction = duration["week"] - floor;
      if (remainingFraction > 0) {
        duration.day = (_c = duration == null ? void 0 : duration.day) != null ? _c : 0;
        duration.day += Math.round(remainingFraction * 7);
      }
    }
    if ("day" in duration) {
      const floor = Math.floor(duration["day"]);
      date.setDate(date.getDate() + floor);
      const remainingFraction = duration["day"] - floor;
      if (remainingFraction > 0) {
        duration.hour = (_d = duration == null ? void 0 : duration.hour) != null ? _d : 0;
        duration.hour += Math.round(remainingFraction * 24);
      }
    }
    if ("hour" in duration) {
      const floor = Math.floor(duration["hour"]);
      date.setHours(date.getHours() + floor);
      const remainingFraction = duration["hour"] - floor;
      if (remainingFraction > 0) {
        duration.minute = (_e2 = duration == null ? void 0 : duration.minute) != null ? _e2 : 0;
        duration.minute += Math.round(remainingFraction * 60);
      }
    }
    if ("minute" in duration) {
      const floor = Math.floor(duration["minute"]);
      date.setMinutes(date.getMinutes() + floor);
      const remainingFraction = duration["minute"] - floor;
      if (remainingFraction > 0) {
        duration.second = (_f = duration == null ? void 0 : duration.second) != null ? _f : 0;
        duration.second += Math.round(remainingFraction * 60);
      }
    }
    if ("second" in duration) {
      const floor = Math.floor(duration["second"]);
      date.setSeconds(date.getSeconds() + floor);
      const remainingFraction = duration["second"] - floor;
      if (remainingFraction > 0) {
        duration.millisecond = (_g = duration == null ? void 0 : duration.millisecond) != null ? _g : 0;
        duration.millisecond += Math.round(remainingFraction * 1e3);
      }
    }
    if ("millisecond" in duration) {
      const floor = Math.floor(duration["millisecond"]);
      date.setMilliseconds(date.getMilliseconds() + floor);
    }
    return date;
  }
  function reverseDuration(duration) {
    const reversed = {};
    for (const key in duration) {
      reversed[key] = -duration[key];
    }
    return reversed;
  }

  // node_modules/chrono-node/dist/esm/results.js
  import_dayjs2.default.extend(import_quarterOfYear.default);
  var ReferenceWithTimezone = class _ReferenceWithTimezone {
    constructor(instant, timezoneOffset) {
      __publicField(this, "instant");
      __publicField(this, "timezoneOffset");
      this.instant = instant != null ? instant : /* @__PURE__ */ new Date();
      this.timezoneOffset = timezoneOffset != null ? timezoneOffset : null;
    }
    static fromDate(date) {
      return new _ReferenceWithTimezone(date);
    }
    static fromInput(input, timezoneOverrides) {
      var _a;
      if (input instanceof Date) {
        return _ReferenceWithTimezone.fromDate(input);
      }
      const instant = (_a = input == null ? void 0 : input.instant) != null ? _a : /* @__PURE__ */ new Date();
      const timezoneOffset = toTimezoneOffset(input == null ? void 0 : input.timezone, instant, timezoneOverrides);
      return new _ReferenceWithTimezone(instant, timezoneOffset);
    }
    getDateWithAdjustedTimezone() {
      const date = new Date(this.instant);
      if (this.timezoneOffset !== null) {
        date.setMinutes(date.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant));
      }
      return date;
    }
    getSystemTimezoneAdjustmentMinute(date, overrideTimezoneOffset) {
      var _a;
      if (!date || date.getTime() < 0) {
        date = /* @__PURE__ */ new Date();
      }
      const currentTimezoneOffset = -date.getTimezoneOffset();
      const targetTimezoneOffset = (_a = overrideTimezoneOffset != null ? overrideTimezoneOffset : this.timezoneOffset) != null ? _a : currentTimezoneOffset;
      return currentTimezoneOffset - targetTimezoneOffset;
    }
    getTimezoneOffset() {
      var _a;
      return (_a = this.timezoneOffset) != null ? _a : -this.instant.getTimezoneOffset();
    }
  };
  var ParsingComponents = class _ParsingComponents {
    constructor(reference, knownComponents) {
      __publicField(this, "knownValues");
      __publicField(this, "impliedValues");
      __publicField(this, "reference");
      __publicField(this, "_tags", /* @__PURE__ */ new Set());
      this.reference = reference;
      this.knownValues = {};
      this.impliedValues = {};
      if (knownComponents) {
        for (const key in knownComponents) {
          this.knownValues[key] = knownComponents[key];
        }
      }
      const refDayJs = reference.getDateWithAdjustedTimezone();
      this.imply("day", refDayJs.getDate());
      this.imply("month", refDayJs.getMonth() + 1);
      this.imply("year", refDayJs.getFullYear());
      this.imply("hour", 12);
      this.imply("minute", 0);
      this.imply("second", 0);
      this.imply("millisecond", 0);
    }
    get(component) {
      if (component in this.knownValues) {
        return this.knownValues[component];
      }
      if (component in this.impliedValues) {
        return this.impliedValues[component];
      }
      return null;
    }
    isCertain(component) {
      return component in this.knownValues;
    }
    getCertainComponents() {
      return Object.keys(this.knownValues);
    }
    imply(component, value) {
      if (component in this.knownValues) {
        return this;
      }
      this.impliedValues[component] = value;
      return this;
    }
    assign(component, value) {
      this.knownValues[component] = value;
      delete this.impliedValues[component];
      return this;
    }
    delete(component) {
      delete this.knownValues[component];
      delete this.impliedValues[component];
    }
    clone() {
      const component = new _ParsingComponents(this.reference);
      component.knownValues = {};
      component.impliedValues = {};
      for (const key in this.knownValues) {
        component.knownValues[key] = this.knownValues[key];
      }
      for (const key in this.impliedValues) {
        component.impliedValues[key] = this.impliedValues[key];
      }
      return component;
    }
    isOnlyDate() {
      return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
    }
    isOnlyTime() {
      return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month") && !this.isCertain("year");
    }
    isOnlyWeekdayComponent() {
      return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
    }
    isDateWithUnknownYear() {
      return this.isCertain("month") && !this.isCertain("year");
    }
    isValidDate() {
      const date = this.dateWithoutTimezoneAdjustment();
      if (date.getFullYear() !== this.get("year"))
        return false;
      if (date.getMonth() !== this.get("month") - 1)
        return false;
      if (date.getDate() !== this.get("day"))
        return false;
      if (this.get("hour") != null && date.getHours() != this.get("hour"))
        return false;
      if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
        return false;
      return true;
    }
    toString() {
      return `[ParsingComponents {
            tags: ${JSON.stringify(Array.from(this._tags).sort())}, 
            knownValues: ${JSON.stringify(this.knownValues)}, 
            impliedValues: ${JSON.stringify(this.impliedValues)}}, 
            reference: ${JSON.stringify(this.reference)}]`;
    }
    dayjs() {
      return (0, import_dayjs2.default)(this.dateWithoutTimezoneAdjustment());
    }
    date() {
      const date = this.dateWithoutTimezoneAdjustment();
      const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get("timezoneOffset"));
      return new Date(date.getTime() + timezoneAdjustment * 6e4);
    }
    addTag(tag) {
      this._tags.add(tag);
      return this;
    }
    addTags(tags) {
      for (const tag of tags) {
        this._tags.add(tag);
      }
      return this;
    }
    tags() {
      return new Set(this._tags);
    }
    dateWithoutTimezoneAdjustment() {
      const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
      date.setFullYear(this.get("year"));
      return date;
    }
    static createRelativeFromReference(reference, duration) {
      let date = addDuration(reference.getDateWithAdjustedTimezone(), duration);
      const components = new _ParsingComponents(reference);
      components.addTag("result/relativeDate");
      if (duration["hour"] || duration["minute"] || duration["second"]) {
        components.addTag("result/relativeDateAndTime");
        assignSimilarTime(components, date);
        assignSimilarDate(components, date);
        components.assign("timezoneOffset", reference.getTimezoneOffset());
      } else {
        implySimilarTime(components, date);
        components.imply("timezoneOffset", reference.getTimezoneOffset());
        if (duration["day"]) {
          components.assign("day", date.getDate());
          components.assign("month", date.getMonth() + 1);
          components.assign("year", date.getFullYear());
          components.assign("weekday", date.getDay());
        } else if (duration["week"]) {
          components.assign("day", date.getDate());
          components.assign("month", date.getMonth() + 1);
          components.assign("year", date.getFullYear());
          components.imply("weekday", date.getDay());
        } else {
          components.imply("day", date.getDate());
          if (duration["month"]) {
            components.assign("month", date.getMonth() + 1);
            components.assign("year", date.getFullYear());
          } else {
            components.imply("month", date.getMonth() + 1);
            if (duration["year"]) {
              components.assign("year", date.getFullYear());
            } else {
              components.imply("year", date.getFullYear());
            }
          }
        }
      }
      return components;
    }
  };
  var ParsingResult = class _ParsingResult {
    constructor(reference, index, text, start, end) {
      __publicField(this, "refDate");
      __publicField(this, "index");
      __publicField(this, "text");
      __publicField(this, "reference");
      __publicField(this, "start");
      __publicField(this, "end");
      this.reference = reference;
      this.refDate = reference.instant;
      this.index = index;
      this.text = text;
      this.start = start || new ParsingComponents(reference);
      this.end = end;
    }
    clone() {
      const result = new _ParsingResult(this.reference, this.index, this.text);
      result.start = this.start ? this.start.clone() : null;
      result.end = this.end ? this.end.clone() : null;
      return result;
    }
    date() {
      return this.start.date();
    }
    addTag(tag) {
      this.start.addTag(tag);
      if (this.end) {
        this.end.addTag(tag);
      }
      return this;
    }
    addTags(tags) {
      this.start.addTags(tags);
      if (this.end) {
        this.end.addTags(tags);
      }
      return this;
    }
    tags() {
      const combinedTags = new Set(this.start.tags());
      if (this.end) {
        for (const tag of this.end.tags()) {
          combinedTags.add(tag);
        }
      }
      return combinedTags;
    }
    toString() {
      const tags = Array.from(this.tags()).sort();
      return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;
    }
  };

  // node_modules/chrono-node/dist/esm/utils/pattern.js
  function repeatedTimeunitPattern(prefix, singleTimeunitPattern, connectorPattern = "\\s{0,5},?\\s{0,5}") {
    const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
    return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;
  }
  function extractTerms(dictionary) {
    let keys;
    if (dictionary instanceof Array) {
      keys = [...dictionary];
    } else if (dictionary instanceof Map) {
      keys = Array.from(dictionary.keys());
    } else {
      keys = Object.keys(dictionary);
    }
    return keys;
  }
  function matchAnyPattern(dictionary) {
    const joinedTerms = extractTerms(dictionary).sort((a2, b2) => b2.length - a2.length).join("|").replace(/\./g, "\\.");
    return `(?:${joinedTerms})`;
  }

  // node_modules/chrono-node/dist/esm/calculation/years.js
  var import_dayjs3 = __toESM(require_dayjs_min(), 1);
  function findMostLikelyADYear(yearNumber) {
    if (yearNumber < 100) {
      if (yearNumber > 50) {
        yearNumber = yearNumber + 1900;
      } else {
        yearNumber = yearNumber + 2e3;
      }
    }
    return yearNumber;
  }
  function findYearClosestToRef(refDate, day, month) {
    const refMoment = (0, import_dayjs3.default)(refDate);
    let dateMoment = refMoment;
    dateMoment = dateMoment.month(month - 1);
    dateMoment = dateMoment.date(day);
    dateMoment = dateMoment.year(refMoment.year());
    const nextYear = dateMoment.add(1, "y");
    const lastYear = dateMoment.add(-1, "y");
    if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
      dateMoment = nextYear;
    } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
      dateMoment = lastYear;
    }
    return dateMoment.year();
  }

  // node_modules/chrono-node/dist/esm/locales/en/constants.js
  var WEEKDAY_DICTIONARY = {
    sunday: 0,
    sun: 0,
    "sun.": 0,
    monday: 1,
    mon: 1,
    "mon.": 1,
    tuesday: 2,
    tue: 2,
    "tue.": 2,
    wednesday: 3,
    wed: 3,
    "wed.": 3,
    thursday: 4,
    thurs: 4,
    "thurs.": 4,
    thur: 4,
    "thur.": 4,
    thu: 4,
    "thu.": 4,
    friday: 5,
    fri: 5,
    "fri.": 5,
    saturday: 6,
    sat: 6,
    "sat.": 6
  };
  var FULL_MONTH_NAME_DICTIONARY = {
    january: 1,
    february: 2,
    march: 3,
    april: 4,
    may: 5,
    june: 6,
    july: 7,
    august: 8,
    september: 9,
    october: 10,
    november: 11,
    december: 12
  };
  var MONTH_DICTIONARY = __spreadProps(__spreadValues({}, FULL_MONTH_NAME_DICTIONARY), {
    jan: 1,
    "jan.": 1,
    feb: 2,
    "feb.": 2,
    mar: 3,
    "mar.": 3,
    apr: 4,
    "apr.": 4,
    jun: 6,
    "jun.": 6,
    jul: 7,
    "jul.": 7,
    aug: 8,
    "aug.": 8,
    sep: 9,
    "sep.": 9,
    sept: 9,
    "sept.": 9,
    oct: 10,
    "oct.": 10,
    nov: 11,
    "nov.": 11,
    dec: 12,
    "dec.": 12
  });
  var INTEGER_WORD_DICTIONARY = {
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9,
    ten: 10,
    eleven: 11,
    twelve: 12
  };
  var ORDINAL_WORD_DICTIONARY = {
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    twentieth: 20,
    "twenty first": 21,
    "twenty-first": 21,
    "twenty second": 22,
    "twenty-second": 22,
    "twenty third": 23,
    "twenty-third": 23,
    "twenty fourth": 24,
    "twenty-fourth": 24,
    "twenty fifth": 25,
    "twenty-fifth": 25,
    "twenty sixth": 26,
    "twenty-sixth": 26,
    "twenty seventh": 27,
    "twenty-seventh": 27,
    "twenty eighth": 28,
    "twenty-eighth": 28,
    "twenty ninth": 29,
    "twenty-ninth": 29,
    "thirtieth": 30,
    "thirty first": 31,
    "thirty-first": 31
  };
  var TIME_UNIT_DICTIONARY_NO_ABBR = {
    second: "second",
    seconds: "second",
    minute: "minute",
    minutes: "minute",
    hour: "hour",
    hours: "hour",
    day: "d",
    days: "d",
    week: "week",
    weeks: "week",
    month: "month",
    months: "month",
    quarter: "quarter",
    quarters: "quarter",
    year: "year",
    years: "year"
  };
  var TIME_UNIT_DICTIONARY = __spreadValues({
    s: "second",
    sec: "second",
    second: "second",
    seconds: "second",
    m: "minute",
    min: "minute",
    mins: "minute",
    minute: "minute",
    minutes: "minute",
    h: "hour",
    hr: "hour",
    hrs: "hour",
    hour: "hour",
    hours: "hour",
    d: "d",
    day: "d",
    days: "d",
    w: "w",
    week: "week",
    weeks: "week",
    mo: "month",
    mon: "month",
    mos: "month",
    month: "month",
    months: "month",
    qtr: "quarter",
    quarter: "quarter",
    quarters: "quarter",
    y: "year",
    yr: "year",
    year: "year",
    years: "year"
  }, TIME_UNIT_DICTIONARY_NO_ABBR);
  var NUMBER_PATTERN = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|the|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
  function parseNumberPattern(match) {
    const num = match.toLowerCase();
    if (INTEGER_WORD_DICTIONARY[num] !== void 0) {
      return INTEGER_WORD_DICTIONARY[num];
    } else if (num === "a" || num === "an" || num == "the") {
      return 1;
    } else if (num.match(/few/)) {
      return 3;
    } else if (num.match(/half/)) {
      return 0.5;
    } else if (num.match(/couple/)) {
      return 2;
    } else if (num.match(/several/)) {
      return 7;
    }
    return parseFloat(num);
  }
  var ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
  function parseOrdinalNumberPattern(match) {
    let num = match.toLowerCase();
    if (ORDINAL_WORD_DICTIONARY[num] !== void 0) {
      return ORDINAL_WORD_DICTIONARY[num];
    }
    num = num.replace(/(?:st|nd|rd|th)$/i, "");
    return parseInt(num);
  }
  var YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;
  function parseYear(match) {
    if (/BE/i.test(match)) {
      match = match.replace(/BE/i, "");
      return parseInt(match) - 543;
    }
    if (/BCE?/i.test(match)) {
      match = match.replace(/BCE?/i, "");
      return -parseInt(match);
    }
    if (/(AD|CE)/i.test(match)) {
      match = match.replace(/(AD|CE)/i, "");
      return parseInt(match);
    }
    const rawYearNumber = parseInt(match);
    return findMostLikelyADYear(rawYearNumber);
  }
  var SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;
  var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
  var SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY_NO_ABBR)})`;
  var TIME_UNIT_CONNECTOR_PATTERN = `\\s{0,5},?(?:\\s*and)?\\s{0,5}`;
  var TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
  var TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_NO_ABBR_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
  function parseTimeUnits(timeunitText) {
    const fragments = {};
    let remainingText = timeunitText;
    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
    while (match) {
      collectDateTimeFragment(fragments, match);
      remainingText = remainingText.substring(match[0].length).trim();
      match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
    }
    if (Object.keys(fragments).length == 0) {
      return null;
    }
    return fragments;
  }
  function collectDateTimeFragment(fragments, match) {
    if (match[0].match(/^[a-zA-Z]+$/)) {
      return;
    }
    const num = parseNumberPattern(match[1]);
    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
    fragments[unit] = num;
  }

  // node_modules/chrono-node/dist/esm/common/parsers/AbstractParserWithWordBoundary.js
  var AbstractParserWithWordBoundaryChecking = class {
    constructor() {
      __publicField(this, "cachedInnerPattern", null);
      __publicField(this, "cachedPattern", null);
    }
    innerPatternHasChange(context, currentInnerPattern) {
      return this.innerPattern(context) !== currentInnerPattern;
    }
    patternLeftBoundary() {
      return `(\\W|^)`;
    }
    pattern(context) {
      if (this.cachedInnerPattern) {
        if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {
          return this.cachedPattern;
        }
      }
      this.cachedInnerPattern = this.innerPattern(context);
      this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`, this.cachedInnerPattern.flags);
      return this.cachedPattern;
    }
    extract(context, match) {
      var _a;
      const header = (_a = match[1]) != null ? _a : "";
      match.index = match.index + header.length;
      match[0] = match[0].substring(header.length);
      for (let i2 = 2; i2 < match.length; i2++) {
        match[i2 - 1] = match[i2];
      }
      return this.innerExtract(context, match);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitWithinFormatParser.js
  var PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(`(?:(?:within|in|for)\\s*)?(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
  var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
  var PATTERN_WITH_PREFIX_STRICT = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
  var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    constructor(strictMode) {
      super();
      __publicField(this, "strictMode");
      this.strictMode = strictMode;
    }
    innerPattern(context) {
      if (this.strictMode) {
        return PATTERN_WITH_PREFIX_STRICT;
      }
      return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;
    }
    innerExtract(context, match) {
      if (match[0].match(/^for\s*the\s*\w+/)) {
        return null;
      }
      const timeUnits = parseTimeUnits(match[1]);
      if (!timeUnits) {
        return null;
      }
      context.debug(() => {
        console.log(timeUnits);
        console.log(ParsingComponents.createRelativeFromReference(context.reference, timeUnits));
      });
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameLittleEndianParser.js
  var PATTERN = new RegExp(`(?:on\\s{0,3})?(${ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${YEAR_PATTERN}(?!\\w)))?(?=\\W|$)`, "i");
  var DATE_GROUP = 1;
  var DATE_TO_GROUP = 2;
  var MONTH_NAME_GROUP = 3;
  var YEAR_GROUP = 4;
  var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN;
    }
    innerExtract(context, match) {
      const result = context.createParsingResult(match.index, match[0]);
      const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
      const day = parseOrdinalNumberPattern(match[DATE_GROUP]);
      if (day > 31) {
        match.index = match.index + match[DATE_GROUP].length;
        return null;
      }
      result.start.assign("month", month);
      result.start.assign("day", day);
      if (match[YEAR_GROUP]) {
        const yearNumber = parseYear(match[YEAR_GROUP]);
        result.start.assign("year", yearNumber);
      } else {
        const year = findYearClosestToRef(context.refDate, day, month);
        result.start.imply("year", year);
      }
      if (match[DATE_TO_GROUP]) {
        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        result.end = result.start.clone();
        result.end.assign("day", endDate);
      }
      return result;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameMiddleEndianParser.js
  var PATTERN2 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,\\s*|\\s+)(${YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
  var MONTH_NAME_GROUP2 = 1;
  var DATE_GROUP2 = 2;
  var DATE_TO_GROUP2 = 3;
  var YEAR_GROUP2 = 4;
  var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
    constructor(shouldSkipYearLikeDate) {
      super();
      __publicField(this, "shouldSkipYearLikeDate");
      this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;
    }
    innerPattern() {
      return PATTERN2;
    }
    innerExtract(context, match) {
      const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP2].toLowerCase()];
      const day = parseOrdinalNumberPattern(match[DATE_GROUP2]);
      if (day > 31) {
        return null;
      }
      if (this.shouldSkipYearLikeDate) {
        if (!match[DATE_TO_GROUP2] && !match[YEAR_GROUP2] && match[DATE_GROUP2].match(/^2[0-5]$/)) {
          return null;
        }
      }
      const components = context.createParsingComponents({
        day,
        month
      }).addTag("parser/ENMonthNameMiddleEndianParser");
      if (match[YEAR_GROUP2]) {
        const year = parseYear(match[YEAR_GROUP2]);
        components.assign("year", year);
      } else {
        const year = findYearClosestToRef(context.refDate, day, month);
        components.imply("year", year);
      }
      if (!match[DATE_TO_GROUP2]) {
        return components;
      }
      const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP2]);
      const result = context.createParsingResult(match.index, match[0]);
      result.start = components;
      result.end = components.clone();
      result.end.assign("day", endDate);
      return result;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameParser.js
  var PATTERN3 = new RegExp(`((?:in)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY)})\\s*(?:(?:,|-|of)?\\s*(${YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
  var PREFIX_GROUP = 1;
  var MONTH_NAME_GROUP3 = 2;
  var YEAR_GROUP3 = 3;
  var ENMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN3;
    }
    innerExtract(context, match) {
      const monthName = match[MONTH_NAME_GROUP3].toLowerCase();
      if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {
        return null;
      }
      const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
      result.start.imply("day", 1);
      result.start.addTag("parser/ENMonthNameParser");
      const month = MONTH_DICTIONARY[monthName];
      result.start.assign("month", month);
      if (match[YEAR_GROUP3]) {
        const year = parseYear(match[YEAR_GROUP3]);
        result.start.assign("year", year);
      } else {
        const year = findYearClosestToRef(context.refDate, 1, month);
        result.start.imply("year", year);
      }
      return result;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENYearMonthDayParser.js
  var PATTERN4 = new RegExp(`([0-9]{4})[-\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
  var YEAR_NUMBER_GROUP = 1;
  var MONTH_NAME_GROUP4 = 2;
  var MONTH_NUMBER_GROUP = 3;
  var DATE_NUMBER_GROUP = 4;
  var ENYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
    constructor(strictMonthDateOrder) {
      super();
      __publicField(this, "strictMonthDateOrder");
      this.strictMonthDateOrder = strictMonthDateOrder;
    }
    innerPattern() {
      return PATTERN4;
    }
    innerExtract(context, match) {
      const year = parseInt(match[YEAR_NUMBER_GROUP]);
      let day = parseInt(match[DATE_NUMBER_GROUP]);
      let month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : MONTH_DICTIONARY[match[MONTH_NAME_GROUP4].toLowerCase()];
      if (month < 1 || month > 12) {
        if (this.strictMonthDateOrder) {
          return null;
        }
        if (day >= 1 && day <= 12) {
          [month, day] = [day, month];
        }
      }
      if (day < 1 || day > 31) {
        return null;
      }
      return {
        day,
        month,
        year
      };
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENSlashMonthFormatParser.js
  var PATTERN5 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
  var MONTH_GROUP = 1;
  var YEAR_GROUP4 = 2;
  var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN5;
    }
    innerExtract(context, match) {
      const year = parseInt(match[YEAR_GROUP4]);
      const month = parseInt(match[MONTH_GROUP]);
      return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
    }
  };

  // node_modules/chrono-node/dist/esm/common/parsers/AbstractTimeExpressionParser.js
  function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
    return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
  }
  function followingTimePatten(followingPhase, followingSuffix) {
    return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
  }
  var HOUR_GROUP = 2;
  var MINUTE_GROUP = 3;
  var SECOND_GROUP = 4;
  var MILLI_SECOND_GROUP = 5;
  var AM_PM_HOUR_GROUP = 6;
  var AbstractTimeExpressionParser = class {
    constructor(strictMode = false) {
      __publicField(this, "strictMode");
      __publicField(this, "cachedPrimaryPrefix", null);
      __publicField(this, "cachedPrimarySuffix", null);
      __publicField(this, "cachedPrimaryTimePattern", null);
      __publicField(this, "cachedFollowingPhase", null);
      __publicField(this, "cachedFollowingSuffix", null);
      __publicField(this, "cachedFollowingTimePatten", null);
      this.strictMode = strictMode;
    }
    patternFlags() {
      return "i";
    }
    primaryPatternLeftBoundary() {
      return `(^|\\s|T|\\b)`;
    }
    primarySuffix() {
      return `(?!/)(?=\\W|$)`;
    }
    followingSuffix() {
      return `(?!/)(?=\\W|$)`;
    }
    pattern(context) {
      return this.getPrimaryTimePatternThroughCache();
    }
    extract(context, match) {
      const startComponents = this.extractPrimaryTimeComponents(context, match);
      if (!startComponents) {
        if (match[0].match(/^\d{4}/)) {
          match.index += 4;
          return null;
        }
        match.index += match[0].length;
        return null;
      }
      const index = match.index + match[1].length;
      const text = match[0].substring(match[1].length);
      const result = context.createParsingResult(index, text, startComponents);
      match.index += match[0].length;
      const remainingText = context.text.substring(match.index);
      const followingPattern = this.getFollowingTimePatternThroughCache();
      const followingMatch = followingPattern.exec(remainingText);
      if (text.match(/^\d{3,4}/) && followingMatch) {
        if (followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (followingMatch[0].match(/^\s*([+-])\s*\d{2}\W\d{2}/)) {
          return null;
        }
      }
      if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
        return this.checkAndReturnWithoutFollowingPattern(result);
      }
      result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
      if (result.end) {
        result.text += followingMatch[0];
      }
      return this.checkAndReturnWithFollowingPattern(result);
    }
    extractPrimaryTimeComponents(context, match, strict2 = false) {
      const components = context.createParsingComponents();
      let minute = 0;
      let meridiem = null;
      let hour = parseInt(match[HOUR_GROUP]);
      if (hour > 100) {
        if (this.strictMode || match[MINUTE_GROUP] != null) {
          return null;
        }
        minute = hour % 100;
        hour = Math.floor(hour / 100);
      }
      if (hour > 24) {
        return null;
      }
      if (match[MINUTE_GROUP] != null) {
        if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
          return null;
        }
        minute = parseInt(match[MINUTE_GROUP]);
      }
      if (minute >= 60) {
        return null;
      }
      if (hour > 12) {
        meridiem = Meridiem.PM;
      }
      if (match[AM_PM_HOUR_GROUP] != null) {
        if (hour > 12)
          return null;
        const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
        if (ampm == "a") {
          meridiem = Meridiem.AM;
          if (hour == 12) {
            hour = 0;
          }
        }
        if (ampm == "p") {
          meridiem = Meridiem.PM;
          if (hour != 12) {
            hour += 12;
          }
        }
      }
      components.assign("hour", hour);
      components.assign("minute", minute);
      if (meridiem !== null) {
        components.assign("meridiem", meridiem);
      } else {
        if (hour < 12) {
          components.imply("meridiem", Meridiem.AM);
        } else {
          components.imply("meridiem", Meridiem.PM);
        }
      }
      if (match[MILLI_SECOND_GROUP] != null) {
        const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
        if (millisecond >= 1e3)
          return null;
        components.assign("millisecond", millisecond);
      }
      if (match[SECOND_GROUP] != null) {
        const second = parseInt(match[SECOND_GROUP]);
        if (second >= 60)
          return null;
        components.assign("second", second);
      }
      return components;
    }
    extractFollowingTimeComponents(context, match, result) {
      const components = context.createParsingComponents();
      if (match[MILLI_SECOND_GROUP] != null) {
        const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
        if (millisecond >= 1e3)
          return null;
        components.assign("millisecond", millisecond);
      }
      if (match[SECOND_GROUP] != null) {
        const second = parseInt(match[SECOND_GROUP]);
        if (second >= 60)
          return null;
        components.assign("second", second);
      }
      let hour = parseInt(match[HOUR_GROUP]);
      let minute = 0;
      let meridiem = -1;
      if (match[MINUTE_GROUP] != null) {
        minute = parseInt(match[MINUTE_GROUP]);
      } else if (hour > 100) {
        minute = hour % 100;
        hour = Math.floor(hour / 100);
      }
      if (minute >= 60 || hour > 24) {
        return null;
      }
      if (hour >= 12) {
        meridiem = Meridiem.PM;
      }
      if (match[AM_PM_HOUR_GROUP] != null) {
        if (hour > 12) {
          return null;
        }
        const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
        if (ampm == "a") {
          meridiem = Meridiem.AM;
          if (hour == 12) {
            hour = 0;
            if (!components.isCertain("day")) {
              components.imply("day", components.get("day") + 1);
            }
          }
        }
        if (ampm == "p") {
          meridiem = Meridiem.PM;
          if (hour != 12)
            hour += 12;
        }
        if (!result.start.isCertain("meridiem")) {
          if (meridiem == Meridiem.AM) {
            result.start.imply("meridiem", Meridiem.AM);
            if (result.start.get("hour") == 12) {
              result.start.assign("hour", 0);
            }
          } else {
            result.start.imply("meridiem", Meridiem.PM);
            if (result.start.get("hour") != 12) {
              result.start.assign("hour", result.start.get("hour") + 12);
            }
          }
        }
      }
      components.assign("hour", hour);
      components.assign("minute", minute);
      if (meridiem >= 0) {
        components.assign("meridiem", meridiem);
      } else {
        const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
        if (startAtPM) {
          if (result.start.get("hour") - 12 > hour) {
            components.imply("meridiem", Meridiem.AM);
          } else if (hour <= 12) {
            components.assign("hour", hour + 12);
            components.assign("meridiem", Meridiem.PM);
          }
        } else if (hour > 12) {
          components.imply("meridiem", Meridiem.PM);
        } else if (hour <= 12) {
          components.imply("meridiem", Meridiem.AM);
        }
      }
      if (components.date().getTime() < result.start.date().getTime()) {
        components.imply("day", components.get("day") + 1);
      }
      return components;
    }
    checkAndReturnWithoutFollowingPattern(result) {
      if (result.text.match(/^\d$/)) {
        return null;
      }
      if (result.text.match(/^\d\d\d+$/)) {
        return null;
      }
      if (result.text.match(/\d[apAP]$/)) {
        return null;
      }
      const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
      if (endingWithNumbers) {
        const endingNumbers = endingWithNumbers[1];
        if (this.strictMode) {
          return null;
        }
        if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
          return null;
        }
        const endingNumberVal = parseInt(endingNumbers);
        if (endingNumberVal > 24) {
          return null;
        }
      }
      return result;
    }
    checkAndReturnWithFollowingPattern(result) {
      if (result.text.match(/^\d+-\d+$/)) {
        return null;
      }
      const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
      if (endingWithNumbers) {
        if (this.strictMode) {
          return null;
        }
        const startingNumbers = endingWithNumbers[1];
        const endingNumbers = endingWithNumbers[2];
        if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
          return null;
        }
        const endingNumberVal = parseInt(endingNumbers);
        const startingNumberVal = parseInt(startingNumbers);
        if (endingNumberVal > 24 || startingNumberVal > 24) {
          return null;
        }
      }
      return result;
    }
    getPrimaryTimePatternThroughCache() {
      const primaryPrefix = this.primaryPrefix();
      const primarySuffix = this.primarySuffix();
      if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
        return this.cachedPrimaryTimePattern;
      }
      this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
      this.cachedPrimaryPrefix = primaryPrefix;
      this.cachedPrimarySuffix = primarySuffix;
      return this.cachedPrimaryTimePattern;
    }
    getFollowingTimePatternThroughCache() {
      const followingPhase = this.followingPhase();
      const followingSuffix = this.followingSuffix();
      if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
        return this.cachedFollowingTimePatten;
      }
      this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
      this.cachedFollowingPhase = followingPhase;
      this.cachedFollowingSuffix = followingSuffix;
      return this.cachedFollowingTimePatten;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeExpressionParser.js
  var ENTimeExpressionParser = class extends AbstractTimeExpressionParser {
    constructor(strictMode) {
      super(strictMode);
    }
    followingPhase() {
      return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|until|through|till|\\?)\\s*";
    }
    primaryPrefix() {
      return "(?:(?:at|from)\\s*)??";
    }
    primarySuffix() {
      return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
    }
    extractPrimaryTimeComponents(context, match) {
      const components = super.extractPrimaryTimeComponents(context, match);
      if (!components) {
        return components;
      }
      if (match[0].endsWith("night")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match[0].endsWith("afternoon")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match[0].endsWith("morning")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
      return components.addTag("parser/ENTimeExpressionParser");
    }
    extractFollowingTimeComponents(context, match, result) {
      const followingComponents = super.extractFollowingTimeComponents(context, match, result);
      if (followingComponents) {
        followingComponents.addTag("parser/ENTimeExpressionParser");
      }
      return followingComponents;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitAgoFormatParser.js
  var PATTERN6 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
  var STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
  var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    constructor(strictMode) {
      super();
      __publicField(this, "strictMode");
      this.strictMode = strictMode;
    }
    innerPattern() {
      return this.strictMode ? STRICT_PATTERN : PATTERN6;
    }
    innerExtract(context, match) {
      const duration = parseTimeUnits(match[1]);
      if (!duration) {
        return null;
      }
      return ParsingComponents.createRelativeFromReference(context.reference, reverseDuration(duration));
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitLaterFormatParser.js
  var PATTERN7 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
  var STRICT_PATTERN2 = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(later|after|from now)(?=\\W|$)`, "i");
  var GROUP_NUM_TIMEUNITS = 1;
  var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    constructor(strictMode) {
      super();
      __publicField(this, "strictMode");
      this.strictMode = strictMode;
    }
    innerPattern() {
      return this.strictMode ? STRICT_PATTERN2 : PATTERN7;
    }
    innerExtract(context, match) {
      const timeUnits = parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
      if (!timeUnits) {
        return null;
      }
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
  };

  // node_modules/chrono-node/dist/esm/common/abstractRefiners.js
  var Filter = class {
    refine(context, results) {
      return results.filter((r2) => this.isValid(context, r2));
    }
  };
  var MergingRefiner = class {
    refine(context, results) {
      if (results.length < 2) {
        return results;
      }
      const mergedResults = [];
      let curResult = results[0];
      let nextResult = null;
      for (let i2 = 1; i2 < results.length; i2++) {
        nextResult = results[i2];
        const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
        if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
          mergedResults.push(curResult);
          curResult = nextResult;
        } else {
          const left = curResult;
          const right = nextResult;
          const mergedResult = this.mergeResults(textBetween, left, right, context);
          context.debug(() => {
            console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
          });
          curResult = mergedResult;
        }
      }
      if (curResult != null) {
        mergedResults.push(curResult);
      }
      return mergedResults;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateRangeRefiner.js
  var AbstractMergeDateRangeRefiner = class extends MergingRefiner {
    shouldMergeResults(textBetween, currentResult, nextResult) {
      return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
    }
    mergeResults(textBetween, fromResult, toResult) {
      if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
        toResult.start.getCertainComponents().forEach((key) => {
          if (!fromResult.start.isCertain(key)) {
            fromResult.start.imply(key, toResult.start.get(key));
          }
        });
        fromResult.start.getCertainComponents().forEach((key) => {
          if (!toResult.start.isCertain(key)) {
            toResult.start.imply(key, fromResult.start.get(key));
          }
        });
      }
      if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
        let fromMoment = fromResult.start.dayjs();
        let toMoment = toResult.start.dayjs();
        if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
          toMoment = toMoment.add(7, "days");
          toResult.start.imply("day", toMoment.date());
          toResult.start.imply("month", toMoment.month() + 1);
          toResult.start.imply("year", toMoment.year());
        } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
          fromMoment = fromMoment.add(-7, "days");
          fromResult.start.imply("day", fromMoment.date());
          fromResult.start.imply("month", fromMoment.month() + 1);
          fromResult.start.imply("year", fromMoment.year());
        } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, "years").isAfter(fromMoment)) {
          toMoment = toMoment.add(1, "years");
          toResult.start.imply("year", toMoment.year());
        } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, "years").isBefore(toMoment)) {
          fromMoment = fromMoment.add(-1, "years");
          fromResult.start.imply("year", fromMoment.year());
        } else {
          [toResult, fromResult] = [fromResult, toResult];
        }
      }
      const result = fromResult.clone();
      result.start = fromResult.start;
      result.end = toResult.start;
      result.index = Math.min(fromResult.index, toResult.index);
      if (fromResult.index < toResult.index) {
        result.text = fromResult.text + textBetween + toResult.text;
      } else {
        result.text = toResult.text + textBetween + fromResult.text;
      }
      return result;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateRangeRefiner.js
  var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
    patternBetween() {
      return /^\s*(to|-||until|through|till)\s*$/i;
    }
  };

  // node_modules/chrono-node/dist/esm/utils/dayjs.js
  function implyTheNextDay(component, targetDayJs) {
    targetDayJs = targetDayJs.add(1, "day");
    implySimilarDate2(component, targetDayJs);
    implySimilarTime2(component, targetDayJs);
  }
  function assignSimilarDate2(component, targetDayJs) {
    component.assign("day", targetDayJs.date());
    component.assign("month", targetDayJs.month() + 1);
    component.assign("year", targetDayJs.year());
  }
  function assignSimilarTime2(component, targetDayJs) {
    component.assign("hour", targetDayJs.hour());
    component.assign("minute", targetDayJs.minute());
    component.assign("second", targetDayJs.second());
    component.assign("millisecond", targetDayJs.millisecond());
    if (component.get("hour") < 12) {
      component.assign("meridiem", Meridiem.AM);
    } else {
      component.assign("meridiem", Meridiem.PM);
    }
  }
  function implySimilarDate2(component, targetDayJs) {
    component.imply("day", targetDayJs.date());
    component.imply("month", targetDayJs.month() + 1);
    component.imply("year", targetDayJs.year());
  }
  function implySimilarTime2(component, targetDayJs) {
    component.imply("hour", targetDayJs.hour());
    component.imply("minute", targetDayJs.minute());
    component.imply("second", targetDayJs.second());
    component.imply("millisecond", targetDayJs.millisecond());
  }

  // node_modules/chrono-node/dist/esm/calculation/mergingCalculation.js
  function mergeDateTimeResult(dateResult, timeResult) {
    const result = dateResult.clone();
    const beginDate = dateResult.start;
    const beginTime = timeResult.start;
    result.start = mergeDateTimeComponent(beginDate, beginTime);
    if (dateResult.end != null || timeResult.end != null) {
      const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
      const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
      const endDateTime = mergeDateTimeComponent(endDate, endTime);
      if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
        const nextDayJs = endDateTime.dayjs().add(1, "day");
        if (endDateTime.isCertain("day")) {
          assignSimilarDate2(endDateTime, nextDayJs);
        } else {
          implySimilarDate2(endDateTime, nextDayJs);
        }
      }
      result.end = endDateTime;
    }
    return result;
  }
  function mergeDateTimeComponent(dateComponent, timeComponent) {
    const dateTimeComponent = dateComponent.clone();
    if (timeComponent.isCertain("hour")) {
      dateTimeComponent.assign("hour", timeComponent.get("hour"));
      dateTimeComponent.assign("minute", timeComponent.get("minute"));
      if (timeComponent.isCertain("second")) {
        dateTimeComponent.assign("second", timeComponent.get("second"));
        if (timeComponent.isCertain("millisecond")) {
          dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
        } else {
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
    } else {
      dateTimeComponent.imply("hour", timeComponent.get("hour"));
      dateTimeComponent.imply("minute", timeComponent.get("minute"));
      dateTimeComponent.imply("second", timeComponent.get("second"));
      dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
    }
    if (timeComponent.isCertain("timezoneOffset")) {
      dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
    }
    if (timeComponent.isCertain("meridiem")) {
      dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
    } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
      dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
    }
    if (dateTimeComponent.get("meridiem") == Meridiem.PM && dateTimeComponent.get("hour") < 12) {
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
      } else {
        dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
      }
    }
    dateTimeComponent.addTags(dateComponent.tags());
    dateTimeComponent.addTags(timeComponent.tags());
    return dateTimeComponent;
  }

  // node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateTimeRefiner.js
  var AbstractMergeDateTimeRefiner = class extends MergingRefiner {
    shouldMergeResults(textBetween, currentResult, nextResult) {
      return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
    }
    mergeResults(textBetween, currentResult, nextResult) {
      const result = currentResult.start.isOnlyDate() ? mergeDateTimeResult(currentResult, nextResult) : mergeDateTimeResult(nextResult, currentResult);
      result.index = currentResult.index;
      result.text = currentResult.text + textBetween + nextResult.text;
      return result;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateTimeRefiner.js
  var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
    patternBetween() {
      return new RegExp("^\\s*(T|at|after|before|on|of|,|-|\\.|\u2219|:)?\\s*$");
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneAbbrRefiner.js
  var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
  var ExtractTimezoneAbbrRefiner = class {
    constructor(timezoneOverrides) {
      __publicField(this, "timezoneOverrides");
      this.timezoneOverrides = timezoneOverrides;
    }
    refine(context, results) {
      var _a;
      const timezoneOverrides = (_a = context.option.timezones) != null ? _a : {};
      results.forEach((result) => {
        var _a2, _b;
        const suffix = context.text.substring(result.index + result.text.length);
        const match = TIMEZONE_NAME_PATTERN.exec(suffix);
        if (!match) {
          return;
        }
        const timezoneAbbr = match[1].toUpperCase();
        const refDate = (_b = (_a2 = result.start.date()) != null ? _a2 : result.refDate) != null ? _b : /* @__PURE__ */ new Date();
        const tzOverrides = __spreadValues(__spreadValues({}, this.timezoneOverrides), timezoneOverrides);
        const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);
        if (extractedTimezoneOffset == null) {
          return;
        }
        context.debug(() => {
          console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
        });
        const currentTimezoneOffset = result.start.get("timezoneOffset");
        if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
          if (result.start.isCertain("timezoneOffset")) {
            return;
          }
          if (timezoneAbbr != match[1]) {
            return;
          }
        }
        if (result.start.isOnlyDate()) {
          if (timezoneAbbr != match[1]) {
            return;
          }
        }
        result.text += match[0];
        if (!result.start.isCertain("timezoneOffset")) {
          result.start.assign("timezoneOffset", extractedTimezoneOffset);
        }
        if (result.end != null && !result.end.isCertain("timezoneOffset")) {
          result.end.assign("timezoneOffset", extractedTimezoneOffset);
        }
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneOffsetRefiner.js
  var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
  var TIMEZONE_OFFSET_SIGN_GROUP = 1;
  var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
  var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
  var ExtractTimezoneOffsetRefiner = class {
    refine(context, results) {
      results.forEach(function(result) {
        if (result.start.isCertain("timezoneOffset")) {
          return;
        }
        const suffix = context.text.substring(result.index + result.text.length);
        const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
        if (!match) {
          return;
        }
        context.debug(() => {
          console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
        });
        const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
        const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
        let timezoneOffset = hourOffset * 60 + minuteOffset;
        if (timezoneOffset > 14 * 60) {
          return;
        }
        if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
          timezoneOffset = -timezoneOffset;
        }
        if (result.end != null) {
          result.end.assign("timezoneOffset", timezoneOffset);
        }
        result.start.assign("timezoneOffset", timezoneOffset);
        result.text += match[0];
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/OverlapRemovalRefiner.js
  var OverlapRemovalRefiner = class {
    refine(context, results) {
      if (results.length < 2) {
        return results;
      }
      const filteredResults = [];
      let prevResult = results[0];
      for (let i2 = 1; i2 < results.length; i2++) {
        const result = results[i2];
        if (result.index >= prevResult.index + prevResult.text.length) {
          filteredResults.push(prevResult);
          prevResult = result;
          continue;
        }
        let kept = null;
        let removed = null;
        if (result.text.length > prevResult.text.length) {
          kept = result;
          removed = prevResult;
        } else {
          kept = prevResult;
          removed = result;
        }
        context.debug(() => {
          console.log(`${this.constructor.name} remove ${removed} by ${kept}`);
        });
        prevResult = kept;
      }
      if (prevResult != null) {
        filteredResults.push(prevResult);
      }
      return filteredResults;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/ForwardDateRefiner.js
  var import_dayjs5 = __toESM(require_dayjs_min(), 1);
  var ForwardDateRefiner = class {
    refine(context, results) {
      if (!context.option.forwardDate) {
        return results;
      }
      results.forEach((result) => {
        let refMoment = (0, import_dayjs5.default)(context.reference.getDateWithAdjustedTimezone());
        if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {
          const refDate = context.reference.getDateWithAdjustedTimezone();
          const refFollowingDay = new Date(refDate);
          refFollowingDay.setDate(refFollowingDay.getDate() + 1);
          implySimilarDate(result.start, refFollowingDay);
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result} time from the ref date (${refDate}) to the following day (${refFollowingDay})`);
          });
          if (result.end && result.end.isOnlyTime()) {
            implySimilarDate(result.end, refFollowingDay);
            if (result.start.date() > result.end.date()) {
              refFollowingDay.setDate(refFollowingDay.getDate() + 1);
              implySimilarDate(result.end, refFollowingDay);
            }
          }
        }
        if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
          if (refMoment.day() >= result.start.get("weekday")) {
            refMoment = refMoment.day(result.start.get("weekday") + 7);
          } else {
            refMoment = refMoment.day(result.start.get("weekday"));
          }
          result.start.imply("day", refMoment.date());
          result.start.imply("month", refMoment.month() + 1);
          result.start.imply("year", refMoment.year());
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);
          });
          if (result.end && result.end.isOnlyWeekdayComponent()) {
            if (refMoment.day() > result.end.get("weekday")) {
              refMoment = refMoment.day(result.end.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result.end.get("weekday"));
            }
            result.end.imply("day", refMoment.date());
            result.end.imply("month", refMoment.month() + 1);
            result.end.imply("year", refMoment.year());
            context.debug(() => {
              console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);
            });
          }
        }
        if (result.start.isDateWithUnknownYear() && refMoment.isAfter(result.start.dayjs())) {
          for (let i2 = 0; i2 < 3 && refMoment.isAfter(result.start.dayjs()); i2++) {
            result.start.imply("year", result.start.get("year") + 1);
            context.debug(() => {
              console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);
            });
            if (result.end && !result.end.isCertain("year")) {
              result.end.imply("year", result.end.get("year") + 1);
              context.debug(() => {
                console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);
              });
            }
          }
        }
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/UnlikelyFormatFilter.js
  var UnlikelyFormatFilter = class extends Filter {
    constructor(strictMode) {
      super();
      __publicField(this, "strictMode");
      this.strictMode = strictMode;
    }
    isValid(context, result) {
      if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
        context.debug(() => {
          console.log(`Removing unlikely result '${result.text}'`);
        });
        return false;
      }
      if (!result.start.isValidDate()) {
        context.debug(() => {
          console.log(`Removing invalid result: ${result} (${result.start})`);
        });
        return false;
      }
      if (result.end && !result.end.isValidDate()) {
        context.debug(() => {
          console.log(`Removing invalid result: ${result} (${result.end})`);
        });
        return false;
      }
      if (this.strictMode) {
        return this.isStrictModeValid(context, result);
      }
      return true;
    }
    isStrictModeValid(context, result) {
      if (result.start.isOnlyWeekdayComponent()) {
        context.debug(() => {
          console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
        });
        return false;
      }
      return true;
    }
  };

  // node_modules/chrono-node/dist/esm/common/parsers/ISOFormatParser.js
  var PATTERN8 = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
  var YEAR_NUMBER_GROUP2 = 1;
  var MONTH_NUMBER_GROUP2 = 2;
  var DATE_NUMBER_GROUP2 = 3;
  var HOUR_NUMBER_GROUP = 4;
  var MINUTE_NUMBER_GROUP = 5;
  var SECOND_NUMBER_GROUP = 6;
  var MILLISECOND_NUMBER_GROUP = 7;
  var TZD_GROUP = 8;
  var TZD_HOUR_OFFSET_GROUP = 9;
  var TZD_MINUTE_OFFSET_GROUP = 10;
  var ISOFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN8;
    }
    innerExtract(context, match) {
      const components = context.createParsingComponents({
        "year": parseInt(match[YEAR_NUMBER_GROUP2]),
        "month": parseInt(match[MONTH_NUMBER_GROUP2]),
        "day": parseInt(match[DATE_NUMBER_GROUP2])
      });
      if (match[HOUR_NUMBER_GROUP] != null) {
        components.assign("hour", parseInt(match[HOUR_NUMBER_GROUP]));
        components.assign("minute", parseInt(match[MINUTE_NUMBER_GROUP]));
        if (match[SECOND_NUMBER_GROUP] != null) {
          components.assign("second", parseInt(match[SECOND_NUMBER_GROUP]));
        }
        if (match[MILLISECOND_NUMBER_GROUP] != null) {
          components.assign("millisecond", parseInt(match[MILLISECOND_NUMBER_GROUP]));
        }
        if (match[TZD_GROUP] != null) {
          let offset = 0;
          if (match[TZD_HOUR_OFFSET_GROUP]) {
            const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
            }
            offset = hourOffset * 60;
            if (offset < 0) {
              offset -= minuteOffset;
            } else {
              offset += minuteOffset;
            }
          }
          components.assign("timezoneOffset", offset);
        }
      }
      return components.addTag("parser/ISOFormatParser");
    }
  };

  // node_modules/chrono-node/dist/esm/common/refiners/MergeWeekdayComponentRefiner.js
  var MergeWeekdayComponentRefiner = class extends MergingRefiner {
    mergeResults(textBetween, currentResult, nextResult) {
      const newResult = nextResult.clone();
      newResult.index = currentResult.index;
      newResult.text = currentResult.text + textBetween + newResult.text;
      newResult.start.assign("weekday", currentResult.start.get("weekday"));
      if (newResult.end) {
        newResult.end.assign("weekday", currentResult.start.get("weekday"));
      }
      return newResult;
    }
    shouldMergeResults(textBetween, currentResult, nextResult) {
      const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
      return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
    }
  };

  // node_modules/chrono-node/dist/esm/configurations.js
  function includeCommonConfiguration(configuration2, strictMode = false) {
    configuration2.parsers.unshift(new ISOFormatParser());
    configuration2.refiners.unshift(new MergeWeekdayComponentRefiner());
    configuration2.refiners.unshift(new ExtractTimezoneOffsetRefiner());
    configuration2.refiners.unshift(new OverlapRemovalRefiner());
    configuration2.refiners.push(new ExtractTimezoneAbbrRefiner());
    configuration2.refiners.push(new OverlapRemovalRefiner());
    configuration2.refiners.push(new ForwardDateRefiner());
    configuration2.refiners.push(new UnlikelyFormatFilter(strictMode));
    return configuration2;
  }

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
  var import_dayjs8 = __toESM(require_dayjs_min(), 1);

  // node_modules/chrono-node/dist/esm/common/casualReferences.js
  var import_dayjs6 = __toESM(require_dayjs_min(), 1);
  function now(reference) {
    const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference, {});
    assignSimilarDate2(component, targetDate);
    assignSimilarTime2(component, targetDate);
    component.assign("timezoneOffset", reference.getTimezoneOffset());
    component.addTag("casualReference/now");
    return component;
  }
  function today(reference) {
    const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference, {});
    assignSimilarDate2(component, targetDate);
    implySimilarTime2(component, targetDate);
    component.addTag("casualReference/today");
    return component;
  }
  function yesterday(reference) {
    return theDayBefore(reference, 1).addTag("casualReference/yesterday");
  }
  function theDayBefore(reference, numDay) {
    return theDayAfter(reference, -numDay);
  }
  function tomorrow(reference) {
    return theDayAfter(reference, 1).addTag("casualReference/tomorrow");
  }
  function theDayAfter(reference, nDays) {
    let targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference, {});
    targetDate = targetDate.add(nDays, "day");
    assignSimilarDate2(component, targetDate);
    implySimilarTime2(component, targetDate);
    return component;
  }
  function tonight(reference, implyHour = 22) {
    const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
    const component = new ParsingComponents(reference, {});
    assignSimilarDate2(component, targetDate);
    component.imply("hour", implyHour);
    component.imply("meridiem", Meridiem.PM);
    component.addTag("casualReference/tonight");
    return component;
  }
  function evening(reference, implyHour = 20) {
    const component = new ParsingComponents(reference, {});
    component.imply("meridiem", Meridiem.PM);
    component.imply("hour", implyHour);
    component.addTag("casualReference/evening");
    return component;
  }
  function midnight(reference) {
    const component = new ParsingComponents(reference, {});
    const targetDate = (0, import_dayjs6.default)(reference.getDateWithAdjustedTimezone());
    if (targetDate.hour() > 2) {
      implyTheNextDay(component, targetDate);
    }
    component.assign("hour", 0);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/midnight");
    return component;
  }
  function morning(reference, implyHour = 6) {
    const component = new ParsingComponents(reference, {});
    component.imply("meridiem", Meridiem.AM);
    component.imply("hour", implyHour);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/morning");
    return component;
  }
  function afternoon(reference, implyHour = 15) {
    const component = new ParsingComponents(reference, {});
    component.imply("meridiem", Meridiem.PM);
    component.imply("hour", implyHour);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/afternoon");
    return component;
  }
  function noon(reference) {
    const component = new ParsingComponents(reference, {});
    component.imply("meridiem", Meridiem.AM);
    component.assign("hour", 12);
    component.imply("minute", 0);
    component.imply("second", 0);
    component.imply("millisecond", 0);
    component.addTag("casualReference/noon");
    return component;
  }

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
  var PATTERN9 = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
  var ENCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern(context) {
      return PATTERN9;
    }
    innerExtract(context, match) {
      let targetDate = (0, import_dayjs8.default)(context.refDate);
      const lowerText = match[0].toLowerCase();
      let component = context.createParsingComponents();
      switch (lowerText) {
        case "now":
          component = now(context.reference);
          break;
        case "today":
          component = today(context.reference);
          break;
        case "yesterday":
          component = yesterday(context.reference);
          break;
        case "tomorrow":
        case "tmr":
        case "tmrw":
          component = tomorrow(context.reference);
          break;
        case "tonight":
          component = tonight(context.reference);
          break;
        case "overmorrow":
          component = theDayAfter(context.reference, 2);
          break;
        default:
          if (lowerText.match(/last\s*night/)) {
            if (targetDate.hour() > 6) {
              targetDate = targetDate.add(-1, "day");
            }
            assignSimilarDate2(component, targetDate);
            component.imply("hour", 0);
          }
          break;
      }
      component.addTag("parser/ENCasualDateParser");
      return component;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualTimeParser.js
  var PATTERN10 = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\W|$)/i;
  var ENCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN10;
    }
    innerExtract(context, match) {
      let component = null;
      switch (match[1].toLowerCase()) {
        case "afternoon":
          component = afternoon(context.reference);
          break;
        case "evening":
        case "night":
          component = evening(context.reference);
          break;
        case "midnight":
          component = midnight(context.reference);
          break;
        case "morning":
          component = morning(context.reference);
          break;
        case "noon":
        case "midday":
          component = noon(context.reference);
          break;
      }
      if (component) {
        component.addTag("parser/ENCasualTimeParser");
      }
      return component;
    }
  };

  // node_modules/chrono-node/dist/esm/utils/timeunits.js
  function reverseTimeUnits(timeUnits) {
    const reversed = {};
    for (const key in timeUnits) {
      reversed[key] = -timeUnits[key];
    }
    return reversed;
  }
  function addImpliedTimeUnits(components, timeUnits) {
    const output = components.clone();
    let date = components.dayjs();
    for (const key in timeUnits) {
      date = date.add(timeUnits[key], key);
    }
    if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
      output.imply("day", date.date());
      output.imply("month", date.month() + 1);
      output.imply("year", date.year());
    }
    if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
      output.imply("second", date.second());
      output.imply("minute", date.minute());
      output.imply("hour", date.hour());
    }
    return output;
  }

  // node_modules/chrono-node/dist/esm/calculation/weekdays.js
  function createParsingComponentsAtWeekday(reference, weekday, modifier) {
    const refDate = reference.getDateWithAdjustedTimezone();
    const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);
    let components = new ParsingComponents(reference);
    components = addImpliedTimeUnits(components, { "day": daysToWeekday });
    components.assign("weekday", weekday);
    return components;
  }
  function getDaysToWeekday(refDate, weekday, modifier) {
    const refWeekday = refDate.getDay();
    switch (modifier) {
      case "this":
        return getDaysForwardToWeekday(refDate, weekday);
      case "last":
        return getBackwardDaysToWeekday(refDate, weekday);
      case "next":
        if (refWeekday == Weekday.SUNDAY) {
          return weekday == Weekday.SUNDAY ? 7 : weekday;
        }
        if (refWeekday == Weekday.SATURDAY) {
          if (weekday == Weekday.SATURDAY)
            return 7;
          if (weekday == Weekday.SUNDAY)
            return 8;
          return 1 + weekday;
        }
        if (weekday < refWeekday && weekday != Weekday.SUNDAY) {
          return getDaysForwardToWeekday(refDate, weekday);
        } else {
          return getDaysForwardToWeekday(refDate, weekday) + 7;
        }
    }
    return getDaysToWeekdayClosest(refDate, weekday);
  }
  function getDaysToWeekdayClosest(refDate, weekday) {
    const backward = getBackwardDaysToWeekday(refDate, weekday);
    const forward = getDaysForwardToWeekday(refDate, weekday);
    return forward < -backward ? forward : backward;
  }
  function getDaysForwardToWeekday(refDate, weekday) {
    const refWeekday = refDate.getDay();
    let forwardCount = weekday - refWeekday;
    if (forwardCount < 0) {
      forwardCount += 7;
    }
    return forwardCount;
  }
  function getBackwardDaysToWeekday(refDate, weekday) {
    const refWeekday = refDate.getDay();
    let backwardCount = weekday - refWeekday;
    if (backwardCount >= 0) {
      backwardCount -= 7;
    }
    return backwardCount;
  }

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENWeekdayParser.js
  var PATTERN11 = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
  var PREFIX_GROUP2 = 1;
  var WEEKDAY_GROUP = 2;
  var POSTFIX_GROUP = 3;
  var ENWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN11;
    }
    innerExtract(context, match) {
      const prefix = match[PREFIX_GROUP2];
      const postfix = match[POSTFIX_GROUP];
      let modifierWord = prefix || postfix;
      modifierWord = modifierWord || "";
      modifierWord = modifierWord.toLowerCase();
      let modifier = null;
      if (modifierWord == "last" || modifierWord == "past") {
        modifier = "last";
      } else if (modifierWord == "next") {
        modifier = "next";
      } else if (modifierWord == "this") {
        modifier = "this";
      }
      const weekday_word = match[WEEKDAY_GROUP].toLowerCase();
      let weekday;
      if (WEEKDAY_DICTIONARY[weekday_word] !== void 0) {
        weekday = WEEKDAY_DICTIONARY[weekday_word];
      } else if (weekday_word == "weekend") {
        weekday = modifier == "last" ? Weekday.SUNDAY : Weekday.SATURDAY;
      } else if (weekday_word == "weekday") {
        const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();
        if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {
          weekday = modifier == "last" ? Weekday.FRIDAY : Weekday.MONDAY;
        } else {
          weekday = refWeekday - 1;
          weekday = modifier == "last" ? weekday - 1 : weekday + 1;
          weekday = weekday % 5 + 1;
        }
      } else {
        return null;
      }
      return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENRelativeDateFormatParser.js
  var import_dayjs10 = __toESM(require_dayjs_min(), 1);
  var PATTERN12 = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
  var MODIFIER_WORD_GROUP = 1;
  var RELATIVE_WORD_GROUP = 2;
  var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    innerPattern() {
      return PATTERN12;
    }
    innerExtract(context, match) {
      const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
      const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
      const timeunit = TIME_UNIT_DICTIONARY[unitWord];
      if (modifier == "next" || modifier.startsWith("after")) {
        const timeUnits = {};
        timeUnits[timeunit] = 1;
        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
      if (modifier == "last" || modifier == "past") {
        const timeUnits = {};
        timeUnits[timeunit] = -1;
        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
      const components = context.createParsingComponents();
      let date = (0, import_dayjs10.default)(context.reference.instant);
      if (unitWord.match(/week/i)) {
        date = date.add(-date.get("d"), "d");
        components.imply("day", date.date());
        components.imply("month", date.month() + 1);
        components.imply("year", date.year());
      } else if (unitWord.match(/month/i)) {
        date = date.add(-date.date() + 1, "d");
        components.imply("day", date.date());
        components.assign("year", date.year());
        components.assign("month", date.month() + 1);
      } else if (unitWord.match(/year/i)) {
        date = date.add(-date.date() + 1, "d");
        date = date.add(-date.month(), "month");
        components.imply("day", date.date());
        components.imply("month", date.month() + 1);
        components.assign("year", date.year());
      }
      return components;
    }
  };

  // node_modules/chrono-node/dist/esm/common/parsers/SlashDateFormatParser.js
  var PATTERN13 = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
  var OPENING_GROUP = 1;
  var ENDING_GROUP = 5;
  var FIRST_NUMBERS_GROUP = 2;
  var SECOND_NUMBERS_GROUP = 3;
  var YEAR_GROUP5 = 4;
  var SlashDateFormatParser = class {
    constructor(littleEndian) {
      __publicField(this, "groupNumberMonth");
      __publicField(this, "groupNumberDay");
      this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
      this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
    }
    pattern() {
      return PATTERN13;
    }
    extract(context, match) {
      const index = match.index + match[OPENING_GROUP].length;
      const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;
      if (index > 0) {
        const textBefore = context.text.substring(0, index);
        if (textBefore.match("\\d/?$")) {
          return;
        }
      }
      if (indexEnd < context.text.length) {
        const textAfter = context.text.substring(indexEnd);
        if (textAfter.match("^/?\\d")) {
          return;
        }
      }
      const text = context.text.substring(index, indexEnd);
      if (text.match(/^\d\.\d$/) || text.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
        return;
      }
      if (!match[YEAR_GROUP5] && text.indexOf("/") < 0) {
        return;
      }
      const result = context.createParsingResult(index, text);
      let month = parseInt(match[this.groupNumberMonth]);
      let day = parseInt(match[this.groupNumberDay]);
      if (month < 1 || month > 12) {
        if (month > 12) {
          if (day >= 1 && day <= 12 && month <= 31) {
            [day, month] = [month, day];
          } else {
            return null;
          }
        }
      }
      if (day < 1 || day > 31) {
        return null;
      }
      result.start.assign("day", day);
      result.start.assign("month", month);
      if (match[YEAR_GROUP5]) {
        const rawYearNumber = parseInt(match[YEAR_GROUP5]);
        const year = findMostLikelyADYear(rawYearNumber);
        result.start.assign("year", year);
      } else {
        const year = findYearClosestToRef(context.refDate, day, month);
        result.start.imply("year", year);
      }
      return result.addTag("parser/SlashDateFormatParser");
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
  var PATTERN14 = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
  var PATTERN_NO_ABBR = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
  var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
    constructor(allowAbbreviations = true) {
      super();
      __publicField(this, "allowAbbreviations");
      this.allowAbbreviations = allowAbbreviations;
    }
    innerPattern() {
      return this.allowAbbreviations ? PATTERN14 : PATTERN_NO_ABBR;
    }
    innerExtract(context, match) {
      const prefix = match[1].toLowerCase();
      let duration = parseTimeUnits(match[2]);
      if (!duration) {
        return null;
      }
      switch (prefix) {
        case "last":
        case "past":
        case "-":
          duration = reverseDuration(duration);
          break;
      }
      return ParsingComponents.createRelativeFromReference(context.reference, duration);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeAfterDateRefiner.js
  function IsPositiveFollowingReference(result) {
    return result.text.match(/^[+-]/i) != null;
  }
  function IsNegativeFollowingReference(result) {
    return result.text.match(/^-/i) != null;
  }
  var ENMergeRelativeAfterDateRefiner = class extends MergingRefiner {
    shouldMergeResults(textBetween, currentResult, nextResult) {
      if (!textBetween.match(/^\s*$/i)) {
        return false;
      }
      return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);
    }
    mergeResults(textBetween, currentResult, nextResult, context) {
      let timeUnits = parseTimeUnits(nextResult.text);
      if (IsNegativeFollowingReference(nextResult)) {
        timeUnits = reverseTimeUnits(timeUnits);
      }
      const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(currentResult.start.date()), timeUnits);
      return new ParsingResult(currentResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.js
  function hasImpliedEarlierReferenceDate(result) {
    return result.text.match(/\s+(before|from)$/i) != null;
  }
  function hasImpliedLaterReferenceDate(result) {
    return result.text.match(/\s+(after|since)$/i) != null;
  }
  var ENMergeRelativeFollowByDateRefiner = class extends MergingRefiner {
    patternBetween() {
      return /^\s*$/i;
    }
    shouldMergeResults(textBetween, currentResult, nextResult) {
      if (!textBetween.match(this.patternBetween())) {
        return false;
      }
      if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
        return false;
      }
      return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
    }
    mergeResults(textBetween, currentResult, nextResult) {
      let duration = parseTimeUnits(currentResult.text);
      if (hasImpliedEarlierReferenceDate(currentResult)) {
        duration = reverseDuration(duration);
      }
      const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(nextResult.start.date()), duration);
      return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENExtractYearSuffixRefiner.js
  var YEAR_SUFFIX_PATTERN = new RegExp(`^\\s*(${YEAR_PATTERN})`, "i");
  var YEAR_GROUP6 = 1;
  var ENExtractYearSuffixRefiner = class {
    refine(context, results) {
      results.forEach(function(result) {
        if (!result.start.isDateWithUnknownYear()) {
          return;
        }
        const suffix = context.text.substring(result.index + result.text.length);
        const match = YEAR_SUFFIX_PATTERN.exec(suffix);
        if (!match) {
          return;
        }
        if (match[0].trim().length <= 3) {
          return;
        }
        context.debug(() => {
          console.log(`Extracting year: '${match[0]}' into : ${result}`);
        });
        const year = parseYear(match[YEAR_GROUP6]);
        if (result.end != null) {
          result.end.assign("year", year);
        }
        result.start.assign("year", year);
        result.text += match[0];
      });
      return results;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/refiners/ENUnlikelyFormatFilter.js
  var ENUnlikelyFormatFilter = class extends Filter {
    constructor() {
      super();
    }
    isValid(context, result) {
      const text = result.text.trim();
      if (text === context.text.trim()) {
        return true;
      }
      if (text.toLowerCase() === "may") {
        const textBefore = context.text.substring(0, result.index).trim();
        if (!textBefore.match(/\b(in)$/i)) {
          context.debug(() => {
            console.log(`Removing unlikely result: ${result}`);
          });
          return false;
        }
      }
      if (text.toLowerCase().endsWith("the second")) {
        const textAfter = context.text.substring(result.index + result.text.length).trim();
        if (textAfter.length > 0) {
          context.debug(() => {
            console.log(`Removing unlikely result: ${result}`);
          });
        }
        return false;
      }
      return true;
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/configuration.js
  var ENDefaultConfiguration = class {
    createCasualConfiguration(littleEndian = false) {
      const option = this.createConfiguration(false, littleEndian);
      option.parsers.push(new ENCasualDateParser());
      option.parsers.push(new ENCasualTimeParser());
      option.parsers.push(new ENMonthNameParser());
      option.parsers.push(new ENRelativeDateFormatParser());
      option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());
      option.refiners.push(new ENUnlikelyFormatFilter());
      return option;
    }
    createConfiguration(strictMode = true, littleEndian = false) {
      const options = includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser(littleEndian),
          new ENTimeUnitWithinFormatParser(strictMode),
          new ENMonthNameLittleEndianParser(),
          new ENMonthNameMiddleEndianParser(littleEndian),
          new ENWeekdayParser(),
          new ENSlashMonthFormatParser(),
          new ENTimeExpressionParser(strictMode),
          new ENTimeUnitAgoFormatParser(strictMode),
          new ENTimeUnitLaterFormatParser(strictMode)
        ],
        refiners: [new ENMergeDateTimeRefiner()]
      }, strictMode);
      options.parsers.unshift(new ENYearMonthDayParser(strictMode));
      options.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());
      options.refiners.unshift(new ENMergeRelativeAfterDateRefiner());
      options.refiners.unshift(new OverlapRemovalRefiner());
      options.refiners.push(new ENMergeDateTimeRefiner());
      options.refiners.push(new ENExtractYearSuffixRefiner());
      options.refiners.push(new ENMergeDateRangeRefiner());
      return options;
    }
  };

  // node_modules/chrono-node/dist/esm/chrono.js
  var Chrono = class _Chrono {
    constructor(configuration2) {
      __publicField(this, "parsers");
      __publicField(this, "refiners");
      __publicField(this, "defaultConfig", new ENDefaultConfiguration());
      configuration2 = configuration2 || this.defaultConfig.createCasualConfiguration();
      this.parsers = [...configuration2.parsers];
      this.refiners = [...configuration2.refiners];
    }
    clone() {
      return new _Chrono({
        parsers: [...this.parsers],
        refiners: [...this.refiners]
      });
    }
    parseDate(text, referenceDate, option) {
      const results = this.parse(text, referenceDate, option);
      return results.length > 0 ? results[0].start.date() : null;
    }
    parse(text, referenceDate, option) {
      const context = new ParsingContext(text, referenceDate, option);
      let results = [];
      this.parsers.forEach((parser) => {
        const parsedResults = _Chrono.executeParser(context, parser);
        results = results.concat(parsedResults);
      });
      results.sort((a2, b2) => {
        return a2.index - b2.index;
      });
      this.refiners.forEach(function(refiner) {
        results = refiner.refine(context, results);
      });
      return results;
    }
    static executeParser(context, parser) {
      const results = [];
      const pattern = parser.pattern(context);
      const originalText = context.text;
      let remainingText = context.text;
      let match = pattern.exec(remainingText);
      while (match) {
        const index = match.index + originalText.length - remainingText.length;
        match.index = index;
        const result = parser.extract(context, match);
        if (!result) {
          remainingText = originalText.substring(match.index + 1);
          match = pattern.exec(remainingText);
          continue;
        }
        let parsedResult = null;
        if (result instanceof ParsingResult) {
          parsedResult = result;
        } else if (result instanceof ParsingComponents) {
          parsedResult = context.createParsingResult(match.index, match[0]);
          parsedResult.start = result;
        } else {
          parsedResult = context.createParsingResult(match.index, match[0], result);
        }
        const parsedIndex = parsedResult.index;
        const parsedText = parsedResult.text;
        context.debug(() => console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`));
        results.push(parsedResult);
        remainingText = originalText.substring(parsedIndex + parsedText.length);
        match = pattern.exec(remainingText);
      }
      return results;
    }
  };
  var ParsingContext = class {
    constructor(text, refDate, option) {
      __publicField(this, "text");
      __publicField(this, "option");
      __publicField(this, "reference");
      __publicField(this, "refDate");
      this.text = text;
      this.option = option != null ? option : {};
      this.reference = ReferenceWithTimezone.fromInput(refDate, this.option.timezones);
      this.refDate = this.reference.instant;
    }
    createParsingComponents(components) {
      if (components instanceof ParsingComponents) {
        return components;
      }
      return new ParsingComponents(this.reference, components);
    }
    createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
      const text = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
      const start = startComponents ? this.createParsingComponents(startComponents) : null;
      const end = endComponents ? this.createParsingComponents(endComponents) : null;
      return new ParsingResult(this.reference, index, text, start, end);
    }
    debug(block) {
      if (this.option.debug) {
        if (this.option.debug instanceof Function) {
          this.option.debug(block);
        } else {
          const handler = this.option.debug;
          handler.debug(block);
        }
      }
    }
  };

  // node_modules/chrono-node/dist/esm/locales/en/index.js
  var configuration = new ENDefaultConfiguration();
  var casual = new Chrono(configuration.createCasualConfiguration(false));
  var strict = new Chrono(configuration.createConfiguration(true, false));
  var GB = new Chrono(configuration.createCasualConfiguration(true));

  // node_modules/chrono-node/dist/esm/index.js
  var casual2 = casual;
  function parse(text, ref, option) {
    return casual2.parse(text, ref, option);
  }

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/external.js
  var external_exports = {};
  __export(external_exports, {
    BRAND: () => BRAND,
    DIRTY: () => DIRTY,
    EMPTY_PATH: () => EMPTY_PATH,
    INVALID: () => INVALID,
    NEVER: () => NEVER,
    OK: () => OK,
    ParseStatus: () => ParseStatus,
    Schema: () => ZodType,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBigInt: () => ZodBigInt,
    ZodBoolean: () => ZodBoolean,
    ZodBranded: () => ZodBranded,
    ZodCatch: () => ZodCatch,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodEffects: () => ZodEffects,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNativeEnum: () => ZodNativeEnum,
    ZodNever: () => ZodNever,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodParsedType: () => ZodParsedType,
    ZodPipeline: () => ZodPipeline,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSchema: () => ZodType,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodSymbol: () => ZodSymbol,
    ZodTransformer: () => ZodEffects,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    addIssueToContext: () => addIssueToContext,
    any: () => anyType,
    array: () => arrayType,
    bigint: () => bigIntType,
    boolean: () => booleanType,
    coerce: () => coerce,
    custom: () => custom,
    date: () => dateType,
    datetimeRegex: () => datetimeRegex,
    defaultErrorMap: () => en_default,
    discriminatedUnion: () => discriminatedUnionType,
    effect: () => effectsType,
    enum: () => enumType,
    function: () => functionType,
    getErrorMap: () => getErrorMap,
    getParsedType: () => getParsedType,
    instanceof: () => instanceOfType,
    intersection: () => intersectionType,
    isAborted: () => isAborted,
    isAsync: () => isAsync,
    isDirty: () => isDirty,
    isValid: () => isValid,
    late: () => late,
    lazy: () => lazyType,
    literal: () => literalType,
    makeIssue: () => makeIssue,
    map: () => mapType,
    nan: () => nanType,
    nativeEnum: () => nativeEnumType,
    never: () => neverType,
    null: () => nullType,
    nullable: () => nullableType,
    number: () => numberType,
    object: () => objectType,
    objectUtil: () => objectUtil,
    oboolean: () => oboolean,
    onumber: () => onumber,
    optional: () => optionalType,
    ostring: () => ostring,
    pipeline: () => pipelineType,
    preprocess: () => preprocessType,
    promise: () => promiseType,
    quotelessJson: () => quotelessJson,
    record: () => recordType,
    set: () => setType,
    setErrorMap: () => setErrorMap,
    strictObject: () => strictObjectType,
    string: () => stringType,
    symbol: () => symbolType,
    transformer: () => effectsType,
    tuple: () => tupleType,
    undefined: () => undefinedType,
    union: () => unionType,
    unknown: () => unknownType,
    util: () => util,
    void: () => voidType
  });

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/helpers/util.js
  var util;
  (function(util2) {
    util2.assertEqual = (_2) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
      const filtered = {};
      for (const k2 of validKeys) {
        filtered[k2] = obj[k2];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e2) {
        return obj[e2];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_2, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return __spreadValues(__spreadValues({}, first), second);
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/ZodError.js
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class _ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof _ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/locales/en.js
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var en_default = errorMap;

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/errors.js
  var overrideErrorMap = en_default;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/helpers/parseUtil.js
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = __spreadProps(__spreadValues({}, issueData), {
      path: fullPath
    });
    if (issueData.message !== void 0) {
      return __spreadProps(__spreadValues({}, issueData), {
        path: fullPath,
        message: issueData.message
      });
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return __spreadProps(__spreadValues({}, issueData), {
      path: fullPath,
      message: errorMessage
    });
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === en_default ? void 0 : en_default
        // then global default map
      ].filter((x2) => !!x2)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s2 of results) {
        if (s2.status === "aborted")
          return INVALID;
        if (s2.status === "dirty")
          status.dirty();
        arrayValue.push(s2.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static mergeObjectAsync(status, pairs) {
      return __async(this, null, function* () {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = yield pair.key;
          const value = yield pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      });
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x2) => x2.status === "aborted";
  var isDirty = (x2) => x2.status === "dirty";
  var isValid = (x2) => x2.status === "valid";
  var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/helpers/errorUtil.js
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));

  // node_modules/@modelcontextprotocol/sdk/node_modules/zod/v3/types.js
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a, _b;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message != null ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a = message != null ? message : required_error) != null ? _a : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b = message != null ? message : invalid_type_error) != null ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params == null ? void 0 : params.async) != null ? _a : false,
          contextualErrorMap: params == null ? void 0 : params.errorMap
        },
        path: (params == null ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      var _a, _b;
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    parseAsync(data, params) {
      return __async(this, null, function* () {
        const result = yield this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      });
    }
    safeParseAsync(data, params) {
      return __async(this, null, function* () {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params == null ? void 0 : params.errorMap,
            async: true
          },
          path: (params == null ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
        return handleResult(ctx, result);
      });
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue(__spreadValues({
          code: ZodIssueCode.custom
        }, getIssueProperties(val)));
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      }));
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      }));
    }
    brand() {
      return new ZodBranded(__spreadValues({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this
      }, processCreateParams(this._def)));
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      }));
    }
    describe(description) {
      const This = this.constructor;
      return new This(__spreadProps(__spreadValues({}, this._def), {
        description
      }));
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch (e2) {
      return false;
    }
  }
  function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (e2) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), __spreadValues({
        validation,
        code: ZodIssueCode.invalid_string
      }, errorUtil.errToObj(message)));
    }
    _addCheck(check) {
      return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
        checks: [...this._def.checks, check]
      }));
    }
    email(message) {
      return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
    }
    url(message) {
      return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
    }
    emoji(message) {
      return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
    }
    uuid(message) {
      return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
    }
    nanoid(message) {
      return this._addCheck(__spreadValues({ kind: "nanoid" }, errorUtil.errToObj(message)));
    }
    cuid(message) {
      return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
    }
    cuid2(message) {
      return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
    }
    ulid(message) {
      return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
    }
    base64(message) {
      return this._addCheck(__spreadValues({ kind: "base64" }, errorUtil.errToObj(message)));
    }
    base64url(message) {
      return this._addCheck(__spreadValues({
        kind: "base64url"
      }, errorUtil.errToObj(message)));
    }
    jwt(options) {
      return this._addCheck(__spreadValues({ kind: "jwt" }, errorUtil.errToObj(options)));
    }
    ip(options) {
      return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
    }
    cidr(options) {
      return this._addCheck(__spreadValues({ kind: "cidr" }, errorUtil.errToObj(options)));
    }
    datetime(options) {
      var _a, _b;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck(__spreadValues({
        kind: "datetime",
        precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
        offset: (_a = options == null ? void 0 : options.offset) != null ? _a : false,
        local: (_b = options == null ? void 0 : options.local) != null ? _b : false
      }, errorUtil.errToObj(options == null ? void 0 : options.message)));
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck(__spreadValues({
        kind: "time",
        precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision
      }, errorUtil.errToObj(options == null ? void 0 : options.message)));
    }
    duration(message) {
      return this._addCheck(__spreadValues({ kind: "duration" }, errorUtil.errToObj(message)));
    }
    regex(regex, message) {
      return this._addCheck(__spreadValues({
        kind: "regex",
        regex
      }, errorUtil.errToObj(message)));
    }
    includes(value, options) {
      return this._addCheck(__spreadValues({
        kind: "includes",
        value,
        position: options == null ? void 0 : options.position
      }, errorUtil.errToObj(options == null ? void 0 : options.message)));
    }
    startsWith(value, message) {
      return this._addCheck(__spreadValues({
        kind: "startsWith",
        value
      }, errorUtil.errToObj(message)));
    }
    endsWith(value, message) {
      return this._addCheck(__spreadValues({
        kind: "endsWith",
        value
      }, errorUtil.errToObj(message)));
    }
    min(minLength, message) {
      return this._addCheck(__spreadValues({
        kind: "min",
        value: minLength
      }, errorUtil.errToObj(message)));
    }
    max(maxLength, message) {
      return this._addCheck(__spreadValues({
        kind: "max",
        value: maxLength
      }, errorUtil.errToObj(message)));
    }
    length(len, message) {
      return this._addCheck(__spreadValues({
        kind: "length",
        value: len
      }, errorUtil.errToObj(message)));
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
        checks: [...this._def.checks, { kind: "trim" }]
      }));
    }
    toLowerCase() {
      return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      }));
    }
    toUpperCase() {
      return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      }));
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString(__spreadValues({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
    }, processCreateParams(params)));
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / __pow(10, decCount);
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      }));
    }
    _addCheck(check) {
      return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
        checks: [...this._def.checks, check]
      }));
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber(__spreadValues({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params == null ? void 0 : params.coerce) || false
    }, processCreateParams(params)));
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch (e2) {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      }));
    }
    _addCheck(check) {
      return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
        checks: [...this._def.checks, check]
      }));
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt(__spreadValues({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
    }, processCreateParams(params)));
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params == null ? void 0 : params.coerce) || false
    }, processCreateParams(params)));
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
        checks: [...this._def.checks, check]
      }));
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate(__spreadValues({
      checks: [],
      coerce: (params == null ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate
    }, processCreateParams(params)));
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodSymbol
    }, processCreateParams(params)));
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodUndefined
    }, processCreateParams(params)));
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodNull
    }, processCreateParams(params)));
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodAny
    }, processCreateParams(params)));
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodUnknown
    }, processCreateParams(params)));
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodNever
    }, processCreateParams(params)));
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodVoid
    }, processCreateParams(params)));
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
        minLength: { value: minLength, message: errorUtil.toString(message) }
      }));
    }
    max(maxLength, message) {
      return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      }));
    }
    length(len, message) {
      return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
        exactLength: { value: len, message: errorUtil.toString(message) }
      }));
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray(__spreadValues({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray
    }, processCreateParams(params)));
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject(__spreadProps(__spreadValues({}, schema._def), {
        shape: () => newShape
      }));
    } else if (schema instanceof ZodArray) {
      return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
        type: deepPartialify(schema.element)
      }));
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {
        } else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(() => __async(this, null, function* () {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = yield pair.key;
            const value = yield pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        })).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
        unknownKeys: "strict"
      }), message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) != null ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) != null ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}));
    }
    strip() {
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        unknownKeys: "strip"
      }));
    }
    passthrough() {
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        unknownKeys: "passthrough"
      }));
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
      }));
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        catchall: index
      }));
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        shape: () => shape
      }));
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        shape: () => shape
      }));
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        shape: () => newShape
      }));
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
        shape: () => newShape
      }));
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject(__spreadValues({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject
    }, processCreateParams(params)));
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject(__spreadValues({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject
    }, processCreateParams(params)));
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject(__spreadValues({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject
    }, processCreateParams(params)));
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map((option) => __async(this, null, function* () {
          const childCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            }),
            parent: null
          });
          return {
            result: yield option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        }))).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            }),
            parent: null
          });
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion(__spreadValues({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion
    }, processCreateParams(params)));
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion(__spreadValues({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap
      }, processCreateParams(params)));
    }
  };
  function mergeValues(a2, b2) {
    const aType = getParsedType(a2);
    const bType = getParsedType(b2);
    if (a2 === b2) {
      return { valid: true, data: a2 };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b2);
      const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = __spreadValues(__spreadValues({}, a2), b2);
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a2[key], b2[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a2.length !== b2.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a2.length; index++) {
        const itemA = a2[index];
        const itemB = b2[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
      return { valid: true, data: a2 };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection(__spreadValues({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection
    }, processCreateParams(params)));
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
        rest
      }));
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple(__spreadValues({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null
    }, processCreateParams(params)));
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord(__spreadValues({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord
        }, processCreateParams(third)));
      }
      return new _ZodRecord(__spreadValues({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord
      }, processCreateParams(second)));
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(() => __async(this, null, function* () {
          for (const pair of pairs) {
            const key = yield pair.key;
            const value = yield pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }));
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap(__spreadValues({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap
    }, processCreateParams(params)));
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
        minSize: { value: minSize, message: errorUtil.toString(message) }
      }));
    }
    max(maxSize, message) {
      return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      }));
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet(__spreadValues({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet
    }, processCreateParams(params)));
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me2 = this;
        return OK(function(...args) {
          return __async(this, null, function* () {
            const error = new ZodError([]);
            const parsedArgs = yield me2._def.args.parseAsync(args, params).catch((e2) => {
              error.addIssue(makeArgsIssue(args, e2));
              throw error;
            });
            const result = yield Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = yield me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
              error.addIssue(makeReturnsIssue(result, e2));
              throw error;
            });
            return parsedReturns;
          });
        });
      } else {
        const me2 = this;
        return OK(function(...args) {
          const parsedArgs = me2._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me2._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      }));
    }
    returns(returnType) {
      return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
        returns: returnType
      }));
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction(__spreadValues({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction
      }, processCreateParams(params)));
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy(__spreadValues({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy
    }, processCreateParams(params)));
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral(__spreadValues({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral
    }, processCreateParams(params)));
  };
  function createZodEnum(values, params) {
    return new ZodEnum(__spreadValues({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum
    }, processCreateParams(params)));
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return _ZodEnum.create(values, __spreadValues(__spreadValues({}, this._def), newDef));
    }
    exclude(values, newDef = this._def) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), __spreadValues(__spreadValues({}, this._def), newDef));
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum(__spreadValues({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum
    }, processCreateParams(params)));
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise(__spreadValues({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise
    }, processCreateParams(params)));
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => __async(this, null, function* () {
            if (status.value === "aborted")
              return INVALID;
            const result = yield this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }));
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects(__spreadValues({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect
    }, processCreateParams(params)));
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects(__spreadValues({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects
    }, processCreateParams(params)));
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional(__spreadValues({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional
    }, processCreateParams(params)));
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable(__spreadValues({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable
    }, processCreateParams(params)));
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault(__spreadValues({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default
    }, processCreateParams(params)));
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = __spreadProps(__spreadValues({}, ctx), {
        common: __spreadProps(__spreadValues({}, ctx.common), {
          issues: []
        })
      });
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: __spreadValues({}, newCtx)
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch(__spreadValues({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
    }, processCreateParams(params)));
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodNaN
    }, processCreateParams(params)));
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = () => __async(this, null, function* () {
          const inResult = yield this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        });
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a2, b2) {
      return new _ZodPipeline({
        in: a2,
        out: b2,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly(__spreadValues({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly
    }, processCreateParams(params)));
  };
  function cleanParams(params, data) {
    const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p22 = typeof p2 === "string" ? { message: p2 } : p2;
    return p22;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        const r2 = check(data);
        if (r2 instanceof Promise) {
          return r2.then((r3) => {
            var _a2, _b2;
            if (!r3) {
              const params = cleanParams(_params, data);
              const _fatal = (_b2 = (_a2 = params.fatal) != null ? _a2 : fatal) != null ? _b2 : true;
              ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, params), { fatal: _fatal }));
            }
          });
        }
        if (!r2) {
          const params = cleanParams(_params, data);
          const _fatal = (_b = (_a = params.fatal) != null ? _a : fatal) != null ? _b : true;
          ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, params), { fatal: _fatal }));
        }
        return;
      });
    return ZodAny.create();
  }
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
    number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
    boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
      coerce: true
    })),
    bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
    date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true }))
  };
  var NEVER = INVALID;

  // node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
  var LATEST_PROTOCOL_VERSION = "2025-06-18";
  var SUPPORTED_PROTOCOL_VERSIONS = [
    LATEST_PROTOCOL_VERSION,
    "2025-03-26",
    "2024-11-05",
    "2024-10-07"
  ];
  var JSONRPC_VERSION = "2.0";
  var ProgressTokenSchema = external_exports.union([external_exports.string(), external_exports.number().int()]);
  var CursorSchema = external_exports.string();
  var RequestMetaSchema = external_exports.object({
    /**
     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
     */
    progressToken: external_exports.optional(ProgressTokenSchema)
  }).passthrough();
  var BaseRequestParamsSchema = external_exports.object({
    _meta: external_exports.optional(RequestMetaSchema)
  }).passthrough();
  var RequestSchema = external_exports.object({
    method: external_exports.string(),
    params: external_exports.optional(BaseRequestParamsSchema)
  });
  var BaseNotificationParamsSchema = external_exports.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var NotificationSchema = external_exports.object({
    method: external_exports.string(),
    params: external_exports.optional(BaseNotificationParamsSchema)
  });
  var ResultSchema = external_exports.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var RequestIdSchema = external_exports.union([external_exports.string(), external_exports.number().int()]);
  var JSONRPCRequestSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: RequestIdSchema
  }).merge(RequestSchema).strict();
  var isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
  var JSONRPCNotificationSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION)
  }).merge(NotificationSchema).strict();
  var isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
  var JSONRPCResponseSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    result: ResultSchema
  }).strict();
  var isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
    ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
    ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
    ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  })(ErrorCode || (ErrorCode = {}));
  var JSONRPCErrorSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    error: external_exports.object({
      /**
       * The error type that occurred.
       */
      code: external_exports.number().int(),
      /**
       * A short description of the error. The message SHOULD be limited to a concise single sentence.
       */
      message: external_exports.string(),
      /**
       * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
       */
      data: external_exports.optional(external_exports.unknown())
    })
  }).strict();
  var isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;
  var JSONRPCMessageSchema = external_exports.union([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResponseSchema,
    JSONRPCErrorSchema
  ]);
  var EmptyResultSchema = ResultSchema.strict();
  var CancelledNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/cancelled"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The ID of the request to cancel.
       *
       * This MUST correspond to the ID of a request previously issued in the same direction.
       */
      requestId: RequestIdSchema,
      /**
       * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
       */
      reason: external_exports.string().optional()
    })
  });
  var BaseMetadataSchema = external_exports.object({
    /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
    name: external_exports.string(),
    /**
    * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
    * even by those unfamiliar with domain-specific terminology.
    *
    * If not provided, the name should be used for display (except for Tool,
    * where `annotations.title` should be given precedence over using `name`,
    * if present).
    */
    title: external_exports.optional(external_exports.string())
  }).passthrough();
  var ImplementationSchema = BaseMetadataSchema.extend({
    version: external_exports.string()
  });
  var ClientCapabilitiesSchema = external_exports.object({
    /**
     * Experimental, non-standard capabilities that the client supports.
     */
    experimental: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the client supports sampling from an LLM.
     */
    sampling: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the client supports eliciting user input.
     */
    elicitation: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the client supports listing roots.
     */
    roots: external_exports.optional(external_exports.object({
      /**
       * Whether the client supports issuing notifications for changes to the roots list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough())
  }).passthrough();
  var InitializeRequestSchema = RequestSchema.extend({
    method: external_exports.literal("initialize"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
       */
      protocolVersion: external_exports.string(),
      capabilities: ClientCapabilitiesSchema,
      clientInfo: ImplementationSchema
    })
  });
  var ServerCapabilitiesSchema = external_exports.object({
    /**
     * Experimental, non-standard capabilities that the server supports.
     */
    experimental: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the server supports sending log messages to the client.
     */
    logging: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the server supports sending completions to the client.
     */
    completions: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the server offers any prompt templates.
     */
    prompts: external_exports.optional(external_exports.object({
      /**
       * Whether this server supports issuing notifications for changes to the prompt list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any resources to read.
     */
    resources: external_exports.optional(external_exports.object({
      /**
       * Whether this server supports clients subscribing to resource updates.
       */
      subscribe: external_exports.optional(external_exports.boolean()),
      /**
       * Whether this server supports issuing notifications for changes to the resource list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any tools to call.
     */
    tools: external_exports.optional(external_exports.object({
      /**
       * Whether this server supports issuing notifications for changes to the tool list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough())
  }).passthrough();
  var InitializeResultSchema = ResultSchema.extend({
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */
    protocolVersion: external_exports.string(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ImplementationSchema,
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */
    instructions: external_exports.optional(external_exports.string())
  });
  var InitializedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/initialized")
  });
  var PingRequestSchema = RequestSchema.extend({
    method: external_exports.literal("ping")
  });
  var ProgressSchema = external_exports.object({
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */
    progress: external_exports.number(),
    /**
     * Total number of items to process (or total progress required), if known.
     */
    total: external_exports.optional(external_exports.number()),
    /**
     * An optional message describing the current progress.
     */
    message: external_exports.optional(external_exports.string())
  }).passthrough();
  var ProgressNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/progress"),
    params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({
      /**
       * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
       */
      progressToken: ProgressTokenSchema
    })
  });
  var PaginatedRequestSchema = RequestSchema.extend({
    params: BaseRequestParamsSchema.extend({
      /**
       * An opaque token representing the current pagination position.
       * If provided, the server should return results starting after this cursor.
       */
      cursor: external_exports.optional(CursorSchema)
    }).optional()
  });
  var PaginatedResultSchema = ResultSchema.extend({
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: external_exports.optional(CursorSchema)
  });
  var ResourceContentsSchema = external_exports.object({
    /**
     * The URI of this resource.
     */
    uri: external_exports.string(),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: external_exports.optional(external_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var TextResourceContentsSchema = ResourceContentsSchema.extend({
    /**
     * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
     */
    text: external_exports.string()
  });
  var Base64Schema = external_exports.string().refine((val) => {
    try {
      atob(val);
      return true;
    } catch (_a) {
      return false;
    }
  }, { message: "Invalid Base64 string" });
  var BlobResourceContentsSchema = ResourceContentsSchema.extend({
    /**
     * A base64-encoded string representing the binary data of the item.
     */
    blob: Base64Schema
  });
  var ResourceSchema = BaseMetadataSchema.extend({
    /**
     * The URI of this resource.
     */
    uri: external_exports.string(),
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: external_exports.optional(external_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  });
  var ResourceTemplateSchema = BaseMetadataSchema.extend({
    /**
     * A URI template (according to RFC 6570) that can be used to construct resource URIs.
     */
    uriTemplate: external_exports.string(),
    /**
     * A description of what this template is for.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
     */
    mimeType: external_exports.optional(external_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  });
  var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("resources/list")
  });
  var ListResourcesResultSchema = PaginatedResultSchema.extend({
    resources: external_exports.array(ResourceSchema)
  });
  var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("resources/templates/list")
  });
  var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
    resourceTemplates: external_exports.array(ResourceTemplateSchema)
  });
  var ReadResourceRequestSchema = RequestSchema.extend({
    method: external_exports.literal("resources/read"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
       */
      uri: external_exports.string()
    })
  });
  var ReadResourceResultSchema = ResultSchema.extend({
    contents: external_exports.array(external_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema]))
  });
  var ResourceListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/resources/list_changed")
  });
  var SubscribeRequestSchema = RequestSchema.extend({
    method: external_exports.literal("resources/subscribe"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
       */
      uri: external_exports.string()
    })
  });
  var UnsubscribeRequestSchema = RequestSchema.extend({
    method: external_exports.literal("resources/unsubscribe"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to unsubscribe from.
       */
      uri: external_exports.string()
    })
  });
  var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/resources/updated"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
       */
      uri: external_exports.string()
    })
  });
  var PromptArgumentSchema = external_exports.object({
    /**
     * The name of the argument.
     */
    name: external_exports.string(),
    /**
     * A human-readable description of the argument.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * Whether this argument must be provided.
     */
    required: external_exports.optional(external_exports.boolean())
  }).passthrough();
  var PromptSchema = BaseMetadataSchema.extend({
    /**
     * An optional description of what this prompt provides
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * A list of arguments to use for templating the prompt.
     */
    arguments: external_exports.optional(external_exports.array(PromptArgumentSchema)),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  });
  var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("prompts/list")
  });
  var ListPromptsResultSchema = PaginatedResultSchema.extend({
    prompts: external_exports.array(PromptSchema)
  });
  var GetPromptRequestSchema = RequestSchema.extend({
    method: external_exports.literal("prompts/get"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The name of the prompt or prompt template.
       */
      name: external_exports.string(),
      /**
       * Arguments to use for templating the prompt.
       */
      arguments: external_exports.optional(external_exports.record(external_exports.string()))
    })
  });
  var TextContentSchema = external_exports.object({
    type: external_exports.literal("text"),
    /**
     * The text content of the message.
     */
    text: external_exports.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var ImageContentSchema = external_exports.object({
    type: external_exports.literal("image"),
    /**
     * The base64-encoded image data.
     */
    data: Base64Schema,
    /**
     * The MIME type of the image. Different providers may support different image types.
     */
    mimeType: external_exports.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var AudioContentSchema = external_exports.object({
    type: external_exports.literal("audio"),
    /**
     * The base64-encoded audio data.
     */
    data: Base64Schema,
    /**
     * The MIME type of the audio. Different providers may support different audio types.
     */
    mimeType: external_exports.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var EmbeddedResourceSchema = external_exports.object({
    type: external_exports.literal("resource"),
    resource: external_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema]),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var ResourceLinkSchema = ResourceSchema.extend({
    type: external_exports.literal("resource_link")
  });
  var ContentBlockSchema = external_exports.union([
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    ResourceLinkSchema,
    EmbeddedResourceSchema
  ]);
  var PromptMessageSchema = external_exports.object({
    role: external_exports.enum(["user", "assistant"]),
    content: ContentBlockSchema
  }).passthrough();
  var GetPromptResultSchema = ResultSchema.extend({
    /**
     * An optional description for the prompt.
     */
    description: external_exports.optional(external_exports.string()),
    messages: external_exports.array(PromptMessageSchema)
  });
  var PromptListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/prompts/list_changed")
  });
  var ToolAnnotationsSchema = external_exports.object({
    /**
     * A human-readable title for the tool.
     */
    title: external_exports.optional(external_exports.string()),
    /**
     * If true, the tool does not modify its environment.
     *
     * Default: false
     */
    readOnlyHint: external_exports.optional(external_exports.boolean()),
    /**
     * If true, the tool may perform destructive updates to its environment.
     * If false, the tool performs only additive updates.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: true
     */
    destructiveHint: external_exports.optional(external_exports.boolean()),
    /**
     * If true, calling the tool repeatedly with the same arguments
     * will have no additional effect on the its environment.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: false
     */
    idempotentHint: external_exports.optional(external_exports.boolean()),
    /**
     * If true, this tool may interact with an "open world" of external
     * entities. If false, the tool's domain of interaction is closed.
     * For example, the world of a web search tool is open, whereas that
     * of a memory tool is not.
     *
     * Default: true
     */
    openWorldHint: external_exports.optional(external_exports.boolean())
  }).passthrough();
  var ToolSchema = BaseMetadataSchema.extend({
    /**
     * A human-readable description of the tool.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * A JSON Schema object defining the expected parameters for the tool.
     */
    inputSchema: external_exports.object({
      type: external_exports.literal("object"),
      properties: external_exports.optional(external_exports.object({}).passthrough()),
      required: external_exports.optional(external_exports.array(external_exports.string()))
    }).passthrough(),
    /**
     * An optional JSON Schema object defining the structure of the tool's output returned in
     * the structuredContent field of a CallToolResult.
     */
    outputSchema: external_exports.optional(external_exports.object({
      type: external_exports.literal("object"),
      properties: external_exports.optional(external_exports.object({}).passthrough()),
      required: external_exports.optional(external_exports.array(external_exports.string()))
    }).passthrough()),
    /**
     * Optional additional tool information.
     */
    annotations: external_exports.optional(ToolAnnotationsSchema),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  });
  var ListToolsRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("tools/list")
  });
  var ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: external_exports.array(ToolSchema)
  });
  var CallToolResultSchema = ResultSchema.extend({
    /**
     * A list of content objects that represent the result of the tool call.
     *
     * If the Tool does not define an outputSchema, this field MUST be present in the result.
     * For backwards compatibility, this field is always present, but it may be empty.
     */
    content: external_exports.array(ContentBlockSchema).default([]),
    /**
     * An object containing structured tool output.
     *
     * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
     */
    structuredContent: external_exports.object({}).passthrough().optional(),
    /**
     * Whether the tool call ended in an error.
     *
     * If not set, this is assumed to be false (the call was successful).
     *
     * Any errors that originate from the tool SHOULD be reported inside the result
     * object, with `isError` set to true, _not_ as an MCP protocol-level error
     * response. Otherwise, the LLM would not be able to see that an error occurred
     * and self-correct.
     *
     * However, any errors in _finding_ the tool, an error indicating that the
     * server does not support tool calls, or any other exceptional conditions,
     * should be reported as an MCP error response.
     */
    isError: external_exports.optional(external_exports.boolean())
  });
  var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
    toolResult: external_exports.unknown()
  }));
  var CallToolRequestSchema = RequestSchema.extend({
    method: external_exports.literal("tools/call"),
    params: BaseRequestParamsSchema.extend({
      name: external_exports.string(),
      arguments: external_exports.optional(external_exports.record(external_exports.unknown()))
    })
  });
  var ToolListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/tools/list_changed")
  });
  var LoggingLevelSchema = external_exports.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency"
  ]);
  var SetLevelRequestSchema = RequestSchema.extend({
    method: external_exports.literal("logging/setLevel"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
       */
      level: LoggingLevelSchema
    })
  });
  var LoggingMessageNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/message"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The severity of this log message.
       */
      level: LoggingLevelSchema,
      /**
       * An optional name of the logger issuing this message.
       */
      logger: external_exports.optional(external_exports.string()),
      /**
       * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
       */
      data: external_exports.unknown()
    })
  });
  var ModelHintSchema = external_exports.object({
    /**
     * A hint for a model name.
     */
    name: external_exports.string().optional()
  }).passthrough();
  var ModelPreferencesSchema = external_exports.object({
    /**
     * Optional hints to use for model selection.
     */
    hints: external_exports.optional(external_exports.array(ModelHintSchema)),
    /**
     * How much to prioritize cost when selecting a model.
     */
    costPriority: external_exports.optional(external_exports.number().min(0).max(1)),
    /**
     * How much to prioritize sampling speed (latency) when selecting a model.
     */
    speedPriority: external_exports.optional(external_exports.number().min(0).max(1)),
    /**
     * How much to prioritize intelligence and capabilities when selecting a model.
     */
    intelligencePriority: external_exports.optional(external_exports.number().min(0).max(1))
  }).passthrough();
  var SamplingMessageSchema = external_exports.object({
    role: external_exports.enum(["user", "assistant"]),
    content: external_exports.union([TextContentSchema, ImageContentSchema, AudioContentSchema])
  }).passthrough();
  var CreateMessageRequestSchema = RequestSchema.extend({
    method: external_exports.literal("sampling/createMessage"),
    params: BaseRequestParamsSchema.extend({
      messages: external_exports.array(SamplingMessageSchema),
      /**
       * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
       */
      systemPrompt: external_exports.optional(external_exports.string()),
      /**
       * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
       */
      includeContext: external_exports.optional(external_exports.enum(["none", "thisServer", "allServers"])),
      temperature: external_exports.optional(external_exports.number()),
      /**
       * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
       */
      maxTokens: external_exports.number().int(),
      stopSequences: external_exports.optional(external_exports.array(external_exports.string())),
      /**
       * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
       */
      metadata: external_exports.optional(external_exports.object({}).passthrough()),
      /**
       * The server's preferences for which model to select.
       */
      modelPreferences: external_exports.optional(ModelPreferencesSchema)
    })
  });
  var CreateMessageResultSchema = ResultSchema.extend({
    /**
     * The name of the model that generated the message.
     */
    model: external_exports.string(),
    /**
     * The reason why sampling stopped.
     */
    stopReason: external_exports.optional(external_exports.enum(["endTurn", "stopSequence", "maxTokens"]).or(external_exports.string())),
    role: external_exports.enum(["user", "assistant"]),
    content: external_exports.discriminatedUnion("type", [
      TextContentSchema,
      ImageContentSchema,
      AudioContentSchema
    ])
  });
  var BooleanSchemaSchema = external_exports.object({
    type: external_exports.literal("boolean"),
    title: external_exports.optional(external_exports.string()),
    description: external_exports.optional(external_exports.string()),
    default: external_exports.optional(external_exports.boolean())
  }).passthrough();
  var StringSchemaSchema = external_exports.object({
    type: external_exports.literal("string"),
    title: external_exports.optional(external_exports.string()),
    description: external_exports.optional(external_exports.string()),
    minLength: external_exports.optional(external_exports.number()),
    maxLength: external_exports.optional(external_exports.number()),
    format: external_exports.optional(external_exports.enum(["email", "uri", "date", "date-time"]))
  }).passthrough();
  var NumberSchemaSchema = external_exports.object({
    type: external_exports.enum(["number", "integer"]),
    title: external_exports.optional(external_exports.string()),
    description: external_exports.optional(external_exports.string()),
    minimum: external_exports.optional(external_exports.number()),
    maximum: external_exports.optional(external_exports.number())
  }).passthrough();
  var EnumSchemaSchema = external_exports.object({
    type: external_exports.literal("string"),
    title: external_exports.optional(external_exports.string()),
    description: external_exports.optional(external_exports.string()),
    enum: external_exports.array(external_exports.string()),
    enumNames: external_exports.optional(external_exports.array(external_exports.string()))
  }).passthrough();
  var PrimitiveSchemaDefinitionSchema = external_exports.union([
    BooleanSchemaSchema,
    StringSchemaSchema,
    NumberSchemaSchema,
    EnumSchemaSchema
  ]);
  var ElicitRequestSchema = RequestSchema.extend({
    method: external_exports.literal("elicitation/create"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The message to present to the user.
       */
      message: external_exports.string(),
      /**
       * The schema for the requested user input.
       */
      requestedSchema: external_exports.object({
        type: external_exports.literal("object"),
        properties: external_exports.record(external_exports.string(), PrimitiveSchemaDefinitionSchema),
        required: external_exports.optional(external_exports.array(external_exports.string()))
      }).passthrough()
    })
  });
  var ElicitResultSchema = ResultSchema.extend({
    /**
     * The user's response action.
     */
    action: external_exports.enum(["accept", "decline", "cancel"]),
    /**
     * The collected user input content (only present if action is "accept").
     */
    content: external_exports.optional(external_exports.record(external_exports.string(), external_exports.unknown()))
  });
  var ResourceTemplateReferenceSchema = external_exports.object({
    type: external_exports.literal("ref/resource"),
    /**
     * The URI or URI template of the resource.
     */
    uri: external_exports.string()
  }).passthrough();
  var PromptReferenceSchema = external_exports.object({
    type: external_exports.literal("ref/prompt"),
    /**
     * The name of the prompt or prompt template
     */
    name: external_exports.string()
  }).passthrough();
  var CompleteRequestSchema = RequestSchema.extend({
    method: external_exports.literal("completion/complete"),
    params: BaseRequestParamsSchema.extend({
      ref: external_exports.union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
      /**
       * The argument's information
       */
      argument: external_exports.object({
        /**
         * The name of the argument
         */
        name: external_exports.string(),
        /**
         * The value of the argument to use for completion matching.
         */
        value: external_exports.string()
      }).passthrough(),
      context: external_exports.optional(external_exports.object({
        /**
         * Previously-resolved variables in a URI template or prompt.
         */
        arguments: external_exports.optional(external_exports.record(external_exports.string(), external_exports.string()))
      }))
    })
  });
  var CompleteResultSchema = ResultSchema.extend({
    completion: external_exports.object({
      /**
       * An array of completion values. Must not exceed 100 items.
       */
      values: external_exports.array(external_exports.string()).max(100),
      /**
       * The total number of completion options available. This can exceed the number of values actually sent in the response.
       */
      total: external_exports.optional(external_exports.number().int()),
      /**
       * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
       */
      hasMore: external_exports.optional(external_exports.boolean())
    }).passthrough()
  });
  var RootSchema = external_exports.object({
    /**
     * The URI identifying the root. This *must* start with file:// for now.
     */
    uri: external_exports.string().startsWith("file://"),
    /**
     * An optional name for the root.
     */
    name: external_exports.optional(external_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var ListRootsRequestSchema = RequestSchema.extend({
    method: external_exports.literal("roots/list")
  });
  var ListRootsResultSchema = ResultSchema.extend({
    roots: external_exports.array(RootSchema)
  });
  var RootsListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/roots/list_changed")
  });
  var ClientRequestSchema = external_exports.union([
    PingRequestSchema,
    InitializeRequestSchema,
    CompleteRequestSchema,
    SetLevelRequestSchema,
    GetPromptRequestSchema,
    ListPromptsRequestSchema,
    ListResourcesRequestSchema,
    ListResourceTemplatesRequestSchema,
    ReadResourceRequestSchema,
    SubscribeRequestSchema,
    UnsubscribeRequestSchema,
    CallToolRequestSchema,
    ListToolsRequestSchema
  ]);
  var ClientNotificationSchema = external_exports.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    InitializedNotificationSchema,
    RootsListChangedNotificationSchema
  ]);
  var ClientResultSchema = external_exports.union([
    EmptyResultSchema,
    CreateMessageResultSchema,
    ElicitResultSchema,
    ListRootsResultSchema
  ]);
  var ServerRequestSchema = external_exports.union([
    PingRequestSchema,
    CreateMessageRequestSchema,
    ElicitRequestSchema,
    ListRootsRequestSchema
  ]);
  var ServerNotificationSchema = external_exports.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    LoggingMessageNotificationSchema,
    ResourceUpdatedNotificationSchema,
    ResourceListChangedNotificationSchema,
    ToolListChangedNotificationSchema,
    PromptListChangedNotificationSchema
  ]);
  var ServerResultSchema = external_exports.union([
    EmptyResultSchema,
    InitializeResultSchema,
    CompleteResultSchema,
    GetPromptResultSchema,
    ListPromptsResultSchema,
    ListResourcesResultSchema,
    ListResourceTemplatesResultSchema,
    ReadResourceResultSchema,
    CallToolResultSchema,
    ListToolsResultSchema
  ]);
  var McpError = class extends Error {
    constructor(code, message, data) {
      super(`MCP error ${code}: ${message}`);
      this.code = code;
      this.data = data;
      this.name = "McpError";
    }
  };

  // node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
  var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
  var Protocol = class {
    constructor(_options) {
      this._options = _options;
      this._requestMessageId = 0;
      this._requestHandlers = /* @__PURE__ */ new Map();
      this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
      this._notificationHandlers = /* @__PURE__ */ new Map();
      this._responseHandlers = /* @__PURE__ */ new Map();
      this._progressHandlers = /* @__PURE__ */ new Map();
      this._timeoutInfo = /* @__PURE__ */ new Map();
      this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
      this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
        const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
        controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);
      });
      this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
        this._onprogress(notification);
      });
      this.setRequestHandler(
        PingRequestSchema,
        // Automatic pong by default.
        (_request) => ({})
      );
    }
    _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
      this._timeoutInfo.set(messageId, {
        timeoutId: setTimeout(onTimeout, timeout),
        startTime: Date.now(),
        timeout,
        maxTotalTimeout,
        resetTimeoutOnProgress,
        onTimeout
      });
    }
    _resetTimeout(messageId) {
      const info = this._timeoutInfo.get(messageId);
      if (!info)
        return false;
      const totalElapsed = Date.now() - info.startTime;
      if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
        this._timeoutInfo.delete(messageId);
        throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: info.maxTotalTimeout, totalElapsed });
      }
      clearTimeout(info.timeoutId);
      info.timeoutId = setTimeout(info.onTimeout, info.timeout);
      return true;
    }
    _cleanupTimeout(messageId) {
      const info = this._timeoutInfo.get(messageId);
      if (info) {
        clearTimeout(info.timeoutId);
        this._timeoutInfo.delete(messageId);
      }
    }
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */
    connect(transport) {
      return __async(this, null, function* () {
        var _a, _b, _c;
        this._transport = transport;
        const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
        this._transport.onclose = () => {
          _onclose === null || _onclose === void 0 ? void 0 : _onclose();
          this._onclose();
        };
        const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
        this._transport.onerror = (error) => {
          _onerror === null || _onerror === void 0 ? void 0 : _onerror(error);
          this._onerror(error);
        };
        const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
        this._transport.onmessage = (message, extra) => {
          _onmessage === null || _onmessage === void 0 ? void 0 : _onmessage(message, extra);
          if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
            this._onresponse(message);
          } else if (isJSONRPCRequest(message)) {
            this._onrequest(message, extra);
          } else if (isJSONRPCNotification(message)) {
            this._onnotification(message);
          } else {
            this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
          }
        };
        yield this._transport.start();
      });
    }
    _onclose() {
      var _a;
      const responseHandlers = this._responseHandlers;
      this._responseHandlers = /* @__PURE__ */ new Map();
      this._progressHandlers.clear();
      this._pendingDebouncedNotifications.clear();
      this._transport = void 0;
      (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);
      const error = new McpError(ErrorCode.ConnectionClosed, "Connection closed");
      for (const handler of responseHandlers.values()) {
        handler(error);
      }
    }
    _onerror(error) {
      var _a;
      (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
    }
    _onnotification(notification) {
      var _a;
      const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
      if (handler === void 0) {
        return;
      }
      Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
    }
    _onrequest(request, extra) {
      var _a, _b, _c, _d;
      const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
      if (handler === void 0) {
        (_b = this._transport) === null || _b === void 0 ? void 0 : _b.send({
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: ErrorCode.MethodNotFound,
            message: "Method not found"
          }
        }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
        return;
      }
      const abortController = new AbortController();
      this._requestHandlerAbortControllers.set(request.id, abortController);
      const fullExtra = {
        signal: abortController.signal,
        sessionId: (_c = this._transport) === null || _c === void 0 ? void 0 : _c.sessionId,
        _meta: (_d = request.params) === null || _d === void 0 ? void 0 : _d._meta,
        sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),
        sendRequest: (r2, resultSchema, options) => this.request(r2, resultSchema, __spreadProps(__spreadValues({}, options), { relatedRequestId: request.id })),
        authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
        requestId: request.id,
        requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
      };
      Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {
        var _a2;
        if (abortController.signal.aborted) {
          return;
        }
        return (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
          result,
          jsonrpc: "2.0",
          id: request.id
        });
      }, (error) => {
        var _a2, _b2;
        if (abortController.signal.aborted) {
          return;
        }
        return (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
            message: (_b2 = error.message) !== null && _b2 !== void 0 ? _b2 : "Internal error"
          }
        });
      }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
        this._requestHandlerAbortControllers.delete(request.id);
      });
    }
    _onprogress(notification) {
      const _a = notification.params, { progressToken } = _a, params = __objRest(_a, ["progressToken"]);
      const messageId = Number(progressToken);
      const handler = this._progressHandlers.get(messageId);
      if (!handler) {
        this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
        return;
      }
      const responseHandler = this._responseHandlers.get(messageId);
      const timeoutInfo = this._timeoutInfo.get(messageId);
      if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
        try {
          this._resetTimeout(messageId);
        } catch (error) {
          responseHandler(error);
          return;
        }
      }
      handler(params);
    }
    _onresponse(response) {
      const messageId = Number(response.id);
      const handler = this._responseHandlers.get(messageId);
      if (handler === void 0) {
        this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
        return;
      }
      this._responseHandlers.delete(messageId);
      this._progressHandlers.delete(messageId);
      this._cleanupTimeout(messageId);
      if (isJSONRPCResponse(response)) {
        handler(response);
      } else {
        const error = new McpError(response.error.code, response.error.message, response.error.data);
        handler(error);
      }
    }
    get transport() {
      return this._transport;
    }
    /**
     * Closes the connection.
     */
    close() {
      return __async(this, null, function* () {
        var _a;
        yield (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
      });
    }
    /**
     * Sends a request and wait for a response.
     *
     * Do not use this method to emit notifications! Use notification() instead.
     */
    request(request, resultSchema, options) {
      const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
      return new Promise((resolve, reject) => {
        var _a, _b, _c, _d, _e2, _f;
        if (!this._transport) {
          reject(new Error("Not connected"));
          return;
        }
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) {
          this.assertCapabilityForMethod(request.method);
        }
        (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
        const messageId = this._requestMessageId++;
        const jsonrpcRequest = __spreadProps(__spreadValues({}, request), {
          jsonrpc: "2.0",
          id: messageId
        });
        if (options === null || options === void 0 ? void 0 : options.onprogress) {
          this._progressHandlers.set(messageId, options.onprogress);
          jsonrpcRequest.params = __spreadProps(__spreadValues({}, request.params), {
            _meta: __spreadProps(__spreadValues({}, ((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {}), {
              progressToken: messageId
            })
          });
        }
        const cancel = (reason) => {
          var _a2;
          this._responseHandlers.delete(messageId);
          this._progressHandlers.delete(messageId);
          this._cleanupTimeout(messageId);
          (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
            jsonrpc: "2.0",
            method: "notifications/cancelled",
            params: {
              requestId: messageId,
              reason: String(reason)
            }
          }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
          reject(reason);
        };
        this._responseHandlers.set(messageId, (response) => {
          var _a2;
          if ((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            return;
          }
          if (response instanceof Error) {
            return reject(response);
          }
          try {
            const result = resultSchema.parse(response.result);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        });
        (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.addEventListener("abort", () => {
          var _a2;
          cancel((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.reason);
        });
        const timeout = (_e2 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e2 !== void 0 ? _e2 : DEFAULT_REQUEST_TIMEOUT_MSEC;
        const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
        this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      });
    }
    /**
     * Emits a notification, which is a one-way message that does not expect a response.
     */
    notification(notification, options) {
      return __async(this, null, function* () {
        var _a, _b;
        if (!this._transport) {
          throw new Error("Not connected");
        }
        this.assertNotificationCapability(notification.method);
        const debouncedMethods = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : [];
        const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId);
        if (canDebounce) {
          if (this._pendingDebouncedNotifications.has(notification.method)) {
            return;
          }
          this._pendingDebouncedNotifications.add(notification.method);
          Promise.resolve().then(() => {
            var _a2;
            this._pendingDebouncedNotifications.delete(notification.method);
            if (!this._transport) {
              return;
            }
            const jsonrpcNotification2 = __spreadProps(__spreadValues({}, notification), {
              jsonrpc: "2.0"
            });
            (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));
          });
          return;
        }
        const jsonrpcNotification = __spreadProps(__spreadValues({}, notification), {
          jsonrpc: "2.0"
        });
        yield this._transport.send(jsonrpcNotification, options);
      });
    }
    /**
     * Registers a handler to invoke when this protocol object receives a request with the given method.
     *
     * Note that this will replace any previous request handler for the same method.
     */
    setRequestHandler(requestSchema, handler) {
      const method = requestSchema.shape.method.value;
      this.assertRequestHandlerCapability(method);
      this._requestHandlers.set(method, (request, extra) => {
        return Promise.resolve(handler(requestSchema.parse(request), extra));
      });
    }
    /**
     * Removes the request handler for the given method.
     */
    removeRequestHandler(method) {
      this._requestHandlers.delete(method);
    }
    /**
     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
     */
    assertCanSetRequestHandler(method) {
      if (this._requestHandlers.has(method)) {
        throw new Error(`A request handler for ${method} already exists, which would be overridden`);
      }
    }
    /**
     * Registers a handler to invoke when this protocol object receives a notification with the given method.
     *
     * Note that this will replace any previous notification handler for the same method.
     */
    setNotificationHandler(notificationSchema, handler) {
      this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
    }
    /**
     * Removes the notification handler for the given method.
     */
    removeNotificationHandler(method) {
      this._notificationHandlers.delete(method);
    }
  };
  function mergeCapabilities(base, additional) {
    return Object.entries(additional).reduce((acc, [key, value]) => {
      if (value && typeof value === "object") {
        acc[key] = acc[key] ? __spreadValues(__spreadValues({}, acc[key]), value) : value;
      } else {
        acc[key] = value;
      }
      return acc;
    }, __spreadValues({}, base));
  }

  // node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
  var import_ajv = __toESM(require_ajv(), 1);
  var Server = class extends Protocol {
    /**
     * Initializes this server with the given name and version information.
     */
    constructor(_serverInfo, options) {
      var _a;
      super(options);
      this._serverInfo = _serverInfo;
      this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
      this._instructions = options === null || options === void 0 ? void 0 : options.instructions;
      this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
      this.setNotificationHandler(InitializedNotificationSchema, () => {
        var _a2;
        return (_a2 = this.oninitialized) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      });
    }
    /**
     * Registers new capabilities. This can only be called before connecting to a transport.
     *
     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
     */
    registerCapabilities(capabilities) {
      if (this.transport) {
        throw new Error("Cannot register capabilities after connecting to transport");
      }
      this._capabilities = mergeCapabilities(this._capabilities, capabilities);
    }
    assertCapabilityForMethod(method) {
      var _a, _b, _c;
      switch (method) {
        case "sampling/createMessage":
          if (!((_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling)) {
            throw new Error(`Client does not support sampling (required for ${method})`);
          }
          break;
        case "elicitation/create":
          if (!((_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation)) {
            throw new Error(`Client does not support elicitation (required for ${method})`);
          }
          break;
        case "roots/list":
          if (!((_c = this._clientCapabilities) === null || _c === void 0 ? void 0 : _c.roots)) {
            throw new Error(`Client does not support listing roots (required for ${method})`);
          }
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(method) {
      switch (method) {
        case "notifications/message":
          if (!this._capabilities.logging) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources) {
            throw new Error(`Server does not support notifying about resources (required for ${method})`);
          }
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools) {
            throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
          }
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts) {
            throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
          }
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(method) {
      switch (method) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling) {
            throw new Error(`Server does not support sampling (required for ${method})`);
          }
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts) {
            throw new Error(`Server does not support prompts (required for ${method})`);
          }
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources) {
            throw new Error(`Server does not support resources (required for ${method})`);
          }
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools) {
            throw new Error(`Server does not support tools (required for ${method})`);
          }
          break;
        case "ping":
        case "initialize":
          break;
      }
    }
    _oninitialize(request) {
      return __async(this, null, function* () {
        const requestedVersion = request.params.protocolVersion;
        this._clientCapabilities = request.params.capabilities;
        this._clientVersion = request.params.clientInfo;
        const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;
        return __spreadValues({
          protocolVersion,
          capabilities: this.getCapabilities(),
          serverInfo: this._serverInfo
        }, this._instructions && { instructions: this._instructions });
      });
    }
    /**
     * After initialization has completed, this will be populated with the client's reported capabilities.
     */
    getClientCapabilities() {
      return this._clientCapabilities;
    }
    /**
     * After initialization has completed, this will be populated with information about the client's name and version.
     */
    getClientVersion() {
      return this._clientVersion;
    }
    getCapabilities() {
      return this._capabilities;
    }
    ping() {
      return __async(this, null, function* () {
        return this.request({ method: "ping" }, EmptyResultSchema);
      });
    }
    createMessage(params, options) {
      return __async(this, null, function* () {
        return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
      });
    }
    elicitInput(params, options) {
      return __async(this, null, function* () {
        const result = yield this.request({ method: "elicitation/create", params }, ElicitResultSchema, options);
        if (result.action === "accept" && result.content) {
          try {
            const ajv = new import_ajv.default();
            const validate = ajv.compile(params.requestedSchema);
            const isValid2 = validate(result.content);
            if (!isValid2) {
              throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${ajv.errorsText(validate.errors)}`);
            }
          } catch (error) {
            if (error instanceof McpError) {
              throw error;
            }
            throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error}`);
          }
        }
        return result;
      });
    }
    listRoots(params, options) {
      return __async(this, null, function* () {
        return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
      });
    }
    sendLoggingMessage(params) {
      return __async(this, null, function* () {
        return this.notification({ method: "notifications/message", params });
      });
    }
    sendResourceUpdated(params) {
      return __async(this, null, function* () {
        return this.notification({
          method: "notifications/resources/updated",
          params
        });
      });
    }
    sendResourceListChanged() {
      return __async(this, null, function* () {
        return this.notification({
          method: "notifications/resources/list_changed"
        });
      });
    }
    sendToolListChanged() {
      return __async(this, null, function* () {
        return this.notification({ method: "notifications/tools/list_changed" });
      });
    }
    sendPromptListChanged() {
      return __async(this, null, function* () {
        return this.notification({ method: "notifications/prompts/list_changed" });
      });
    }
  };

  // src/wordpress-integrations/angie/tools-data.json
  var tools_data_default = [
    {
      name: "tec-calendar-create-update-entities",
      description: 'Create or update a calendar post (Event, Venue, Organizer, or Ticket).\n\nFor creating: provide postType and data.\nFor updating: provide postType, id, and data.\n\n**FREE TICKETS**: To create free tickets, omit the price field entirely. WordPress will automatically default to price 0. Do NOT set price to 0 explicitly as this triggers validation errors. Both Tickets Commerce and RSVP providers support free tickets when the price field is omitted.\n\n**TICKET AVAILABILITY DATES**: Use start_date and end_date fields to control when tickets are available for purchase. start_date is when tickets become available, end_date is when sales stop (typically the event start time). All ticket date fields must be in Y-m-d H:i:s format (e.g., "2024-12-25 15:30:00"). If not provided, defaults to 1 week before event (start) and event start time (end). By default, end_date will be capped to the event start unless you pass allow_end_after_event: true.\n\n**SALE PRICING**: To offer tickets at a reduced price during specific periods:\n- price: Regular ticket price\n- sale_price: Discounted price (must be less than regular price)\n- sale_price_start_date: When the sale price becomes active\n- sale_price_end_date: When the sale price expires (reverts to regular price)\n\nExample: Regular $50 ticket on sale for $35 from Dec 1-15:\n```json\n{\n  "price": 50,\n  "sale_price": 35,\n  "sale_price_start_date": "2024-12-01",\n  "sale_price_end_date": "2024-12-15"\n}\n```\n\n**NOTE**: Ticket availability dates (start_date, end_date) must be provided in Y-m-d H:i:s format. Sale price dates (sale_price_start_date, sale_price_end_date) must be provided in YYYY-MM-DD format.\n**UNLIMITED TICKETS**: To create unlimited tickets, set stock_mode to "unlimited".\n\n**IMPORTANT**: Ensure your event dates and times use the expected formats and timezone context.\n\n### Date Formats Supported\n\n- **ISO 8601**: `"2024-12-25T15:00:00"`\n- **Date and time**: `"2024-12-25 15:00:00"`\n- **Natural language**: `"tomorrow 2pm"`, `"next monday"`, `"first thursday of next month"`\n- **Relative**: `"+3 days"`, `"+2 hours"`, `"3 days 1 hour"`\n- **Specific dates**: `"December 15, 2024 7:00 PM"`\n\n### Workflow for Events with Dates\n\n1. Calculate appropriate dates for your event\n2. Create/update event with calculated dates\n\n### Create Examples\n\n#### Event Creation\n\nThe Events Calendar event post type with date, location, and ticketing information\n\n**Example 1: Standard event with ISO dates**\n```json\n{\n  "postType": "event",\n  "data": {\n    "title": "Conference Next Week",\n    "start_date": "next monday 9am",\n    "end_date": "next friday 5pm",\n    "all_day": false,\n    "timezone": "America/New_York",\n    "venues": [\n      456\n    ],\n    "organizers": [\n      789\n    ]\n  }\n}\n```\n\n**Example 2: Event with natural language dates**\n```json\n{\n  "postType": "event",\n  "data": {\n    "title": "Holiday Party",\n    "start_date": "December 15, 2024 7:00 PM",\n    "end_date": "December 15, 2024 11:30 PM",\n    "all_day": false,\n    "timezone": "America/Denver",\n    "venues": [\n      789\n    ],\n    "cost": "$25 per person"\n  }\n}\n```\n\n**Example 3: All-day event**\n```json\n{\n  "postType": "event",\n  "data": {\n    "title": "All Day Workshop",\n    "start_date": "tomorrow",\n    "end_date": "tomorrow",\n    "all_day": true,\n    "timezone": "Europe/London",\n    "cost": "Free"\n  }\n}\n```\n\n**Example 4: Event with venue and organizers**\n```json\n{\n  "postType": "event",\n  "data": {\n    "title": "Summer Music Festival",\n    "start_date": "2024-07-15 18:00:00",\n    "end_date": "2024-07-15 23:00:00",\n    "all_day": false,\n    "timezone": "America/Los_Angeles"\n  }\n}\n```\n\n#### Venue Creation\n\nLocation where events take place, including address and contact information\n\n**Example 1: Complete venue with address**\n```json\n{\n  "postType": "venue",\n  "data": {\n    "title": "The Grand Ballroom",\n    "venue": "Grand Ballroom at the Historic Hotel",\n    "address": "456 Park Avenue",\n    "city": "New York",\n    "state": "NY",\n    "zip": "10022",\n    "country": "USA",\n    "phone": "+1 (212) 555-0123",\n    "website": "https://grandballroom.example.com"\n  }\n}\n```\n\n**Example 2: Virtual/online venue**\n```json\n{\n  "postType": "venue",\n  "data": {\n    "title": "Beachside Resort",\n    "venue": "Sunset Beach Resort & Spa",\n    "address": "1000 Coastal Highway",\n    "city": "Miami Beach",\n    "state": "FL",\n    "zip": "33139",\n    "country": "US",\n    "phone": "305-555-BEACH",\n    "website": "https://sunsetbeachresort.example.com",\n    "geo_lat": 25.7906,\n    "geo_lng": -80.13\n  }\n}\n```\n\n#### Organizer Creation\n\nPerson or organization responsible for hosting events\n\n**Example 1: Organization with full contact**\n```json\n{\n  "postType": "organizer",\n  "data": {\n    "title": "Local Arts Council",\n    "email": "info@localartscouncil.org",\n    "website": "https://localartscouncil.org",\n    "phone": "(555) 123-4567"\n  }\n}\n```\n\n**Example 2: Individual organizer**\n```json\n{\n  "postType": "organizer",\n  "data": {\n    "title": "DJ Mike Stevens",\n    "organizer": "Mike Stevens - Professional DJ",\n    "email": "bookings@djmikestevens.com",\n    "phone": "+1-555-DJ-MIKE",\n    "website": "https://djmikestevens.example.com"\n  }\n}\n```\n\n#### Ticket Creation\n\nEvent ticket as returned by the API, including read-only fields like sold count and calculated values.\n\n**Example 1: Paid general admission**\n```json\n{\n  "postType": "ticket",\n  "data": {\n    "title": "General Admission",\n    "event": 123,\n    "price": 25,\n    "stock": 100,\n    "capacity": 100,\n    "sku": "GA-2024-001"\n  }\n}\n```\n\n**Example 2: VIP ticket with limited availability**\n```json\n{\n  "postType": "ticket",\n  "data": {\n    "title": "VIP Pass",\n    "event": 123,\n    "price": 150,\n    "stock": 20,\n    "capacity": 30,\n    "sku": "VIP-2024-001"\n  }\n}\n```\n\n### Update Examples\n\n#### Updating Events\n\nThe Events Calendar event post type with date, location, and ticketing information\n\n**Partial update example 1**\n```json\n{\n  "postType": "event",\n  "id": 124,\n  "data": {\n    "title": "Conference Next Week",\n    "start_date": "next monday 9am",\n    "end_date": "next friday 5pm"\n  }\n}\n```\n\n**Partial update example 2**\n```json\n{\n  "postType": "event",\n  "id": 127,\n  "data": {\n    "title": "Holiday Party",\n    "start_date": "December 15, 2024 7:00 PM",\n    "end_date": "December 15, 2024 11:30 PM"\n  }\n}\n```\n\n#### Updating Venues\n\nLocation where events take place, including address and contact information\n\n**Partial update example 1**\n```json\n{\n  "postType": "venue",\n  "id": 457,\n  "data": {\n    "address": "456 Park Avenue",\n    "city": "New York",\n    "phone": "+1 (212) 555-0123"\n  }\n}\n```\n\n**Partial update example 2**\n```json\n{\n  "postType": "venue",\n  "id": 461,\n  "data": {\n    "address": "1000 Coastal Highway",\n    "city": "Miami Beach",\n    "phone": "305-555-BEACH"\n  }\n}\n```\n',
      inputSchema: {
        type: "object",
        properties: {
          postType: {
            type: "string",
            enum: [
              "event",
              "venue",
              "organizer",
              "ticket"
            ],
            description: "The type of post to create or update"
          },
          id: {
            type: "number",
            description: "Post ID (required for updates, omit for creation)"
          },
          data: {
            type: "object",
            description: 'The post data. Required fields depend on postType: Event (title, start_date, end_date), Venue (title or venue, address, city, country), Organizer (title or organizer), Ticket (title, event_id or event). Note: For Venue and Organizer, you can use "title" which will be converted to the appropriate field. For Tickets, all date fields must be in Y-m-d H:i:s format (e.g., "2024-12-25 15:30:00"). Sales dates default to 1 week before event (start) and event start date (end) if not specified. By default, ticket end_date will be capped to the event start date unless allow_end_after_event: true is provided.',
            additionalProperties: true
          }
        },
        required: [
          "postType",
          "data"
        ],
        additionalProperties: false
      },
      annotations: {
        title: "Create or Update Calendar Entities",
        readOnlyHint: false,
        destructiveHint: false,
        idempotentHint: true,
        openWorldHint: false
      }
    },
    {
      name: "tec-calendar-read-entities",
      description: 'Read, list, or search calendar posts.\n\n### Use Cases\n\n1. **Get single post**: provide postType and id\n2. **List all posts**: provide postType only\n3. **Search posts**: provide postType and query\n\n### Query Capabilities\n\n- Get single post by ID\n- List all posts with pagination\n- Search posts by keyword\n- Filter by post-specific criteria\n- Combine multiple filters\n\n## Examples\n\n### Basic Queries\n\n**1. Get specific event by ID**\n```json\n{ "postType": "event", "id": 123 }\n```\n\n**2. List all venues with pagination**\n```json\n{ "postType": "venue", "per_page": 20, "page": 1 }\n```\n\n**3. Search events by keyword**\n```json\n{ "postType": "event", "search": "conference" }\n```\n\n**4. Get all organizers sorted by name**\n```json\n{ "postType": "organizer", "orderby": "title", "order": "asc" }\n```\n\n### Date Filtering\n\n**5. Get upcoming events**\n```json\n{\n  "postType": "event",\n  "eventFilters": {\n    "start_date": "2024-12-06"\n  }\n}\n```\n\n**6. Get events in date range**\n```json\n{\n  "postType": "event",\n  "eventFilters": {\n    "start_date": "2024-12-01",\n    "end_date": "2024-12-31"\n  }\n}\n```\n\n### Location Filtering\n\n**7. Find venues by city and state**\n```json\n{\n  "postType": "venue",\n  "venueFilters": {\n    "city": "San Francisco",\n    "state": "CA"\n  }\n}\n```\n\n**8. Find venues near coordinates**\n```json\n{\n  "postType": "venue",\n  "venueFilters": {\n    "geo_lat": 37.7749,\n    "geo_lng": -122.4194,\n    "radius": 10\n  }\n}\n```\n\n### Relationship Queries\n\n**9. Get events at specific venue**\n```json\n{ "postType": "event", "eventFilters": { "venue": 456 } }\n```\n\n**10. Get tickets for specific event**\n```json\n{ "postType": "ticket", "ticketFilters": { "event": 123 } }\n```\n\n**11. Get available tickets only**\n```json\n{\n  "postType": "ticket",\n  "ticketFilters": {\n    "event": 123,\n    "available": true\n  }\n}\n```\n\n### Status & Filtering\n\n**12. Get only published events**\n```json\n{ "postType": "event", "status": "publish" }\n```\n\n**13. Get draft and pending venues**\n```json\n{ "postType": "venue", "status": ["draft", "pending"] }\n```\n\n### Complex Queries\n\n**14. Search published events at venues with dates**\n```json\n{\n  "postType": "event",\n  "search": "workshop",\n  "status": "publish",\n  "eventFilters": {\n    "venue": 456,\n    "start_date": "2024-12-01"\n  },\n  "per_page": 50\n}\n```\n\n**15. Get tickets under $50 sorted by price**\n```json\n{\n  "postType": "ticket",\n  "ticketFilters": {\n    "max_price": 50,\n    "available": true\n  },\n  "orderby": "price",\n  "order": "asc"\n}\n```\n\n### Available Filters\n\n- **eventFilters**: venue, organizer, featured, categories, tags\n- **venueFilters**: city, state, country, zip, geo_lat/lng, radius\n- **ticketFilters**: event, type, provider, min/max_price\n- **organizerFilters**: email, website, phone\n- **Common**: status, search, include, exclude, page, per_page, orderby',
      inputSchema: {
        type: "object",
        properties: {
          postType: {
            type: "string",
            enum: [
              "event",
              "venue",
              "organizer",
              "ticket"
            ],
            description: "The type of post to read"
          },
          id: {
            type: "number",
            description: "Post ID for single post retrieval"
          },
          query: {
            type: "string",
            description: "Search query string"
          },
          page: {
            type: "number",
            description: "Page number"
          },
          per_page: {
            type: "number",
            description: "Items per page"
          },
          order: {
            type: "string",
            enum: [
              "asc",
              "desc"
            ],
            description: "Sort order"
          },
          orderby: {
            type: "string",
            description: "Field to order by"
          },
          status: {
            oneOf: [
              {
                type: "string"
              },
              {
                type: "array",
                items: {
                  type: "string"
                }
              }
            ],
            description: "Post status filter"
          },
          include: {
            type: "array",
            items: {
              type: "number"
            },
            description: "Include specific IDs"
          },
          exclude: {
            type: "array",
            items: {
              type: "number"
            },
            description: "Exclude specific IDs"
          },
          eventFilters: {
            type: "object",
            description: 'Event-specific filters (only used when postType is "event")',
            properties: {
              start_date: {
                type: "string",
                description: "Event start date filter (YYYY-MM-DD)."
              },
              end_date: {
                type: "string",
                description: "Event end date filter (YYYY-MM-DD)."
              },
              venue: {
                type: "number",
                description: "Filter by venue ID"
              },
              organizer: {
                type: "number",
                description: "Filter by organizer ID"
              },
              featured: {
                type: "boolean",
                description: "Filter featured events"
              },
              categories: {
                type: "array",
                items: {
                  type: "number"
                },
                description: "Filter by category IDs"
              },
              tags: {
                type: "array",
                items: {
                  type: "number"
                },
                description: "Filter by tag IDs"
              }
            },
            additionalProperties: false
          },
          venueFilters: {
            type: "object",
            description: 'Venue-specific filters (only used when postType is "venue")',
            properties: {
              city: {
                type: "string",
                description: "Filter by city"
              },
              state: {
                type: "string",
                description: "Filter by state/province"
              },
              country: {
                type: "string",
                description: "Filter by country"
              },
              zip: {
                type: "string",
                description: "Filter by postal code"
              },
              geo_lat: {
                type: "number",
                description: "Filter by latitude (requires geo_lng)"
              },
              geo_lng: {
                type: "number",
                description: "Filter by longitude (requires geo_lat)"
              },
              radius: {
                type: "number",
                description: "Filter by radius in km (requires geo_lat/geo_lng)"
              }
            },
            additionalProperties: false
          },
          organizerFilters: {
            type: "object",
            description: 'Organizer-specific filters (only used when postType is "organizer")',
            properties: {
              email: {
                type: "string",
                description: "Filter by email"
              },
              website: {
                type: "string",
                description: "Filter by website"
              },
              phone: {
                type: "string",
                description: "Filter by phone"
              }
            },
            additionalProperties: false
          },
          ticketFilters: {
            type: "object",
            description: 'Ticket-specific filters (only used when postType is "ticket")',
            properties: {
              event: {
                type: "number",
                description: "Filter by event ID"
              },
              provider: {
                type: "string",
                description: "Filter by provider (RSVP, Ticket Commerce, WooCommerce)"
              },
              type: {
                type: "string",
                enum: [
                  "rsvp",
                  "paid"
                ],
                description: "Filter by ticket type"
              },
              available: {
                type: "boolean",
                description: "Filter by availability"
              },
              min_price: {
                type: "number",
                description: "Filter by minimum price"
              },
              max_price: {
                type: "number",
                description: "Filter by maximum price"
              }
            },
            additionalProperties: false
          }
        },
        required: [
          "postType"
        ],
        additionalProperties: false
      },
      annotations: {
        title: "Read Calendar Entities",
        readOnlyHint: true,
        destructiveHint: false,
        idempotentHint: true,
        openWorldHint: false
      }
    },
    {
      name: "tec-calendar-delete-entities",
      description: 'Delete or trash a calendar post (Event, Venue, Organizer, or Ticket).\n\n- **Default** (force=false or omitted): Moves posts to trash where they can be restored\n- **Permanent delete** (force=true): Permanently deletes posts with no option to restore\n\n\n### Delete Behaviors\n\n- **Default** (`force=false`): Moves to trash (recoverable)\n- **Force delete** (`force=true`): Permanent deletion (not recoverable)\n\n### Best Practices\n\n- Always use default trash unless permanent deletion is required\n- Consider checking post details before deletion\n- For events, verify dates and timezone context first\n\n### Examples\n\n#### Event Deletion\n\nThe Events Calendar event post type with date, location, and ticketing information\n\n**Move to trash (default, recoverable)**\n```json\n{\n  "postType": "event",\n  "id": 123\n}\n```\n\n**Permanent deletion (not recoverable)**\n```json\n{\n  "postType": "event",\n  "id": 124,\n  "force": true\n}\n```\n\n#### Venue Deletion\n\nLocation where events take place, including address and contact information\n\n**Move to trash (default, recoverable)**\n```json\n{\n  "postType": "venue",\n  "id": 456\n}\n```\n\n**Permanent deletion (not recoverable)**\n```json\n{\n  "postType": "venue",\n  "id": 457,\n  "force": true\n}\n```\n\n#### Organizer Deletion\n\nPerson or organization responsible for hosting events\n\n**Move to trash (default, recoverable)**\n```json\n{\n  "postType": "organizer",\n  "id": 789\n}\n```\n\n**Permanent deletion (not recoverable)**\n```json\n{\n  "postType": "organizer",\n  "id": 790,\n  "force": true\n}\n```\n',
      inputSchema: {
        type: "object",
        properties: {
          postType: {
            type: "string",
            enum: [
              "event",
              "venue",
              "organizer",
              "ticket"
            ],
            description: "The type of post to delete"
          },
          id: {
            type: "number",
            description: "Post ID to delete"
          },
          force: {
            type: "boolean",
            description: "true for permanent delete, false for trash (default: false)",
            default: false
          }
        },
        required: [
          "postType",
          "id"
        ],
        additionalProperties: false
      },
      annotations: {
        title: "Delete Calendar Entities",
        readOnlyHint: false,
        destructiveHint: true,
        idempotentHint: false,
        openWorldHint: false
      }
    }
  ];

  // src/version.ts
  var VERSION = "0.1.6";

  // src/wordpress-integrations/angie/tec-mcp-server.ts
  function buildInstructions() {
    const now2 = /* @__PURE__ */ new Date();
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const offsetMinutes = -now2.getTimezoneOffset();
    const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);
    const offsetMins = Math.abs(offsetMinutes) % 60;
    const offsetSign = offsetMinutes >= 0 ? "+" : "-";
    const timezoneOffset = `${offsetSign}${String(offsetHours).padStart(2, "0")}:${String(offsetMins).padStart(2, "0")}`;
    const year = now2.getFullYear();
    const month = String(now2.getMonth() + 1).padStart(2, "0");
    const day = String(now2.getDate()).padStart(2, "0");
    const hours = String(now2.getHours()).padStart(2, "0");
    const minutes = String(now2.getMinutes()).padStart(2, "0");
    const seconds = String(now2.getSeconds()).padStart(2, "0");
    const datetime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    const iso8601 = now2.toISOString();
    const iso8601Space = iso8601.replace("T", " ").replace("Z", "");
    const today2 = `${year}-${month}-${day}`;
    const tomorrowDate = new Date(now2.getTime() + 24 * 60 * 60 * 1e3);
    const nextWeekDate = new Date(now2.getTime() + 7 * 24 * 60 * 60 * 1e3);
    const tomorrow2 = `${tomorrowDate.getFullYear()}-${String(tomorrowDate.getMonth() + 1).padStart(2, "0")}-${String(tomorrowDate.getDate()).padStart(2, "0")}`;
    const nextWeek = `${nextWeekDate.getFullYear()}-${String(nextWeekDate.getMonth() + 1).padStart(2, "0")}-${String(nextWeekDate.getDate()).padStart(2, "0")}`;
    const todayAt3pm = `${today2} 15:00:00`;
    const tomorrowAt10am = `${tomorrow2} 10:00:00`;
    return [
      "### The Events Calendar MCP Server Instructions",
      "",
      "**Purpose**: Interact with WordPress posts for Events, Venues, Organizers, and Tickets using the provided tools.",
      "",
      "### Time Context (precomputed to avoid extra calls)",
      `- **Local time**: ${datetime} (${timezone}, UTC offset ${timezoneOffset})`,
      `- **ISO (UTC)**: ${iso8601Space}`,
      "- **Usage hints**:",
      `  - **today_3pm**: ${todayAt3pm}`,
      `  - **tomorrow_10am**: ${tomorrowAt10am}`,
      `  - **next_week**: ${nextWeek}`,
      "",
      "### Date and Time Handling",
      '- **Events**: Use dates in `YYYY-MM-DD HH:MM:SS` format (e.g., "2025-01-15 14:30:00")',
      "- **Tickets**: All availability dates must be in `YYYY-MM-DD HH:MM:SS` format",
      "- **Sale price dates**: Use `YYYY-MM-DD` format",
      "- Prefer not sending a `timezone` field unless explicitly needed. Do not guess timezones.",
      "- When a timezone is required, use the site's timezone context; otherwise omit.",
      "",
      "### Available Tools",
      "- **tec-calendar-read-entities**: Read, list, or search posts with filters (events/venues/organizers/tickets)",
      "- **tec-calendar-create-update-entities**: Create or update posts with proper date formatting",
      "- **tec-calendar-delete-entities**: Trash or permanently delete posts",
      "",
      "### Important Notes",
      "- **Free tickets**: Omit `price` entirely (do not set it to 0)",
      "- **Unlimited tickets**: Set `stock_mode` to unlimited",
      "- **Response format**: Return concise JSON objects with IDs and essential fields",
      "",
      "### Post Types",
      "- **tribe_events**: Events",
      "- **tribe_venue**: Event venues",
      "- **tribe_organizer**: Event organizers",
      "- **tec_tc_ticket**: Event tickets (Commerce)",
      "- **tribe_rsvp_tickets**: RSVP tickets"
    ].join("\n");
  }
  function pad2(n2) {
    return String(n2).padStart(2, "0");
  }
  function formatDate(date) {
    return `${date.getFullYear()}-${pad2(date.getMonth() + 1)}-${pad2(date.getDate())}`;
  }
  function formatDateTime(date) {
    return `${formatDate(date)} ${pad2(date.getHours())}:${pad2(date.getMinutes())}:${pad2(date.getSeconds())}`;
  }
  function parseFlexibleDate(input) {
    try {
      const s2 = String(input).trim();
      const d2 = casual2.parseDate(s2, /* @__PURE__ */ new Date(), { forwardDate: true });
      if (d2 && Number.isFinite(d2.getTime())) return d2;
    } catch (e2) {
    }
    try {
      const results = parse(String(input));
      if (results && results.length > 0) {
        const d2 = results[0].date();
        if (Number.isFinite(d2.getTime())) return d2;
      }
    } catch (e2) {
    }
    const iso = new Date(String(input).replace(" ", "T"));
    if (Number.isFinite(iso.getTime())) return iso;
    const plain = new Date(String(input));
    if (Number.isFinite(plain.getTime())) return plain;
    return null;
  }
  function normalizeDateFields(data) {
    if (!data || typeof data !== "object") return { invalids: [] };
    const invalids = [];
    const dateTimeFields = ["start_date", "end_date", "start_date_utc", "end_date_utc"];
    const dateOnlyFields = ["sale_price_start_date", "sale_price_end_date"];
    const prefRegex = /^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$/;
    const dateOnlyRegex = /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/;
    for (const field of dateTimeFields) {
      if (typeof data[field] !== "string") continue;
      const raw = String(data[field]).trim();
      const parsed = parseFlexibleDate(raw);
      if (parsed) {
        data[field] = formatDateTime(parsed);
        continue;
      }
      if (!prefRegex.test(raw)) invalids.push({ field, value: raw });
    }
    for (const field of dateOnlyFields) {
      if (typeof data[field] !== "string") continue;
      const raw = String(data[field]).trim();
      const parsed = parseFlexibleDate(raw);
      if (parsed) {
        data[field] = formatDate(parsed);
        continue;
      }
      if (!dateOnlyRegex.test(raw)) invalids.push({ field, value: raw });
    }
    return { invalids };
  }
  var ENDPOINTS = {
    event: {
      namespace: "tec",
      resource: "events",
      version: "v1"
    },
    venue: {
      namespace: "tec",
      resource: "venues",
      version: "v1"
    },
    organizer: {
      namespace: "tec",
      resource: "organizers",
      version: "v1"
    },
    ticket: {
      namespace: "tec",
      resource: "tickets",
      version: "v1"
    }
  };
  function buildEndpointForTool(toolName, params) {
    console.log(`[TEC_MCP] Building endpoint for tool:`, { toolName, params });
    const postType = params == null ? void 0 : params.postType;
    const id = params == null ? void 0 : params.id;
    if (!postType || !ENDPOINTS[postType]) {
      console.error(`[TEC_MCP] Invalid post type:`, { postType, availableTypes: Object.keys(ENDPOINTS) });
      throw new Error(`Invalid post type: ${postType}`);
    }
    const config = ENDPOINTS[postType];
    const base = `${config.namespace}/${config.version}/${config.resource}`;
    console.log(`[TEC_MCP] Endpoint config for ${postType}:`, {
      namespace: config.namespace,
      version: config.version,
      resource: config.resource,
      base
    });
    switch (toolName) {
      case "tec-calendar-create-update-entities":
        return id ? `${base}/${id}` : base;
      case "tec-calendar-read-entities":
        if (id) {
          return `${base}/${id}`;
        }
        const queryParams = new URLSearchParams();
        if (params.search) {
          queryParams.append("search", params.search);
        }
        if (params.per_page) {
          queryParams.append("per_page", Math.min(params.per_page, 100).toString());
        }
        if (params.page) {
          queryParams.append("page", params.page);
        }
        if (params.orderby) {
          queryParams.append("orderby", params.orderby);
        }
        if (params.order) {
          queryParams.append("order", params.order);
        }
        Object.entries(params).forEach(([key, value]) => {
          if (!["postType", "id", "search", "per_page", "page", "orderby", "order"].includes(key) && value !== void 0) {
            queryParams.append(key, String(value));
          }
        });
        const query = queryParams.toString();
        return query ? `${base}?${query}` : base;
      case "tec-calendar-delete-entities":
        if (!id) {
          throw new Error("ID is required for delete operation");
        }
        const force = params.force ? "?force=true" : "";
        return `${base}/${id}${force}`;
      case "tec-calendar-current-datetime":
        throw new Error("Unknown tool: tec-calendar-current-datetime");
      default:
        throw new Error(`Unknown tool: ${toolName}`);
    }
  }
  var tecTools = tools_data_default;
  console.log(`[TEC_MCP] Loaded ${tecTools.length} tool definitions:`, tecTools.map((t2) => t2.name));
  console.log("[TEC_MCP] Full tool definitions with annotations:");
  tecTools.forEach((tool, index) => {
    var _a;
    console.log(`[TEC_MCP] Tool ${index + 1}: ${tool.name}`);
    console.log(`[TEC_MCP]   Title: ${((_a = tool.annotations) == null ? void 0 : _a.title) || "No title"}`);
    console.log(`[TEC_MCP]   Description: ${tool.description.substring(0, 100)}...`);
    console.log(`[TEC_MCP]   Annotations:`, tool.annotations);
    console.log(`[TEC_MCP]   Input Schema Properties:`, Object.keys(tool.inputSchema.properties || {}));
  });
  function createTecMcpServer() {
    console.log("[TEC_MCP] Creating server with low-level API...");
    const server = new Server(
      { name: "plugin-the-events-calendar", version: VERSION },
      { capabilities: { tools: {} } }
    );
    server.setRequestHandler(ListToolsRequestSchema, (_request) => __async(null, null, function* () {
      console.log("[TEC_MCP] Handling tools/list request");
      const tools = tecTools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        inputSchema: tool.inputSchema,
        annotations: tool.annotations
      }));
      console.log("[TEC_MCP] Returning tools with annotations:");
      tools.forEach((tool, index) => {
        var _a, _b, _c;
        console.log(`[TEC_MCP]   ${index + 1}. ${tool.name} - ${((_a = tool.annotations) == null ? void 0 : _a.title) || "No title"}`);
        console.log(`[TEC_MCP]      Read-only: ${((_b = tool.annotations) == null ? void 0 : _b.readOnlyHint) || false}`);
        console.log(`[TEC_MCP]      Destructive: ${((_c = tool.annotations) == null ? void 0 : _c.destructiveHint) || false}`);
      });
      return { tools };
    }));
    server.setRequestHandler(CallToolRequestSchema, (request) => __async(null, null, function* () {
      const { name: toolName, arguments: args = {} } = request.params;
      console.log(`[TEC_MCP] Tool called: ${toolName}`, { args, request });
      if (!globalThis.wpApiSettings) {
        console.error("[TEC_MCP] WordPress API settings not found");
        throw new Error("WordPress API settings not found. Make sure wp_localize_script is called.");
      }
      const { root, nonce } = globalThis.wpApiSettings;
      console.log(`[TEC_MCP] Using WordPress API:`, { root, nonceLength: nonce == null ? void 0 : nonce.length });
      const tool = tecTools.find((t2) => t2.name === toolName);
      if (!tool) {
        throw new Error(`Unknown tool: ${toolName}`);
      }
      try {
        if (toolName === "tec-calendar-create-update-entities" && args && args.data && typeof args.data === "object") {
          const { invalids } = normalizeDateFields(args.data);
          if (invalids.length > 0) {
            const details = JSON.stringify({ invalid_fields: invalids });
            throw new Error(`Invalid date format. Prefer 'YYYY-MM-DD HH:MM:SS'. Details: ${details}`);
          }
        }
        const endpoint = buildEndpointForTool(toolName, args);
        const url = `${root}${endpoint}`;
        console.log(`[TEC_MCP] Built endpoint URL:`, {
          tool: toolName,
          endpoint,
          fullUrl: url,
          root,
          args: JSON.stringify(args, null, 2)
        });
        let method = "GET";
        let body = void 0;
        switch (toolName) {
          case "tec-calendar-create-update-entities":
            method = args.id ? "PUT" : "POST";
            if (args && args.data && typeof args.data === "object" && args.data.status === void 0) {
              args.data.status = "publish";
            }
            body = JSON.stringify(args.data || {});
            break;
          case "tec-calendar-delete-entities":
            method = "DELETE";
            break;
        }
        console.log(`[TEC_MCP] Making API request:`, {
          method,
          url,
          hasBody: !!body,
          bodyContent: body ? JSON.parse(body) : null
        });
        const headers = {
          "Content-Type": "application/json",
          // Add experimental endpoint acknowledgement header for TEC v1 API
          "X-TEC-EEA": "I understand that this endpoint is experimental and may change in a future release without maintaining backward compatibility. I also understand that I am using this endpoint at my own risk, while support is not provided for it."
        };
        let finalUrl = url;
        if (args.postType === "ticket") {
          headers["X-WP-Nonce"] = nonce;
          finalUrl = url.includes("?") ? `${url}&_wpnonce=${nonce}` : `${url}?_wpnonce=${nonce}`;
          console.log(`[TEC_MCP] Special ticket authentication:`, {
            originalUrl: url,
            finalUrl,
            nonceInHeader: "X-WP-Nonce",
            nonceInUrl: "_wpnonce",
            nonceValue: nonce
          });
        } else {
          headers["X-WP-Nonce"] = nonce;
          console.log(`[TEC_MCP] Standard authentication for ${args.postType}:`, {
            url,
            nonceInHeader: "X-WP-Nonce",
            nonceValue: nonce
          });
        }
        console.log(`[TEC_MCP] Final request details:`, {
          url: finalUrl,
          method,
          headers,
          credentials: "same-origin",
          bodyLength: typeof body === "string" ? body.length : 0
        });
        const response = yield fetch(finalUrl, {
          method,
          headers,
          credentials: "same-origin",
          body
        });
        console.log(`[TEC_MCP] API response:`, {
          status: response.status,
          statusText: response.statusText,
          ok: response.ok,
          headers: Array.from(response.headers.entries()).reduce((acc, [k2, v2]) => __spreadProps(__spreadValues({}, acc), { [k2]: v2 }), {})
        });
        if (!response.ok) {
          const error = yield response.text();
          console.log(`[TEC_MCP] Error response body:`, error);
          let errorMessage;
          try {
            const errorJson = JSON.parse(error);
            console.log(`[TEC_MCP] Parsed error JSON:`, errorJson);
            errorMessage = errorJson.message || errorJson.code || response.statusText;
          } catch (e2) {
            console.log(`[TEC_MCP] Could not parse error as JSON, using raw text`);
            errorMessage = error || response.statusText;
          }
          throw new Error(`API request failed (${response.status}): ${errorMessage}`);
        }
        const result = yield response.json();
        console.log(`[TEC_MCP] Raw API result:`, result);
        let data = result;
        console.log(`[TEC_MCP] Response type:`, {
          isArray: Array.isArray(data),
          length: Array.isArray(data) ? data.length : "n/a",
          type: typeof data
        });
        return {
          content: [{
            type: "text",
            text: typeof data === "string" ? data : JSON.stringify(data, null, 2)
          }]
        };
      } catch (error) {
        console.error(`[TEC_MCP] Error calling tool ${toolName}:`, error);
        console.error("[TEC_MCP] Error details:", {
          message: error.message,
          stack: error.stack,
          tool: toolName,
          args
        });
        throw error;
      }
    }));
    return server;
  }
  function initializeTecMcpServer() {
    return __async(this, null, function* () {
      console.log("[TEC_MCP] Starting initialization...");
      try {
        console.log("[TEC_MCP] Creating MCP server...");
        const server = createTecMcpServer();
        console.log("[TEC_MCP] Server created, initializing Angie SDK...");
        const sdk = new ws();
        const config = {
          name: "plugin-the-events-calendar",
          version: VERSION,
          description: buildInstructions(),
          server
        };
        console.log("[TEC_MCP] Registering server with Angie SDK...", config);
        yield sdk.registerServer(config);
        console.log("[TEC_MCP] Server registered successfully with Angie");
        if (!globalThis.TEC_MCP) {
          globalThis.TEC_MCP = {
            createServer: createTecMcpServer,
            initialize: initializeTecMcpServer
          };
        }
        globalThis.TEC_MCP.server = server;
        globalThis.TEC_MCP.tools = tecTools;
      } catch (error) {
        console.error("[TEC_MCP] Failed to initialize server:", error);
        console.error("[TEC_MCP] Initialization error details:", {
          message: error == null ? void 0 : error.message,
          stack: error == null ? void 0 : error.stack,
          name: error == null ? void 0 : error.name
        });
      }
    });
  }
  console.log("[TEC_MCP] Module loaded, checking DOM state:", globalThis.document.readyState);
  if (globalThis.document.readyState === "loading") {
    console.log("[TEC_MCP] DOM still loading, waiting for DOMContentLoaded...");
    globalThis.document.addEventListener("DOMContentLoaded", () => {
      console.log("[TEC_MCP] DOMContentLoaded fired, initializing...");
      initializeTecMcpServer();
    });
  } else {
    console.log("[TEC_MCP] DOM already loaded, initializing immediately...");
    initializeTecMcpServer();
  }
  var tec_mcp_server_default = {
    createServer: createTecMcpServer,
    initialize: initializeTecMcpServer,
    tools: tecTools
  };
  if (typeof globalThis !== "undefined") {
    globalThis.TEC_MCP = {
      createServer: createTecMcpServer,
      initialize: initializeTecMcpServer,
      tools: tecTools
    };
  }
  return __toCommonJS(tec_mcp_server_exports);
})();
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
